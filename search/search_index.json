{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Modern C++: Snippets Modern C++ Snippets We often need to copy and paste some snippets to code more productively. Snippets can help us when it's not easy to remember all high levels features Modern C++ has to offer. This repository contains lots of organized, reusable, and safe snippets for Modern C++. All snippets are available in GitHub pages in a convenient way for copying and pasting.","title":"Home"},{"location":"#modern-c-snippets","text":"Modern C++ Snippets We often need to copy and paste some snippets to code more productively. Snippets can help us when it's not easy to remember all high levels features Modern C++ has to offer. This repository contains lots of organized, reusable, and safe snippets for Modern C++. All snippets are available in GitHub pages in a convenient way for copying and pasting.","title":"Modern C++: Snippets"},{"location":"contributors/","text":"Contributors Alan De Freitas Jo\u00e3o Vitor Vieira Discussions Discussions are concentrated on our GitHub discussions page. Don't refrain from asking questions and proposing ideas. If you are a programmer with good ideas, please share these ideas with us. Academic collaboration is more than welcome. Contributing Feel free to contribute with new snippets to this repository. For complex features and changes, consider getting feedback from the community first. There are many ways in which you can contribute to this library: Testing the library in new environments Contributing with interesting snippets Finding problems in the documentation Finding bugs in general Whatever idea seems interesting to you The only thing we ask you is to make sure your contribution is not destructive. Some contributions in which we are not interested are: \"I don't like this optional feature so I removed/deprecated it\" \"I removed this feature to support older versions of C++\" but have not provided an equivalent alternative. This repository is focused on Modern C++. \"I removed this feature, so I don't have to install/update ______\" but have not provided an equivalent alternative \"I'm creating this high-cost promise that we'll support _ _ forever\" but I'm not sticking around to keep that promise In doubt, please open a discussion first. Guidelines If contributing with code, please leave the pedantic warnings ON. You can use the helper CMake options -DBUILD_WITH_PEDANTIC_WARNINGS=ON :","title":"Contributors"},{"location":"contributors/#contributors","text":"Alan De Freitas Jo\u00e3o Vitor Vieira","title":"Contributors"},{"location":"contributors/#discussions","text":"Discussions are concentrated on our GitHub discussions page. Don't refrain from asking questions and proposing ideas. If you are a programmer with good ideas, please share these ideas with us. Academic collaboration is more than welcome.","title":"Discussions"},{"location":"contributors/#contributing","text":"Feel free to contribute with new snippets to this repository. For complex features and changes, consider getting feedback from the community first. There are many ways in which you can contribute to this library: Testing the library in new environments Contributing with interesting snippets Finding problems in the documentation Finding bugs in general Whatever idea seems interesting to you The only thing we ask you is to make sure your contribution is not destructive. Some contributions in which we are not interested are: \"I don't like this optional feature so I removed/deprecated it\" \"I removed this feature to support older versions of C++\" but have not provided an equivalent alternative. This repository is focused on Modern C++. \"I removed this feature, so I don't have to install/update ______\" but have not provided an equivalent alternative \"I'm creating this high-cost promise that we'll support _ _ forever\" but I'm not sticking around to keep that promise In doubt, please open a discussion first.","title":"Contributing"},{"location":"contributors/#guidelines","text":"If contributing with code, please leave the pedantic warnings ON. You can use the helper CMake options -DBUILD_WITH_PEDANTIC_WARNINGS=ON :","title":"Guidelines"},{"location":"quickstart/","text":"Quickstart Why C++ C++ has always been a great language for Scientific Computing, High-Performance Computing, and Data Analysis: Most programmers are familiar with its basic syntax; It's been among the most popular languages over last 40 years; Access to hundreds of thousands of high-performance libraries; Performance level almost no other language can achieve; Complex abstractions with zero-overhead ; Easy access to parallelism ; Numerous compilers with great optimization options available; Innumerable target platforms, from microcontrollers , to GPUs , to mobile , to webassembly ; Does not rely on any virtual machine; Easy bindings from/to virtually any other programming language ( Python , Javascript , PHP , R , Java , Matlab , Rust , Swift , Julia , C , ... you name it); Great tools for static analysis to avoid bugs; Avoids the two-languages problem in scientific computing: one for prototyping and one to reimplement all the work once the experiments are successful; No need for special licenses to distribute your compiled code, like it is common in technical languages that rely on virtual machines; Allows saving tons of money and extra-security for applications to be run in the cloud or dedicated servers. Why Modern C++ Many people have move from C++ over the last decade and might not be aware that the Modern C++ ecosystem has evolved to cover almost all use cases that made C++ inconvenient for certain tasks in the past: Efficient interpreters with beautiful IDEs ; Cross-platform build systems , including microcontrollers , GPUs , mobile and webassembly ; Package managers ; Type deduction ; Variant types ; Types for optional data ; Cheap automatic memory management via smart pointers ; Numerous data structures out of the box; Modules ; Concepts ; Functional programming ; Convenient meta programming ; Structured bindings and tuples ; Ranges ; Move semantics . By incentivizing and highlighting modern C++ features in instructional content , it's also possible to combine the familiar syntax of C and old C++ to achieve high levels of abstraction with a gentle learning curve. How this repository works Snippets The snippets directory has lots of short programs with useful C++ snippets GitHub actions ensures all snippets are working on GCC, MSVC, and Clang. We generate GitHub pages with all snippets by groups of tasks Libraries We give preference to libraries in this order: Libraries supported by most C++ compilers Libraries accepted into the C++ standard Libraries likely to be accepted into the next C++ standard Libraries representative of existing practice External Libraries For external libraries, we also include a short CMake snippet in the build script with: find_package to find, setup, and link the large external libraries FetchContents to download, build, and link the external library Snippets and Examples Examples are often long and don't represent independent tasks you can copy and paste. Snippets represent independent tasks you can copy and paste. Why not get my snippets directly from cppreference or cplusplus.com ? cppreference is not meant for snippets and this repository is not meant to be a reference for the C++ standard. Some implications are: The snippets: Meant to list the commands you most often need in a library. Lots of independent tasks for copying and pasting Include corresponding build scripts when something more complex is required Include external libraries when it's existing practice Organized roughly in the order someone learning C++ might need them The examples in cppreference or cplusplus.com: Meant to make points about the internals of the libraries. A single task meant to prove a point Has nothing to do with build scripts Has nothing to do with external libraries Might mix simple and complex concepts to make a point GitHub Pages We generate GitHub pages with all snippets: The GitHub pages are generated with mkdocs material Snippets are categorized by groups of tasks Sections are easy to explore, copy, and paste","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"","title":"Quickstart"},{"location":"quickstart/#why-c","text":"C++ has always been a great language for Scientific Computing, High-Performance Computing, and Data Analysis: Most programmers are familiar with its basic syntax; It's been among the most popular languages over last 40 years; Access to hundreds of thousands of high-performance libraries; Performance level almost no other language can achieve; Complex abstractions with zero-overhead ; Easy access to parallelism ; Numerous compilers with great optimization options available; Innumerable target platforms, from microcontrollers , to GPUs , to mobile , to webassembly ; Does not rely on any virtual machine; Easy bindings from/to virtually any other programming language ( Python , Javascript , PHP , R , Java , Matlab , Rust , Swift , Julia , C , ... you name it); Great tools for static analysis to avoid bugs; Avoids the two-languages problem in scientific computing: one for prototyping and one to reimplement all the work once the experiments are successful; No need for special licenses to distribute your compiled code, like it is common in technical languages that rely on virtual machines; Allows saving tons of money and extra-security for applications to be run in the cloud or dedicated servers.","title":"Why C++"},{"location":"quickstart/#why-modern-c","text":"Many people have move from C++ over the last decade and might not be aware that the Modern C++ ecosystem has evolved to cover almost all use cases that made C++ inconvenient for certain tasks in the past: Efficient interpreters with beautiful IDEs ; Cross-platform build systems , including microcontrollers , GPUs , mobile and webassembly ; Package managers ; Type deduction ; Variant types ; Types for optional data ; Cheap automatic memory management via smart pointers ; Numerous data structures out of the box; Modules ; Concepts ; Functional programming ; Convenient meta programming ; Structured bindings and tuples ; Ranges ; Move semantics . By incentivizing and highlighting modern C++ features in instructional content , it's also possible to combine the familiar syntax of C and old C++ to achieve high levels of abstraction with a gentle learning curve.","title":"Why Modern C++"},{"location":"quickstart/#how-this-repository-works","text":"","title":"How this repository works"},{"location":"quickstart/#snippets","text":"The snippets directory has lots of short programs with useful C++ snippets GitHub actions ensures all snippets are working on GCC, MSVC, and Clang. We generate GitHub pages with all snippets by groups of tasks","title":"Snippets"},{"location":"quickstart/#libraries","text":"We give preference to libraries in this order: Libraries supported by most C++ compilers Libraries accepted into the C++ standard Libraries likely to be accepted into the next C++ standard Libraries representative of existing practice","title":"Libraries"},{"location":"quickstart/#external-libraries","text":"For external libraries, we also include a short CMake snippet in the build script with: find_package to find, setup, and link the large external libraries FetchContents to download, build, and link the external library","title":"External Libraries"},{"location":"quickstart/#snippets-and-examples","text":"Examples are often long and don't represent independent tasks you can copy and paste. Snippets represent independent tasks you can copy and paste. Why not get my snippets directly from cppreference or cplusplus.com ? cppreference is not meant for snippets and this repository is not meant to be a reference for the C++ standard. Some implications are: The snippets: Meant to list the commands you most often need in a library. Lots of independent tasks for copying and pasting Include corresponding build scripts when something more complex is required Include external libraries when it's existing practice Organized roughly in the order someone learning C++ might need them The examples in cppreference or cplusplus.com: Meant to make points about the internals of the libraries. A single task meant to prove a point Has nothing to do with build scripts Has nothing to do with external libraries Might mix simple and complex concepts to make a point","title":"Snippets and Examples"},{"location":"quickstart/#github-pages","text":"We generate GitHub pages with all snippets: The GitHub pages are generated with mkdocs material Snippets are categorized by groups of tasks Sections are easy to explore, copy, and paste","title":"GitHub Pages"},{"location":"algorithms-data-structures/algorithm/basic-algorithms/","text":"Basic Algorithms Create number generator 1 2 3 std :: random_device rd ; std :: mt19937 generator { rd ()}; std :: uniform_int_distribution < int > distribution ( 1 , 30 ); Generating values 1 2 3 4 5 6 std :: vector < int > v ( 100 ); std :: generate ( v . begin (), v . end (), [ & ] { return distribution ( generator ); }); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << '\\n' ; Counting 1 2 std :: cout << \"There are \" << std :: count ( v . begin (), v . end (), 10 ) << \" tens\" << '\\n' ; Comparing sequences 1 2 3 4 auto v2 = v ; if ( std :: equal ( v . begin (), v . end (), v2 . begin ())) { std :: cout << \"v and v2 are the same\" << '\\n' ; } Finding elements 1 2 3 4 5 6 7 auto position = std :: find ( v . begin (), v . end (), 10 ); if ( position != v . end ()) { std :: cout << \"A ten was found in position \" << position - v . begin () << '\\n' ; } else { std :: cout << \"A ten was not found in any position\" << '\\n' ; } Finding elements from a set 1 2 3 4 5 6 7 8 9 10 std :: vector < int > set = { 16 , 15 , 14 }; auto position2 = std :: find_first_of ( v . begin (), v . end (), set . begin (), set . end ()); if ( position2 != v . end ()) { std :: cout << \"An element from the set was found in position \" << position2 - v . begin () << '\\n' ; } else { std :: cout << \"An element from the set was not found in any position\" << '\\n' ; } Finding mismatches 1 2 3 4 5 v2 [ v2 . size () / 3 ] ++ ; auto mpair = std :: mismatch ( v . begin (), v . end (), v2 . begin ()); std :: cout << \"Elements \" << * mpair . first << \" and \" << * mpair . second << \" mismatched at position \" << mpair . first - v . begin () << '\\n' ; Adjacent elements 1 2 3 4 5 6 7 auto i1 = std :: adjacent_find ( v . begin (), v . end ()); if ( i1 == v . end ()) { std :: cout << \"No matching adjacent elements\" << '\\n' ; } else { std :: cout << \"The first adjacent pair of equal elements at: \" << std :: distance ( v . begin (), i1 ) << '\\n' ; } Find subsequence 1 2 3 4 5 6 7 8 9 std :: vector < int > target = { v [ 30 ], v [ 31 ], v [ 32 ]}; auto result = std :: search ( v . begin (), v . end (), target . begin (), target . end ()); if ( result == v . end ()) { std :: cout << \"Subsequence not found\" << '\\n' ; } else { std :: cout << \"First subsequence is at: \" << std :: distance ( v . begin (), result ) << '\\n' ; } Find last subsequence 1 2 3 4 5 6 7 8 std :: vector < int > v3 = { v [ 30 ], v [ 31 ], v [ 32 ]}; auto result2 = std :: find_end ( v . begin (), v . end (), v3 . begin (), v3 . end ()); if ( result2 == v . end ()) { std :: cout << \"Subsequence not found\" << '\\n' ; } else { std :: cout << \"Last subsequence is at: \" << std :: distance ( v . begin (), result2 ) << '\\n' ; } Copying 1 2 3 4 std :: copy ( v . begin (), v . end (), v2 . begin ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << '\\n' ; Filling 1 2 3 4 std :: fill ( v2 . begin (), v2 . end (), 0 ); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << '\\n' ; Removing elements 1 2 3 4 v2 = v ; auto last_removed = std :: remove ( v2 . begin (), v2 . end (), 10 ); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); Erasing elements 1 2 3 v2 . erase ( last_removed , v2 . end ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); Replacing elements 1 2 3 std :: replace ( v2 . begin (), v2 . end (), 0 , 100 ); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); Swapping elements 1 2 3 std :: swap ( v , v2 ); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); Swapping ranges 1 2 3 std :: swap_ranges ( v . begin (), v . end (), v2 . begin ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); Reverse 1 2 3 std :: reverse ( v2 . begin (), v2 . end ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); Rotate left 1 2 3 std :: rotate ( v2 . begin (), v2 . begin () + 5 , v2 . end ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); Rotate right 1 2 3 std :: rotate ( v2 . rbegin (), v2 . rbegin () + 5 , v2 . rend ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); Shuffle 1 2 3 std :: shuffle ( v2 . begin (), v2 . end (), generator ); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); Sample 1 2 3 std :: sample ( v . begin (), v . end (), v2 . begin (), v . size (), generator ); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); Remove duplicates 1 2 3 4 5 6 7 8 9 10 std :: sort ( v2 . begin (), v2 . end ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << '\\n' ; auto last_unique = std :: unique ( v2 . begin (), v2 . end ()); v2 . erase ( last_unique , v2 . end ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << '\\n' ; Sorting (Usually Introsort = Quicksort + Heapsort) 1 2 3 std :: sort ( v2 . begin (), v2 . end ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); Checking if sorted 1 2 3 if ( std :: is_sorted ( v2 . begin (), v2 . end ())) { std :: cout << \"The vector is sorted\" << '\\n' ; } Sorting partially 1 2 3 4 v2 = v ; std :: partial_sort ( v2 . begin (), v2 . begin () + 15 , v2 . end ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); Stable Sorting 1 2 3 std :: stable_sort ( v2 . begin (), v2 . end ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); Median and percentiles 1 2 3 4 5 6 v2 = v ; std :: nth_element ( v2 . begin (), v2 . begin () + v2 . size () / 2 , v2 . end ()); std :: cout << \"The median is \" << v [ v . size () / 2 ] << '\\n' ; std :: nth_element ( v2 . begin (), v2 . begin () + 1 , v2 . end ()); std :: cout << \"The second smallest element is \" << v2 [ 1 ] << '\\n' ; Binary search 1 2 3 4 5 6 std :: sort ( v . begin (), v . end ()); // prepare if ( std :: binary_search ( v . begin (), v . end (), 15 )) { std :: cout << \"Element 15 found\" << '\\n' ; } else { std :: cout << \"Element 15 not found\" << '\\n' ; } Binary Search Lower bound 1 2 3 4 5 6 7 auto lower = std :: lower_bound ( v . begin (), v . end (), 15 ); if ( lower != v . end ()) { std :: cout << \"First 15 at position \" << lower - v . begin () << '\\n' ; } else { std :: cout << \"15 not found\" << '\\n' ; } Binary Search Upper bound 1 2 3 4 5 6 7 auto upper = std :: upper_bound ( v . begin (), v . end (), 15 ); if ( upper != v . end ()) { std :: cout << \"Last 15 at position \" << upper - v . begin () << '\\n' ; } else { std :: cout << \"Last 15 not found\" << '\\n' ; } Binary Search Equal Range (From lower to upper bound) 1 2 3 4 5 auto range = std :: equal_range ( v . begin (), v . end (), 15 ); if ( range . first != v . end ()) { std :: cout << \"15 from positions \" << range . first - v . begin () << \" to \" << range . second - v . begin () << '\\n' ; } Creating heaps 1 2 3 4 5 std :: make_heap ( v . begin (), v . end ()); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << '\\n' ; std :: cout << \"The largest element is \" << v . front () << '\\n' ; Pushing elements to heap 1 2 3 4 5 v . push_back ( 31 ); std :: push_heap ( v . begin (), v . end ()); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << '\\n' ; Popping elements from heap 1 2 3 4 5 std :: pop_heap ( v . begin (), v . end ()); v . pop_back (); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << '\\n' ; Sorting heap 1 2 3 4 std :: sort_heap ( v . begin (), v . end ()); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << '\\n' ; Min/Max Values 1 2 std :: cout << \"min: \" << std :: min ( 9 , 3 ) << \", max = \" << std :: max ( 9 , 3 ) << '\\n' ; Min/Max Bounds 1 2 3 4 5 6 7 std :: pair < int , int > bounds = std :: minmax ( std :: rand () % v . size (), std :: rand () % v . size ()); std :: cout << \"v[\" << bounds . first << \",\" << bounds . second << \"]: \" ; for ( int i = bounds . first ; i < bounds . second ; ++ i ) { std :: cout << v [ i ] << ' ' ; } std :: cout << '\\n' ; Max element 1 2 3 auto max_i = std :: max_element ( v . begin (), v . end ()); std :: cout << \"Max element at: \" << std :: distance ( v . begin (), max_i ) << '\\n' ; Min element 1 2 3 auto min_i = std :: min_element ( v . begin (), v . end ()); std :: cout << \"Min element at: \" << std :: distance ( v . begin (), min_i ) << '\\n' ; Min/max elements 1 2 3 auto result = std :: minmax_element ( v . begin (), v . end ()); std :: cout << \"min element at: \" << ( result . first - v . begin ()) << '\\n' ; std :: cout << \"max element at: \" << ( result . second - v . begin ()) << '\\n' ; Check permutation 1 2 3 4 5 6 std :: vector < int > v1 { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v2 { 3 , 5 , 4 , 1 , 2 }; std :: cout << \"3,5,4,1,2 is a permutation of 1,2,3,4,5? \" << std :: boolalpha << std :: is_permutation ( v1 . begin (), v1 . end (), v2 . begin ()) << '\\n' ; Get permutations 1 2 3 4 5 6 std :: vector < int > v3 { 1 , 2 , 3 }; do { std :: for_each ( v3 . begin (), v3 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << '\\n' ; } while ( std :: next_permutation ( v3 . begin (), v3 . end ())); Sequentially increasing values 1 2 3 4 std :: iota ( v . begin (), v . end (), 0 ); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << '\\n' ; Accumulating 1 2 std :: cout << \"Total \" << std :: accumulate ( v . begin (), v . end (), 0 ) << '\\n' ; Inner product 1 2 3 4 std :: vector < int > a { 0 , 1 , 2 , 3 , 4 }; std :: vector < int > b { 5 , 4 , 2 , 3 , 1 }; int r1 = std :: inner_product ( a . begin (), a . end (), b . begin (), 0 ); std :: cout << \"Inner product of a and b: \" << r1 << '\\n' ; Adjacent difference 1 2 3 4 5 std :: vector < int > x { 1 , 4 , 7 , 8 , 11 , 11 , 14 , 15 , 19 , 22 }; std :: adjacent_difference ( x . begin (), x . end (), x . begin ()); std :: for_each ( x . begin (), x . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << '\\n' ; Partial sum 1 2 3 std :: partial_sum ( x . begin (), x . end (), std :: ostream_iterator < int > ( std :: cout , \" \" )); std :: cout << '\\n' ; Share Snippets","title":"Basic Algorithms"},{"location":"algorithms-data-structures/algorithm/basic-algorithms/#basic-algorithms","text":"Create number generator 1 2 3 std :: random_device rd ; std :: mt19937 generator { rd ()}; std :: uniform_int_distribution < int > distribution ( 1 , 30 ); Generating values 1 2 3 4 5 6 std :: vector < int > v ( 100 ); std :: generate ( v . begin (), v . end (), [ & ] { return distribution ( generator ); }); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << '\\n' ; Counting 1 2 std :: cout << \"There are \" << std :: count ( v . begin (), v . end (), 10 ) << \" tens\" << '\\n' ; Comparing sequences 1 2 3 4 auto v2 = v ; if ( std :: equal ( v . begin (), v . end (), v2 . begin ())) { std :: cout << \"v and v2 are the same\" << '\\n' ; } Finding elements 1 2 3 4 5 6 7 auto position = std :: find ( v . begin (), v . end (), 10 ); if ( position != v . end ()) { std :: cout << \"A ten was found in position \" << position - v . begin () << '\\n' ; } else { std :: cout << \"A ten was not found in any position\" << '\\n' ; } Finding elements from a set 1 2 3 4 5 6 7 8 9 10 std :: vector < int > set = { 16 , 15 , 14 }; auto position2 = std :: find_first_of ( v . begin (), v . end (), set . begin (), set . end ()); if ( position2 != v . end ()) { std :: cout << \"An element from the set was found in position \" << position2 - v . begin () << '\\n' ; } else { std :: cout << \"An element from the set was not found in any position\" << '\\n' ; } Finding mismatches 1 2 3 4 5 v2 [ v2 . size () / 3 ] ++ ; auto mpair = std :: mismatch ( v . begin (), v . end (), v2 . begin ()); std :: cout << \"Elements \" << * mpair . first << \" and \" << * mpair . second << \" mismatched at position \" << mpair . first - v . begin () << '\\n' ; Adjacent elements 1 2 3 4 5 6 7 auto i1 = std :: adjacent_find ( v . begin (), v . end ()); if ( i1 == v . end ()) { std :: cout << \"No matching adjacent elements\" << '\\n' ; } else { std :: cout << \"The first adjacent pair of equal elements at: \" << std :: distance ( v . begin (), i1 ) << '\\n' ; } Find subsequence 1 2 3 4 5 6 7 8 9 std :: vector < int > target = { v [ 30 ], v [ 31 ], v [ 32 ]}; auto result = std :: search ( v . begin (), v . end (), target . begin (), target . end ()); if ( result == v . end ()) { std :: cout << \"Subsequence not found\" << '\\n' ; } else { std :: cout << \"First subsequence is at: \" << std :: distance ( v . begin (), result ) << '\\n' ; } Find last subsequence 1 2 3 4 5 6 7 8 std :: vector < int > v3 = { v [ 30 ], v [ 31 ], v [ 32 ]}; auto result2 = std :: find_end ( v . begin (), v . end (), v3 . begin (), v3 . end ()); if ( result2 == v . end ()) { std :: cout << \"Subsequence not found\" << '\\n' ; } else { std :: cout << \"Last subsequence is at: \" << std :: distance ( v . begin (), result2 ) << '\\n' ; } Copying 1 2 3 4 std :: copy ( v . begin (), v . end (), v2 . begin ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << '\\n' ; Filling 1 2 3 4 std :: fill ( v2 . begin (), v2 . end (), 0 ); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << '\\n' ; Removing elements 1 2 3 4 v2 = v ; auto last_removed = std :: remove ( v2 . begin (), v2 . end (), 10 ); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); Erasing elements 1 2 3 v2 . erase ( last_removed , v2 . end ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); Replacing elements 1 2 3 std :: replace ( v2 . begin (), v2 . end (), 0 , 100 ); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); Swapping elements 1 2 3 std :: swap ( v , v2 ); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); Swapping ranges 1 2 3 std :: swap_ranges ( v . begin (), v . end (), v2 . begin ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); Reverse 1 2 3 std :: reverse ( v2 . begin (), v2 . end ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); Rotate left 1 2 3 std :: rotate ( v2 . begin (), v2 . begin () + 5 , v2 . end ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); Rotate right 1 2 3 std :: rotate ( v2 . rbegin (), v2 . rbegin () + 5 , v2 . rend ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); Shuffle 1 2 3 std :: shuffle ( v2 . begin (), v2 . end (), generator ); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); Sample 1 2 3 std :: sample ( v . begin (), v . end (), v2 . begin (), v . size (), generator ); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); Remove duplicates 1 2 3 4 5 6 7 8 9 10 std :: sort ( v2 . begin (), v2 . end ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << '\\n' ; auto last_unique = std :: unique ( v2 . begin (), v2 . end ()); v2 . erase ( last_unique , v2 . end ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << '\\n' ; Sorting (Usually Introsort = Quicksort + Heapsort) 1 2 3 std :: sort ( v2 . begin (), v2 . end ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); Checking if sorted 1 2 3 if ( std :: is_sorted ( v2 . begin (), v2 . end ())) { std :: cout << \"The vector is sorted\" << '\\n' ; } Sorting partially 1 2 3 4 v2 = v ; std :: partial_sort ( v2 . begin (), v2 . begin () + 15 , v2 . end ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); Stable Sorting 1 2 3 std :: stable_sort ( v2 . begin (), v2 . end ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); Median and percentiles 1 2 3 4 5 6 v2 = v ; std :: nth_element ( v2 . begin (), v2 . begin () + v2 . size () / 2 , v2 . end ()); std :: cout << \"The median is \" << v [ v . size () / 2 ] << '\\n' ; std :: nth_element ( v2 . begin (), v2 . begin () + 1 , v2 . end ()); std :: cout << \"The second smallest element is \" << v2 [ 1 ] << '\\n' ; Binary search 1 2 3 4 5 6 std :: sort ( v . begin (), v . end ()); // prepare if ( std :: binary_search ( v . begin (), v . end (), 15 )) { std :: cout << \"Element 15 found\" << '\\n' ; } else { std :: cout << \"Element 15 not found\" << '\\n' ; } Binary Search Lower bound 1 2 3 4 5 6 7 auto lower = std :: lower_bound ( v . begin (), v . end (), 15 ); if ( lower != v . end ()) { std :: cout << \"First 15 at position \" << lower - v . begin () << '\\n' ; } else { std :: cout << \"15 not found\" << '\\n' ; } Binary Search Upper bound 1 2 3 4 5 6 7 auto upper = std :: upper_bound ( v . begin (), v . end (), 15 ); if ( upper != v . end ()) { std :: cout << \"Last 15 at position \" << upper - v . begin () << '\\n' ; } else { std :: cout << \"Last 15 not found\" << '\\n' ; } Binary Search Equal Range (From lower to upper bound) 1 2 3 4 5 auto range = std :: equal_range ( v . begin (), v . end (), 15 ); if ( range . first != v . end ()) { std :: cout << \"15 from positions \" << range . first - v . begin () << \" to \" << range . second - v . begin () << '\\n' ; } Creating heaps 1 2 3 4 5 std :: make_heap ( v . begin (), v . end ()); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << '\\n' ; std :: cout << \"The largest element is \" << v . front () << '\\n' ; Pushing elements to heap 1 2 3 4 5 v . push_back ( 31 ); std :: push_heap ( v . begin (), v . end ()); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << '\\n' ; Popping elements from heap 1 2 3 4 5 std :: pop_heap ( v . begin (), v . end ()); v . pop_back (); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << '\\n' ; Sorting heap 1 2 3 4 std :: sort_heap ( v . begin (), v . end ()); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << '\\n' ; Min/Max Values 1 2 std :: cout << \"min: \" << std :: min ( 9 , 3 ) << \", max = \" << std :: max ( 9 , 3 ) << '\\n' ; Min/Max Bounds 1 2 3 4 5 6 7 std :: pair < int , int > bounds = std :: minmax ( std :: rand () % v . size (), std :: rand () % v . size ()); std :: cout << \"v[\" << bounds . first << \",\" << bounds . second << \"]: \" ; for ( int i = bounds . first ; i < bounds . second ; ++ i ) { std :: cout << v [ i ] << ' ' ; } std :: cout << '\\n' ; Max element 1 2 3 auto max_i = std :: max_element ( v . begin (), v . end ()); std :: cout << \"Max element at: \" << std :: distance ( v . begin (), max_i ) << '\\n' ; Min element 1 2 3 auto min_i = std :: min_element ( v . begin (), v . end ()); std :: cout << \"Min element at: \" << std :: distance ( v . begin (), min_i ) << '\\n' ; Min/max elements 1 2 3 auto result = std :: minmax_element ( v . begin (), v . end ()); std :: cout << \"min element at: \" << ( result . first - v . begin ()) << '\\n' ; std :: cout << \"max element at: \" << ( result . second - v . begin ()) << '\\n' ; Check permutation 1 2 3 4 5 6 std :: vector < int > v1 { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v2 { 3 , 5 , 4 , 1 , 2 }; std :: cout << \"3,5,4,1,2 is a permutation of 1,2,3,4,5? \" << std :: boolalpha << std :: is_permutation ( v1 . begin (), v1 . end (), v2 . begin ()) << '\\n' ; Get permutations 1 2 3 4 5 6 std :: vector < int > v3 { 1 , 2 , 3 }; do { std :: for_each ( v3 . begin (), v3 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << '\\n' ; } while ( std :: next_permutation ( v3 . begin (), v3 . end ())); Sequentially increasing values 1 2 3 4 std :: iota ( v . begin (), v . end (), 0 ); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << '\\n' ; Accumulating 1 2 std :: cout << \"Total \" << std :: accumulate ( v . begin (), v . end (), 0 ) << '\\n' ; Inner product 1 2 3 4 std :: vector < int > a { 0 , 1 , 2 , 3 , 4 }; std :: vector < int > b { 5 , 4 , 2 , 3 , 1 }; int r1 = std :: inner_product ( a . begin (), a . end (), b . begin (), 0 ); std :: cout << \"Inner product of a and b: \" << r1 << '\\n' ; Adjacent difference 1 2 3 4 5 std :: vector < int > x { 1 , 4 , 7 , 8 , 11 , 11 , 14 , 15 , 19 , 22 }; std :: adjacent_difference ( x . begin (), x . end (), x . begin ()); std :: for_each ( x . begin (), x . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << '\\n' ; Partial sum 1 2 3 std :: partial_sum ( x . begin (), x . end (), std :: ostream_iterator < int > ( std :: cout , \" \" )); std :: cout << '\\n' ; Share Snippets","title":"Basic Algorithms"},{"location":"algorithms-data-structures/algorithm/ranges/","text":"Ranges Ranges The ranges library is an extension and generalization of the algorithms and iterator libraries that makes them more powerful by making them composable and less error-prone. All algorithms that take iterator pairs have overloads that accept ranges (e.g ranges::sort). The library creates and manipulates range views, lightweight objects that indirectly represent iterable sequences (ranges). Ranges are an abstraction on top of [begin, end) iterator pairs, e.g. ranges made by implicit conversion from containers. The ranges library was originally developed as the range-v3 library , and was finally merged to ISO C++ as of C++20. The range-v3 implementation is currently available on more compilers and platforms than the C++20 library. CMakeLists.txt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # Ranges in C++20: https://en.cppreference.com/w/cpp/ranges # Use range-v3 for now: https://github.com/ericniebler/range-v3 find_package ( range-v3 QUIET ) if ( NOT range-v3_FOUND ) FetchContent_Declare ( range-v3 URL https://github.com/ericniebler/range-v3/archive/0.11.0.zip ) FetchContent_GetProperties ( range-v3 ) if ( NOT range-v3_POPULATED ) FetchContent_Populate ( range-v3 ) add_library ( range-v3 INTERFACE IMPORTED ) target_include_directories ( range-v3 INTERFACE \"${range-v3_SOURCE_DIR}/include\" ) endif () endif () add_executable ( ranges ranges.cpp ) target_link_libraries ( ranges PUBLIC range-v3 ) Headers 1 #include <range/v3/all.hpp> Sequentially increasing range 1 2 std :: vector < double > v ( 30 ); ranges :: iota ( v , 1 ); Counting 1 std :: cout << ranges :: count ( v , 0 ) << '\\n' ; Accumulating 1 std :: cout << ranges :: accumulate ( v , 0 ) << '\\n' ; Sorting 1 ranges :: sort ( v ); Binary Search 1 std :: cout << ranges :: binary_search ( v , 15 ) << '\\n' ; Check if sorted 1 std :: cout << ranges :: is_sorted ( v ) << '\\n' ; For each 1 2 ranges :: for_each ( v , []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << '\\n' ; Filter views 1 2 3 std :: array < int , 6 > a {{ 0 , 5 , 2 , 1 , 3 , 4 }}; auto filtered_range = ranges :: views :: filter ( a , []( int i ) { return i > 2 ; }); std :: vector < int > v2 ( filtered_range . begin (), filtered_range . end ()); Reversed view 1 2 3 4 auto reversed_range = ranges :: views :: reverse ( a ); for ( int x : reversed_range ) { std :: cout << x << ' ' ; } Unique view 1 2 3 4 5 ranges :: sort ( a ); auto unique_range = ranges :: views :: unique ( a ); for ( int x : unique_range ) { std :: cout << x << ' ' ; } Keys view 1 2 3 4 5 6 7 8 std :: map < std :: string , int > m ; m [ \"a\" ] = 0 ; m [ \"b\" ] = 1 ; m [ \"c\" ] = 2 ; auto map_keys = ranges :: views :: keys ( m ); for ( const std :: string & k : map_keys ) { std :: cout << k << \",\" ; } Tokenize view 1 2 3 4 5 6 7 std :: string s = \"The range v3 library\" ; std :: regex expr { \"[ \\\\ w+]+\" }; auto tokenizer = ranges :: views :: tokenize ( s , expr , 0 , std :: regex_constants :: match_default ); for ( auto & x : tokenizer ) { std :: cout << x << \",\" ; } Integer views 1 2 3 4 auto ir = ranges :: views :: ints ( 0 , 3 ); for ( auto x : ir ) { std :: cout << x << \",\" ; } Share Snippets","title":"Ranges"},{"location":"algorithms-data-structures/algorithm/ranges/#ranges","text":"Ranges The ranges library is an extension and generalization of the algorithms and iterator libraries that makes them more powerful by making them composable and less error-prone. All algorithms that take iterator pairs have overloads that accept ranges (e.g ranges::sort). The library creates and manipulates range views, lightweight objects that indirectly represent iterable sequences (ranges). Ranges are an abstraction on top of [begin, end) iterator pairs, e.g. ranges made by implicit conversion from containers. The ranges library was originally developed as the range-v3 library , and was finally merged to ISO C++ as of C++20. The range-v3 implementation is currently available on more compilers and platforms than the C++20 library. CMakeLists.txt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # Ranges in C++20: https://en.cppreference.com/w/cpp/ranges # Use range-v3 for now: https://github.com/ericniebler/range-v3 find_package ( range-v3 QUIET ) if ( NOT range-v3_FOUND ) FetchContent_Declare ( range-v3 URL https://github.com/ericniebler/range-v3/archive/0.11.0.zip ) FetchContent_GetProperties ( range-v3 ) if ( NOT range-v3_POPULATED ) FetchContent_Populate ( range-v3 ) add_library ( range-v3 INTERFACE IMPORTED ) target_include_directories ( range-v3 INTERFACE \"${range-v3_SOURCE_DIR}/include\" ) endif () endif () add_executable ( ranges ranges.cpp ) target_link_libraries ( ranges PUBLIC range-v3 ) Headers 1 #include <range/v3/all.hpp> Sequentially increasing range 1 2 std :: vector < double > v ( 30 ); ranges :: iota ( v , 1 ); Counting 1 std :: cout << ranges :: count ( v , 0 ) << '\\n' ; Accumulating 1 std :: cout << ranges :: accumulate ( v , 0 ) << '\\n' ; Sorting 1 ranges :: sort ( v ); Binary Search 1 std :: cout << ranges :: binary_search ( v , 15 ) << '\\n' ; Check if sorted 1 std :: cout << ranges :: is_sorted ( v ) << '\\n' ; For each 1 2 ranges :: for_each ( v , []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << '\\n' ; Filter views 1 2 3 std :: array < int , 6 > a {{ 0 , 5 , 2 , 1 , 3 , 4 }}; auto filtered_range = ranges :: views :: filter ( a , []( int i ) { return i > 2 ; }); std :: vector < int > v2 ( filtered_range . begin (), filtered_range . end ()); Reversed view 1 2 3 4 auto reversed_range = ranges :: views :: reverse ( a ); for ( int x : reversed_range ) { std :: cout << x << ' ' ; } Unique view 1 2 3 4 5 ranges :: sort ( a ); auto unique_range = ranges :: views :: unique ( a ); for ( int x : unique_range ) { std :: cout << x << ' ' ; } Keys view 1 2 3 4 5 6 7 8 std :: map < std :: string , int > m ; m [ \"a\" ] = 0 ; m [ \"b\" ] = 1 ; m [ \"c\" ] = 2 ; auto map_keys = ranges :: views :: keys ( m ); for ( const std :: string & k : map_keys ) { std :: cout << k << \",\" ; } Tokenize view 1 2 3 4 5 6 7 std :: string s = \"The range v3 library\" ; std :: regex expr { \"[ \\\\ w+]+\" }; auto tokenizer = ranges :: views :: tokenize ( s , expr , 0 , std :: regex_constants :: match_default ); for ( auto & x : tokenizer ) { std :: cout << x << \",\" ; } Integer views 1 2 3 4 auto ir = ranges :: views :: ints ( 0 , 3 ); for ( auto x : ir ) { std :: cout << x << \",\" ; } Share Snippets","title":"Ranges"},{"location":"algorithms-data-structures/algorithm/searching/","text":"Searching Create vector for searching 1 std :: vector v = { 5 , 4 , 9 , 8 , 6 , 3 }; Sequential search from the standard library 1 2 3 4 5 6 7 // - std::find is what you would use daily // - don't implement your own version unless you're studying the algorithms auto i1 = std :: find ( v . begin (), v . end (), 6 ); if ( i1 != v . end ()) { std :: cout << \"*i1: \" << * i1 << '\\n' ; } std :: cout << \"position: \" << i1 - v . begin () << '\\n' ; Prepare vector for binary search 1 sort ( v . begin (), v . end ()); Binary search from the standard library 1 2 3 4 5 6 7 // - std::lower_bound is what you would use daily // - don't implement your own version unless you're studying the algorithms auto i2 = lower_bound ( v . begin (), v . end (), 6 ); if ( i2 != v . end ()) { std :: cout << \"*i2: \" << * i2 << '\\n' ; } std :: cout << \"position: \" << i2 - v . begin () << '\\n' ; Textbook sequential search based on subscripts 1 2 3 4 5 6 7 8 9 10 11 // This is what you would probably learn in college // Example only. Use std::find instead. size_t sequential_find ( const std :: vector < int > & v , const int key ) { for ( size_t i = 0 ; i < v . size (); ++ i ) { if ( v [ i ] == key ) { return i ; } } // return a sentinel return v . size (); } C++ sequential search based on iterators 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // This is what works in C++ for most container types. // Example only. Use std::find instead. template < class It , class T > constexpr It sequential_find ( It first , It last , const T & value ) { for (; first != last ; ++ first ) { // Best: O(1) // Worst: O(n) // Average: O(n) if ( * first == value ) { return first ; } } // return a sentinel return last ; } Call sequential search (vector + the textbook convention) 1 2 3 4 5 size_t pos1 = sequential_find ( v , 6 ); if ( pos1 != v . size ()) { std :: cout << \"value: \" << v [ pos1 ] << '\\n' ; } std :: cout << \"position: \" << pos1 << '\\n' ; Sequential search (iterators + the C++ convention) 1 2 3 4 5 auto it1 = sequential_find ( v . begin (), v . end (), 6 ); if ( it1 != v . end ()) { std :: cout << \"*it1: \" << * it1 << '\\n' ; } std :: cout << \"position: \" << it1 - v . begin () << '\\n' ; Textbook binary search based on subscripts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // This is what you would probably learn in college // Example only. Use std::lower_bound instead. size_t binary_find ( const std :: vector < int > & v , const int key ) { size_t left_idx = 0 ; size_t right_idx = v . size () - 1 ; size_t i ; do { i = ( left_idx + right_idx ) / 2 ; if ( v [ i ] < key ) { left_idx = i + 1 ; } else { right_idx = i - 1 ; } } while ( v [ i ] != key && left_idx <= right_idx ); return v [ i ] == key ? i : v . size (); } C++ binary search based on iterators 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // This is what works in C++ for most container types. // Example only. Use std::lower_bound instead. template < class It , class T > It binary_find ( It first , It last , const T & value ) { typename std :: iterator_traits < It >:: difference_type count , step ; It it ; count = std :: distance ( first , last ); while ( count > 0 ) { it = first ; step = count / 2 ; std :: advance ( it , step ); if ( * it < value ) { first = ++ it ; count -= step + 1 ; } else { count = step ; } } return first ; } Binary search (vector + the textbook convention) 1 2 3 4 5 size_t pos2 = binary_find ( v , 6 ); if ( pos2 != v . size ()) { std :: cout << \"value: \" << v [ pos2 ] << '\\n' ; } std :: cout << \"position: \" << pos2 << '\\n' ; Binary search (iterators + the C++ convention) 1 2 3 4 5 auto it2 = binary_find ( v . begin (), v . end (), 6 ); if ( it2 != v . end ()) { std :: cout << \"*it2: \" << * it2 << '\\n' ; } std :: cout << \"position: \" << it2 - v . begin () << '\\n' ; Share Snippets","title":"Searching"},{"location":"algorithms-data-structures/algorithm/searching/#searching","text":"Create vector for searching 1 std :: vector v = { 5 , 4 , 9 , 8 , 6 , 3 }; Sequential search from the standard library 1 2 3 4 5 6 7 // - std::find is what you would use daily // - don't implement your own version unless you're studying the algorithms auto i1 = std :: find ( v . begin (), v . end (), 6 ); if ( i1 != v . end ()) { std :: cout << \"*i1: \" << * i1 << '\\n' ; } std :: cout << \"position: \" << i1 - v . begin () << '\\n' ; Prepare vector for binary search 1 sort ( v . begin (), v . end ()); Binary search from the standard library 1 2 3 4 5 6 7 // - std::lower_bound is what you would use daily // - don't implement your own version unless you're studying the algorithms auto i2 = lower_bound ( v . begin (), v . end (), 6 ); if ( i2 != v . end ()) { std :: cout << \"*i2: \" << * i2 << '\\n' ; } std :: cout << \"position: \" << i2 - v . begin () << '\\n' ; Textbook sequential search based on subscripts 1 2 3 4 5 6 7 8 9 10 11 // This is what you would probably learn in college // Example only. Use std::find instead. size_t sequential_find ( const std :: vector < int > & v , const int key ) { for ( size_t i = 0 ; i < v . size (); ++ i ) { if ( v [ i ] == key ) { return i ; } } // return a sentinel return v . size (); } C++ sequential search based on iterators 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // This is what works in C++ for most container types. // Example only. Use std::find instead. template < class It , class T > constexpr It sequential_find ( It first , It last , const T & value ) { for (; first != last ; ++ first ) { // Best: O(1) // Worst: O(n) // Average: O(n) if ( * first == value ) { return first ; } } // return a sentinel return last ; } Call sequential search (vector + the textbook convention) 1 2 3 4 5 size_t pos1 = sequential_find ( v , 6 ); if ( pos1 != v . size ()) { std :: cout << \"value: \" << v [ pos1 ] << '\\n' ; } std :: cout << \"position: \" << pos1 << '\\n' ; Sequential search (iterators + the C++ convention) 1 2 3 4 5 auto it1 = sequential_find ( v . begin (), v . end (), 6 ); if ( it1 != v . end ()) { std :: cout << \"*it1: \" << * it1 << '\\n' ; } std :: cout << \"position: \" << it1 - v . begin () << '\\n' ; Textbook binary search based on subscripts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // This is what you would probably learn in college // Example only. Use std::lower_bound instead. size_t binary_find ( const std :: vector < int > & v , const int key ) { size_t left_idx = 0 ; size_t right_idx = v . size () - 1 ; size_t i ; do { i = ( left_idx + right_idx ) / 2 ; if ( v [ i ] < key ) { left_idx = i + 1 ; } else { right_idx = i - 1 ; } } while ( v [ i ] != key && left_idx <= right_idx ); return v [ i ] == key ? i : v . size (); } C++ binary search based on iterators 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // This is what works in C++ for most container types. // Example only. Use std::lower_bound instead. template < class It , class T > It binary_find ( It first , It last , const T & value ) { typename std :: iterator_traits < It >:: difference_type count , step ; It it ; count = std :: distance ( first , last ); while ( count > 0 ) { it = first ; step = count / 2 ; std :: advance ( it , step ); if ( * it < value ) { first = ++ it ; count -= step + 1 ; } else { count = step ; } } return first ; } Binary search (vector + the textbook convention) 1 2 3 4 5 size_t pos2 = binary_find ( v , 6 ); if ( pos2 != v . size ()) { std :: cout << \"value: \" << v [ pos2 ] << '\\n' ; } std :: cout << \"position: \" << pos2 << '\\n' ; Binary search (iterators + the C++ convention) 1 2 3 4 5 auto it2 = binary_find ( v . begin (), v . end (), 6 ); if ( it2 != v . end ()) { std :: cout << \"*it2: \" << * it2 << '\\n' ; } std :: cout << \"position: \" << it2 - v . begin () << '\\n' ; Share Snippets","title":"Searching"},{"location":"algorithms-data-structures/algorithm/sorting/","text":"Sorting Hint The standard algorithms for sorting containers are std::sort and std::stable_sort . These snippets include extra functions describing how these tasks can be implemented with many other classic sorting algorithms. They are mostly relevant for people studying sorting algorithms for the first time. Create vector for sorting 1 std :: vector < int > v = { 5 , 4 , 9 , 8 , 6 , 3 }; Sorting 1 2 3 4 5 // - std::sort is what you would use daily // - don't implement your own version unless you're studying the algorithms std :: sort ( v . begin (), v . end ()); std :: copy ( v . begin (), v . end (), std :: ostream_iterator < int > { std :: cout , \" \" }); std :: cout << '\\n' ; Stable sorting 1 2 3 4 // Elements that compare equal don't change their relative positions std :: stable_sort ( v . begin (), v . end ()); copy ( v . begin (), v . end (), std :: ostream_iterator < int > { std :: cout , \" \" }); std :: cout << '\\n' ; Stable sorting 1 2 3 4 // Elements that compare equal don't change their relative positions std :: stable_sort ( v . begin (), v . end ()); copy ( v . begin (), v . end (), std :: ostream_iterator < int > { std :: cout , \" \" }); std :: cout << '\\n' ; Selection sort: O(n^2) 1 2 3 4 5 6 7 8 9 10 11 12 template < class It , class C > void selection_sort ( It first , It last , C comp ) { // For each position for ( auto it = first ; it != std :: prev ( last ); ++ it ) { // Swap the current with the min_element std :: iter_swap ( it , std :: min_element ( it , last , comp )); } } template < class It > void selection_sort ( It first , It last ) { // If no comparison function is provided, use `std::less` selection_sort ( first , last , std :: less < std :: decay_t < decltype ( * first ) >> ()); } Insertion sort: O(n^2) 1 2 3 4 5 6 7 8 9 10 11 12 template < class It , class C > void insertion_sort ( It first , It last , C comp ) { // For each position for ( auto i = std :: next ( first ); i != last ; ++ i ) { // Push the element to the sorted subarray to the left rotate ( upper_bound ( first , i , * i , comp ), i , i + 1 ); } } template < class It > void insertion_sort ( It first , It last ) { // If no comparison function is provided, use `std::less` insertion_sort ( first , last , std :: less < std :: decay_t < decltype ( * first ) >> ()); } Mergesort: O(n log n) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template < class It , class C > void merge_sort ( It first , It last , C comp ) { // While more than 1 element if ( last - first > 1 ) { It middle = first + ( last - first ) / 2 ; // Sort left-hand side merge_sort ( first , middle , comp ); // Sort right-hand side merge_sort ( middle , last , comp ); // Merge left and right-hand sides inplace_merge ( first , middle , last , comp ); } } template < class It > void merge_sort ( It first , It last ) { // If no comparison function is provided, use `std::less` merge_sort ( first , last , std :: less < std :: decay_t < decltype ( * first ) >> ()); } Helper function for median of three values 1 2 3 4 5 6 7 8 9 template < typename T , class C > constexpr T median ( T t1 , T t2 , T t3 , C comp ) { return ( comp ( t1 , t2 )) ? (( comp ( t2 , t3 )) ? t2 : (( comp ( t1 , t3 )) ? t3 : t1 )) : (( comp ( t1 , t3 )) ? t1 : (( comp ( t2 , t3 )) ? t3 : t2 )); } template < class It > void median ( It first , It last ) { // If no comparison function is provided, use `std::less` median ( first , last , std :: less < std :: decay_t < decltype ( * first ) >> ()); } Quicksort: O(n log n) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 template < class It , class C > void quick_sort ( It first , It last , C comp ) { // If there is more than 1 element to sort if ( first != last && std :: next ( first ) != last ) { It middle = first + ( last - first ) / 2 ; // Choose a pivot based on the median element auto pivot = median ( * first , * middle , * std :: prev ( last ), comp ); // Partition the vector based on the pivot It split1 = partition ( first , last , [ & ]( auto x ) { return comp ( x , pivot ); }); It split2 = partition ( split1 , last , [ & ]( auto x ) { return ! comp ( pivot , x ); }); // Sort left-hand side quick_sort ( first , split1 , comp ); // Sort right-hand side quick_sort ( split2 , last , comp ); } } template < class It > void quick_sort ( It first , It last ) { // If no comparison function is provided, use `std::less` quick_sort ( first , last , std :: less < std :: decay_t < decltype ( * first ) >> ()); } Call selection sort 1 2 3 selection_sort ( v . begin (), v . end ()); copy ( v . begin (), v . end (), std :: ostream_iterator < int > { std :: cout , \" \" }); std :: cout << '\\n' ; Call insertion sort 1 2 3 insertion_sort ( v . begin (), v . end ()); copy ( v . begin (), v . end (), std :: ostream_iterator < int > { std :: cout , \" \" }); std :: cout << '\\n' ; Call mergesort 1 2 3 merge_sort ( v . begin (), v . end ()); copy ( v . begin (), v . end (), std :: ostream_iterator < int > { std :: cout , \" \" }); std :: cout << '\\n' ; Call quicksort 1 2 3 quick_sort ( v . begin (), v . end ()); copy ( v . begin (), v . end (), std :: ostream_iterator < int > { std :: cout , \" \" }); std :: cout << '\\n' ; Share Snippets","title":"Sorting"},{"location":"algorithms-data-structures/algorithm/sorting/#sorting","text":"Hint The standard algorithms for sorting containers are std::sort and std::stable_sort . These snippets include extra functions describing how these tasks can be implemented with many other classic sorting algorithms. They are mostly relevant for people studying sorting algorithms for the first time. Create vector for sorting 1 std :: vector < int > v = { 5 , 4 , 9 , 8 , 6 , 3 }; Sorting 1 2 3 4 5 // - std::sort is what you would use daily // - don't implement your own version unless you're studying the algorithms std :: sort ( v . begin (), v . end ()); std :: copy ( v . begin (), v . end (), std :: ostream_iterator < int > { std :: cout , \" \" }); std :: cout << '\\n' ; Stable sorting 1 2 3 4 // Elements that compare equal don't change their relative positions std :: stable_sort ( v . begin (), v . end ()); copy ( v . begin (), v . end (), std :: ostream_iterator < int > { std :: cout , \" \" }); std :: cout << '\\n' ; Stable sorting 1 2 3 4 // Elements that compare equal don't change their relative positions std :: stable_sort ( v . begin (), v . end ()); copy ( v . begin (), v . end (), std :: ostream_iterator < int > { std :: cout , \" \" }); std :: cout << '\\n' ; Selection sort: O(n^2) 1 2 3 4 5 6 7 8 9 10 11 12 template < class It , class C > void selection_sort ( It first , It last , C comp ) { // For each position for ( auto it = first ; it != std :: prev ( last ); ++ it ) { // Swap the current with the min_element std :: iter_swap ( it , std :: min_element ( it , last , comp )); } } template < class It > void selection_sort ( It first , It last ) { // If no comparison function is provided, use `std::less` selection_sort ( first , last , std :: less < std :: decay_t < decltype ( * first ) >> ()); } Insertion sort: O(n^2) 1 2 3 4 5 6 7 8 9 10 11 12 template < class It , class C > void insertion_sort ( It first , It last , C comp ) { // For each position for ( auto i = std :: next ( first ); i != last ; ++ i ) { // Push the element to the sorted subarray to the left rotate ( upper_bound ( first , i , * i , comp ), i , i + 1 ); } } template < class It > void insertion_sort ( It first , It last ) { // If no comparison function is provided, use `std::less` insertion_sort ( first , last , std :: less < std :: decay_t < decltype ( * first ) >> ()); } Mergesort: O(n log n) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template < class It , class C > void merge_sort ( It first , It last , C comp ) { // While more than 1 element if ( last - first > 1 ) { It middle = first + ( last - first ) / 2 ; // Sort left-hand side merge_sort ( first , middle , comp ); // Sort right-hand side merge_sort ( middle , last , comp ); // Merge left and right-hand sides inplace_merge ( first , middle , last , comp ); } } template < class It > void merge_sort ( It first , It last ) { // If no comparison function is provided, use `std::less` merge_sort ( first , last , std :: less < std :: decay_t < decltype ( * first ) >> ()); } Helper function for median of three values 1 2 3 4 5 6 7 8 9 template < typename T , class C > constexpr T median ( T t1 , T t2 , T t3 , C comp ) { return ( comp ( t1 , t2 )) ? (( comp ( t2 , t3 )) ? t2 : (( comp ( t1 , t3 )) ? t3 : t1 )) : (( comp ( t1 , t3 )) ? t1 : (( comp ( t2 , t3 )) ? t3 : t2 )); } template < class It > void median ( It first , It last ) { // If no comparison function is provided, use `std::less` median ( first , last , std :: less < std :: decay_t < decltype ( * first ) >> ()); } Quicksort: O(n log n) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 template < class It , class C > void quick_sort ( It first , It last , C comp ) { // If there is more than 1 element to sort if ( first != last && std :: next ( first ) != last ) { It middle = first + ( last - first ) / 2 ; // Choose a pivot based on the median element auto pivot = median ( * first , * middle , * std :: prev ( last ), comp ); // Partition the vector based on the pivot It split1 = partition ( first , last , [ & ]( auto x ) { return comp ( x , pivot ); }); It split2 = partition ( split1 , last , [ & ]( auto x ) { return ! comp ( pivot , x ); }); // Sort left-hand side quick_sort ( first , split1 , comp ); // Sort right-hand side quick_sort ( split2 , last , comp ); } } template < class It > void quick_sort ( It first , It last ) { // If no comparison function is provided, use `std::less` quick_sort ( first , last , std :: less < std :: decay_t < decltype ( * first ) >> ()); } Call selection sort 1 2 3 selection_sort ( v . begin (), v . end ()); copy ( v . begin (), v . end (), std :: ostream_iterator < int > { std :: cout , \" \" }); std :: cout << '\\n' ; Call insertion sort 1 2 3 insertion_sort ( v . begin (), v . end ()); copy ( v . begin (), v . end (), std :: ostream_iterator < int > { std :: cout , \" \" }); std :: cout << '\\n' ; Call mergesort 1 2 3 merge_sort ( v . begin (), v . end ()); copy ( v . begin (), v . end (), std :: ostream_iterator < int > { std :: cout , \" \" }); std :: cout << '\\n' ; Call quicksort 1 2 3 quick_sort ( v . begin (), v . end ()); copy ( v . begin (), v . end (), std :: ostream_iterator < int > { std :: cout , \" \" }); std :: cout << '\\n' ; Share Snippets","title":"Sorting"},{"location":"algorithms-data-structures/data-structures/associative-containers/","text":"Associative Containers Associative Containers Associative containers implement sorted data structures that can be quickly searched (O(log n) complexity. They are usually implemented as binary trees. set: collection of unique keys, sorted by keys map: collection of key-value pairs, sorted by keys, keys are unique multiset: collection of keys, sorted by keys multimap: collection of key-value pairs, sorted by keys Unordered associative containers implement unsorted (hashed) data structures that can be quickly searched (O(1) amortized, O(n) worst-case complexity). They are usually implemented as hash tables. unordered_set (C++11): collection of unique keys, hashed by keys unordered_map (C++11): collection of key-value pairs, hashed by keys, keys are unique unordered_multiset (C++11): collection of keys, hashed by keys unordered_multimap (C++11): collection of key-value pairs, hashed by keys Headers 1 2 3 4 #include <map> #include <set> #include <unordered_map> #include <unordered_set> Construct associative containers 1 2 std :: set < int > a = { 2 , 3 , 1 , 5 , 4 }; std :: unordered_set < int > a2 = { 1 , 2 , 3 , 4 , 5 }; Subscript Operator (Ordered maps) 1 2 3 4 std :: map < std :: string , double > m ; m [ \"PI\" ] = 3.14 ; m [ \"ZERO\" ] = 0.0 ; m [ \"IRPF\" ] = 0.15 ; Subscript Operator (Ordered maps) 1 2 3 4 std :: map < std :: string , double > m ; m [ \"PI\" ] = 3.14 ; m [ \"ZERO\" ] = 0.0 ; m [ \"IRPF\" ] = 0.15 ; Container size 1 2 3 4 std :: cout << a . size () << '\\n' ; std :: cout << a2 . size () << '\\n' ; std :: cout << m . size () << '\\n' ; std :: cout << m2 . size () << '\\n' ; Insert values in sets 1 2 a . insert ( 8 ); a2 . insert ( 8 ); Insert values in maps with subscript operator 1 2 m [ \"hundred\" ] = 100.0 ; m2 [ \"hundred\" ] = 100.0 ; Insert values in maps with subscript operator 1 2 m [ \"hundred\" ] = 100.0 ; m2 [ \"hundred\" ] = 100.0 ; Erase elements 1 2 3 4 a . erase ( 2 ); a2 . erase ( 2 ); m . erase ( \"thousand\" ); m2 . erase ( \"thousand\" ); Share Snippets","title":"Associative Containers"},{"location":"algorithms-data-structures/data-structures/associative-containers/#associative-containers","text":"Associative Containers Associative containers implement sorted data structures that can be quickly searched (O(log n) complexity. They are usually implemented as binary trees. set: collection of unique keys, sorted by keys map: collection of key-value pairs, sorted by keys, keys are unique multiset: collection of keys, sorted by keys multimap: collection of key-value pairs, sorted by keys Unordered associative containers implement unsorted (hashed) data structures that can be quickly searched (O(1) amortized, O(n) worst-case complexity). They are usually implemented as hash tables. unordered_set (C++11): collection of unique keys, hashed by keys unordered_map (C++11): collection of key-value pairs, hashed by keys, keys are unique unordered_multiset (C++11): collection of keys, hashed by keys unordered_multimap (C++11): collection of key-value pairs, hashed by keys Headers 1 2 3 4 #include <map> #include <set> #include <unordered_map> #include <unordered_set> Construct associative containers 1 2 std :: set < int > a = { 2 , 3 , 1 , 5 , 4 }; std :: unordered_set < int > a2 = { 1 , 2 , 3 , 4 , 5 }; Subscript Operator (Ordered maps) 1 2 3 4 std :: map < std :: string , double > m ; m [ \"PI\" ] = 3.14 ; m [ \"ZERO\" ] = 0.0 ; m [ \"IRPF\" ] = 0.15 ; Subscript Operator (Ordered maps) 1 2 3 4 std :: map < std :: string , double > m ; m [ \"PI\" ] = 3.14 ; m [ \"ZERO\" ] = 0.0 ; m [ \"IRPF\" ] = 0.15 ; Container size 1 2 3 4 std :: cout << a . size () << '\\n' ; std :: cout << a2 . size () << '\\n' ; std :: cout << m . size () << '\\n' ; std :: cout << m2 . size () << '\\n' ; Insert values in sets 1 2 a . insert ( 8 ); a2 . insert ( 8 ); Insert values in maps with subscript operator 1 2 m [ \"hundred\" ] = 100.0 ; m2 [ \"hundred\" ] = 100.0 ; Insert values in maps with subscript operator 1 2 m [ \"hundred\" ] = 100.0 ; m2 [ \"hundred\" ] = 100.0 ; Erase elements 1 2 3 4 a . erase ( 2 ); a2 . erase ( 2 ); m . erase ( \"thousand\" ); m2 . erase ( \"thousand\" ); Share Snippets","title":"Associative Containers"},{"location":"algorithms-data-structures/data-structures/bitset/","text":"Bitset Bitset The class template bitset represents a fixed-size sequence of N bits. Bitsets can be manipulated by standard logic operators and converted to and from strings and integers. CMakeLists.txt 1 add_executable ( bitset bitset.cpp ) Headers 1 #include <bitset> Get type size 1 2 3 4 5 6 7 8 std :: cout << \"sizeof(char) = \" << sizeof ( char ) << \" bytes\" << '\\n' ; std :: cout << \"sizeof(unsigned char) = \" << sizeof ( unsigned char ) << \" bytes\" << '\\n' ; std :: cout << \"sizeof(short) = \" << sizeof ( short ) << \" bytes\" << '\\n' ; std :: cout << \"sizeof(int) = \" << sizeof ( int ) << \" bytes\" << '\\n' ; std :: cout << \"sizeof(long) = \" << sizeof ( long ) << \" bytes\" << '\\n' ; std :: cout << \"sizeof(size_t) = \" << sizeof ( size_t ) << \" bytes\" << '\\n' ; std :: cout << \"sizeof(double) = \" << sizeof ( double ) << \" bytes\" << '\\n' << '\\n' ; Binary literals 1 2 uint32_t r = 0b111111110100010001100110 ; std :: cout << r << '\\n' ; Bitsets 1 std :: cout << \"r = \" << std :: bitset < 32 > ( r ) << '\\n' << '\\n' ; Operators 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 const uint32_t unit = 0x01 ; std :: cout << \"unit << 0 = \" << std :: bitset < 32 > ( unit << 0 ) << '\\n' ; std :: cout << \"~(unit << 0) = \" << std :: bitset < 32 > ( ~ ( unit << 0 )) << '\\n' ; std :: cout << \"r & (~(unit << 0)) = \" << std :: bitset < 32 > ( r & ( ~ ( unit << 0 ))) << '\\n' << '\\n' ; std :: cout << \"unit << 1 = \" << std :: bitset < 32 > ( unit << 1 ) << '\\n' ; std :: cout << \"~(unit << 1) = \" << std :: bitset < 32 > ( ~ ( unit << 1 )) << '\\n' ; std :: cout << \"r & (~(unit << 1)) = \" << std :: bitset < 32 > ( r & ( ~ ( unit << 1 ))) << '\\n' << '\\n' ; std :: cout << \"unit << 2 = \" << std :: bitset < 32 > ( unit << 2 ) << '\\n' ; std :: cout << \"~(unit << 2) = \" << std :: bitset < 32 > ( ~ ( unit << 2 )) << '\\n' ; std :: cout << \"r & (~(unit << 2)) = \" << std :: bitset < 32 > ( r & ( ~ ( unit << 2 ))) << '\\n' << '\\n' ; std :: cout << \"unit << 3 = \" << std :: bitset < 32 > ( unit << 3 ) << '\\n' ; std :: cout << \"~(unit << 3) = \" << std :: bitset < 32 > ( ~ ( unit << 3 )) << '\\n' ; std :: cout << \"r & (~(unit << 3)) = \" << std :: bitset < 32 > ( r & ( ~ ( unit << 3 ))) << '\\n' << '\\n' ; std :: cout << \"unit << 4 = \" << std :: bitset < 32 > ( unit << 4 ) << '\\n' ; std :: cout << \"~(unit << 4) = \" << std :: bitset < 32 > ( ~ ( unit << 4 )) << '\\n' ; std :: cout << \"r & (~(unit << 4)) = \" << std :: bitset < 32 > ( r & ( ~ ( unit << 4 ))) << '\\n' << '\\n' ; std :: cout << \"unit << 5 = \" << std :: bitset < 32 > ( unit << 5 ) << '\\n' ; std :: cout << \"~(unit << 5) = \" << std :: bitset < 32 > ( ~ ( unit << 5 )) << '\\n' ; std :: cout << \"r & (~(unit << 5)) = \" << std :: bitset < 32 > ( r & ( ~ ( unit << 5 ))) << '\\n' << '\\n' ; std :: cout << \"unit << 6 = \" << std :: bitset < 32 > ( unit << 6 ) << '\\n' ; std :: cout << \"~(unit << 6) = \" << std :: bitset < 32 > ( ~ ( unit << 6 )) << '\\n' ; std :: cout << \"r & (~(unit << 6)) = \" << std :: bitset < 32 > ( r & ( ~ ( unit << 6 ))) << '\\n' << '\\n' ; std :: cout << \"unit << 7 = \" << std :: bitset < 32 > ( unit << 7 ) << '\\n' ; std :: cout << \"~(unit << 7) = \" << std :: bitset < 32 > ( ~ ( unit << 7 )) << '\\n' ; std :: cout << \"r & (~(unit << 7)) = \" << std :: bitset < 32 > ( r & ( ~ ( unit << 7 ))) << '\\n' << '\\n' ; std :: cout << \"unit << 8 = \" << std :: bitset < 32 > ( unit << 8 ) << '\\n' ; std :: cout << \"~(unit << 8) = \" << std :: bitset < 32 > ( ~ ( unit << 8 )) << '\\n' ; std :: cout << \"r & (~(unit << 8)) = \" << std :: bitset < 32 > ( r & ( ~ ( unit << 8 ))) << '\\n' << '\\n' ; Create bitset with 8 bits 1 std :: bitset < 8 > b ( 20 ); Convert bitset 1 2 3 4 5 6 std :: cout << \"b: \" << b << '\\n' ; std :: cout << \"b: \" << b . to_ulong () << '\\n' ; std :: cout << \"b: \" << b . to_string () << '\\n' ; for ( size_t i = 0 ; i < b . size (); ++ i ) { std :: cout << \"b[i] : \" << b [ i ] << '\\n' ; } Create byte 1 2 std :: byte a { 20 }; std :: cout << \"a: \" << std :: to_integer < int > ( a ) << '\\n' ; Share Snippets","title":"Bitset"},{"location":"algorithms-data-structures/data-structures/bitset/#bitset","text":"Bitset The class template bitset represents a fixed-size sequence of N bits. Bitsets can be manipulated by standard logic operators and converted to and from strings and integers. CMakeLists.txt 1 add_executable ( bitset bitset.cpp ) Headers 1 #include <bitset> Get type size 1 2 3 4 5 6 7 8 std :: cout << \"sizeof(char) = \" << sizeof ( char ) << \" bytes\" << '\\n' ; std :: cout << \"sizeof(unsigned char) = \" << sizeof ( unsigned char ) << \" bytes\" << '\\n' ; std :: cout << \"sizeof(short) = \" << sizeof ( short ) << \" bytes\" << '\\n' ; std :: cout << \"sizeof(int) = \" << sizeof ( int ) << \" bytes\" << '\\n' ; std :: cout << \"sizeof(long) = \" << sizeof ( long ) << \" bytes\" << '\\n' ; std :: cout << \"sizeof(size_t) = \" << sizeof ( size_t ) << \" bytes\" << '\\n' ; std :: cout << \"sizeof(double) = \" << sizeof ( double ) << \" bytes\" << '\\n' << '\\n' ; Binary literals 1 2 uint32_t r = 0b111111110100010001100110 ; std :: cout << r << '\\n' ; Bitsets 1 std :: cout << \"r = \" << std :: bitset < 32 > ( r ) << '\\n' << '\\n' ; Operators 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 const uint32_t unit = 0x01 ; std :: cout << \"unit << 0 = \" << std :: bitset < 32 > ( unit << 0 ) << '\\n' ; std :: cout << \"~(unit << 0) = \" << std :: bitset < 32 > ( ~ ( unit << 0 )) << '\\n' ; std :: cout << \"r & (~(unit << 0)) = \" << std :: bitset < 32 > ( r & ( ~ ( unit << 0 ))) << '\\n' << '\\n' ; std :: cout << \"unit << 1 = \" << std :: bitset < 32 > ( unit << 1 ) << '\\n' ; std :: cout << \"~(unit << 1) = \" << std :: bitset < 32 > ( ~ ( unit << 1 )) << '\\n' ; std :: cout << \"r & (~(unit << 1)) = \" << std :: bitset < 32 > ( r & ( ~ ( unit << 1 ))) << '\\n' << '\\n' ; std :: cout << \"unit << 2 = \" << std :: bitset < 32 > ( unit << 2 ) << '\\n' ; std :: cout << \"~(unit << 2) = \" << std :: bitset < 32 > ( ~ ( unit << 2 )) << '\\n' ; std :: cout << \"r & (~(unit << 2)) = \" << std :: bitset < 32 > ( r & ( ~ ( unit << 2 ))) << '\\n' << '\\n' ; std :: cout << \"unit << 3 = \" << std :: bitset < 32 > ( unit << 3 ) << '\\n' ; std :: cout << \"~(unit << 3) = \" << std :: bitset < 32 > ( ~ ( unit << 3 )) << '\\n' ; std :: cout << \"r & (~(unit << 3)) = \" << std :: bitset < 32 > ( r & ( ~ ( unit << 3 ))) << '\\n' << '\\n' ; std :: cout << \"unit << 4 = \" << std :: bitset < 32 > ( unit << 4 ) << '\\n' ; std :: cout << \"~(unit << 4) = \" << std :: bitset < 32 > ( ~ ( unit << 4 )) << '\\n' ; std :: cout << \"r & (~(unit << 4)) = \" << std :: bitset < 32 > ( r & ( ~ ( unit << 4 ))) << '\\n' << '\\n' ; std :: cout << \"unit << 5 = \" << std :: bitset < 32 > ( unit << 5 ) << '\\n' ; std :: cout << \"~(unit << 5) = \" << std :: bitset < 32 > ( ~ ( unit << 5 )) << '\\n' ; std :: cout << \"r & (~(unit << 5)) = \" << std :: bitset < 32 > ( r & ( ~ ( unit << 5 ))) << '\\n' << '\\n' ; std :: cout << \"unit << 6 = \" << std :: bitset < 32 > ( unit << 6 ) << '\\n' ; std :: cout << \"~(unit << 6) = \" << std :: bitset < 32 > ( ~ ( unit << 6 )) << '\\n' ; std :: cout << \"r & (~(unit << 6)) = \" << std :: bitset < 32 > ( r & ( ~ ( unit << 6 ))) << '\\n' << '\\n' ; std :: cout << \"unit << 7 = \" << std :: bitset < 32 > ( unit << 7 ) << '\\n' ; std :: cout << \"~(unit << 7) = \" << std :: bitset < 32 > ( ~ ( unit << 7 )) << '\\n' ; std :: cout << \"r & (~(unit << 7)) = \" << std :: bitset < 32 > ( r & ( ~ ( unit << 7 ))) << '\\n' << '\\n' ; std :: cout << \"unit << 8 = \" << std :: bitset < 32 > ( unit << 8 ) << '\\n' ; std :: cout << \"~(unit << 8) = \" << std :: bitset < 32 > ( ~ ( unit << 8 )) << '\\n' ; std :: cout << \"r & (~(unit << 8)) = \" << std :: bitset < 32 > ( r & ( ~ ( unit << 8 ))) << '\\n' << '\\n' ; Create bitset with 8 bits 1 std :: bitset < 8 > b ( 20 ); Convert bitset 1 2 3 4 5 6 std :: cout << \"b: \" << b << '\\n' ; std :: cout << \"b: \" << b . to_ulong () << '\\n' ; std :: cout << \"b: \" << b . to_string () << '\\n' ; for ( size_t i = 0 ; i < b . size (); ++ i ) { std :: cout << \"b[i] : \" << b [ i ] << '\\n' ; } Create byte 1 2 std :: byte a { 20 }; std :: cout << \"a: \" << std :: to_integer < int > ( a ) << '\\n' ; Share Snippets","title":"Bitset"},{"location":"algorithms-data-structures/data-structures/build-script/","text":"Build script 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 # Data structures add_executable ( sequence_containers sequence_containers.cpp ) add_executable ( associative_containers associative_containers.cpp ) add_executable ( container_adapters container_adapters.cpp ) #[pmr CMakeLists.txt find_package ( PMR ) if ( PMR_FOUND ) add_executable ( memory_resource memory_resources.cpp ) else () message ( \"Your compiler does not support *PMR* yet\" ) endif () #] #[span CMakeLists.txt add_executable ( span span.cpp ) target_compile_features ( span PRIVATE cxx_std_20 ) #] #[bitset CMakeLists.txt add_executable ( bitset bitset.cpp ) #] #[pareto CMakeLists.txt # Set options to not build pareto examples # - Cache our own BUILD_EXAMPLES var so that pareto # doesn't mess with it set ( BUILD_MATPLOT_TARGETS OFF CACHE BOOL \"\" FORCE ) set ( BUILD_EXAMPLES_PREV ${ BUILD_EXAMPLES } ) set ( BUILD_EXAMPLES OFF CACHE BOOL \"\" FORCE ) FetchContent_Declare ( pareto GIT_REPOSITORY https://github.com/alandefreitas/pareto.git GIT_TAG v1.2.0 ) FetchContent_MakeAvailable ( pareto ) set ( BUILD_EXAMPLES ${ BUILD_EXAMPLES_PREV } CACHE BOOL \"\" FORCE ) add_executable ( spatial_containers spatial_containers.cpp ) target_link_libraries ( spatial_containers PUBLIC pareto ) #]","title":"Build script"},{"location":"algorithms-data-structures/data-structures/build-script/#build-script","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 # Data structures add_executable ( sequence_containers sequence_containers.cpp ) add_executable ( associative_containers associative_containers.cpp ) add_executable ( container_adapters container_adapters.cpp ) #[pmr CMakeLists.txt find_package ( PMR ) if ( PMR_FOUND ) add_executable ( memory_resource memory_resources.cpp ) else () message ( \"Your compiler does not support *PMR* yet\" ) endif () #] #[span CMakeLists.txt add_executable ( span span.cpp ) target_compile_features ( span PRIVATE cxx_std_20 ) #] #[bitset CMakeLists.txt add_executable ( bitset bitset.cpp ) #] #[pareto CMakeLists.txt # Set options to not build pareto examples # - Cache our own BUILD_EXAMPLES var so that pareto # doesn't mess with it set ( BUILD_MATPLOT_TARGETS OFF CACHE BOOL \"\" FORCE ) set ( BUILD_EXAMPLES_PREV ${ BUILD_EXAMPLES } ) set ( BUILD_EXAMPLES OFF CACHE BOOL \"\" FORCE ) FetchContent_Declare ( pareto GIT_REPOSITORY https://github.com/alandefreitas/pareto.git GIT_TAG v1.2.0 ) FetchContent_MakeAvailable ( pareto ) set ( BUILD_EXAMPLES ${ BUILD_EXAMPLES_PREV } CACHE BOOL \"\" FORCE ) add_executable ( spatial_containers spatial_containers.cpp ) target_link_libraries ( spatial_containers PUBLIC pareto ) #]","title":"Build script"},{"location":"algorithms-data-structures/data-structures/memory-resources/","text":"Memory resources Memory resources The class std::pmr::memory_resource is an abstract interface to an unbounded set of classes encapsulating memory resources. The class template std::pmr::polymorphic_allocator is an Allocator which exhibits different allocation behavior depending upon the std::pmr::memory_resource from which it is constructed. This allows us to control how a given container allocates memory. Since memory_resource uses runtime polymorphism to manage allocations, different container instances with polymorphic_allocator as their static allocator type are interoperable, but can behave as if they had different allocator types. Not all compilers implement PMR yet, even though it's a C++17 feature. We need a CMake script such as FindPMR.cmake to identify if your compiler implements it. Another option is using __has_include to identify if the appropriate headers are available. CMakeLists.txt 1 2 3 4 5 6 find_package ( PMR ) if ( PMR_FOUND ) add_executable ( memory_resource memory_resources.cpp ) else () message ( \"Your compiler does not support *PMR* yet\" ) endif () Headers 1 #include <memory_resource> Construct a buffer where to allocate memory 1 2 3 char buffer [ 64 ] = {}; // a small buffer on the stack std :: fill_n ( std :: begin ( buffer ), std :: size ( buffer ) - 1 , '_' ); std :: cout << buffer << '\\n' ; Create a memory resource with the buffer 1 2 std :: pmr :: monotonic_buffer_resource pool { std :: data ( buffer ), std :: size ( buffer )}; Create a vector that allocates memory from the pool 1 2 3 4 5 std :: pmr :: vector < char > vec { & pool }; for ( char ch = 'a' ; ch <= 'z' ; ++ ch ) { vec . push_back ( ch ); } std :: cout << buffer << '\\n' ; Create a pool for memory allocations and a vector using the pool 1 2 3 4 5 std :: pmr :: unsynchronized_pool_resource pool2 ; std :: pmr :: vector < char > vec2 { & pool2 }; for ( char ch = 'a' ; ch <= 'z' ; ++ ch ) { vec2 . push_back ( ch ); } Share Snippets","title":"Memory resources"},{"location":"algorithms-data-structures/data-structures/memory-resources/#memory-resources","text":"Memory resources The class std::pmr::memory_resource is an abstract interface to an unbounded set of classes encapsulating memory resources. The class template std::pmr::polymorphic_allocator is an Allocator which exhibits different allocation behavior depending upon the std::pmr::memory_resource from which it is constructed. This allows us to control how a given container allocates memory. Since memory_resource uses runtime polymorphism to manage allocations, different container instances with polymorphic_allocator as their static allocator type are interoperable, but can behave as if they had different allocator types. Not all compilers implement PMR yet, even though it's a C++17 feature. We need a CMake script such as FindPMR.cmake to identify if your compiler implements it. Another option is using __has_include to identify if the appropriate headers are available. CMakeLists.txt 1 2 3 4 5 6 find_package ( PMR ) if ( PMR_FOUND ) add_executable ( memory_resource memory_resources.cpp ) else () message ( \"Your compiler does not support *PMR* yet\" ) endif () Headers 1 #include <memory_resource> Construct a buffer where to allocate memory 1 2 3 char buffer [ 64 ] = {}; // a small buffer on the stack std :: fill_n ( std :: begin ( buffer ), std :: size ( buffer ) - 1 , '_' ); std :: cout << buffer << '\\n' ; Create a memory resource with the buffer 1 2 std :: pmr :: monotonic_buffer_resource pool { std :: data ( buffer ), std :: size ( buffer )}; Create a vector that allocates memory from the pool 1 2 3 4 5 std :: pmr :: vector < char > vec { & pool }; for ( char ch = 'a' ; ch <= 'z' ; ++ ch ) { vec . push_back ( ch ); } std :: cout << buffer << '\\n' ; Create a pool for memory allocations and a vector using the pool 1 2 3 4 5 std :: pmr :: unsynchronized_pool_resource pool2 ; std :: pmr :: vector < char > vec2 { & pool2 }; for ( char ch = 'a' ; ch <= 'z' ; ++ ch ) { vec2 . push_back ( ch ); } Share Snippets","title":"Memory resources"},{"location":"algorithms-data-structures/data-structures/sequence-containers/","text":"Sequence Containers Sequence Containers Sequence containers implement data structures which can be accessed sequentially. array (C++11): static contiguous array vector: dynamic contiguous array deque: double-ended queue forward_list (C++11): singly-linked list list: doubly-linked list Headers 1 2 3 4 #include <array> #include <deque> #include <list> #include <vector> Construct sequence containers 1 2 3 4 std :: array < int , 5 > a = { 1 , 2 , 3 , 4 , 5 }; // from values std :: vector < int > v ( 8 , 9 ); // from size and value std :: deque < int > d ( a . begin (), a . end ()); // from iterators std :: list < int > l ; // empty Container size 1 2 3 4 std :: cout << \"a.size(): \" << a . size () << '\\n' ; std :: cout << \"v.size(): \" << v . size () << '\\n' ; std :: cout << \"d.size(): \" << d . size () << '\\n' ; std :: cout << \"l.size(): \" << l . size () << '\\n' ; Push back / Append 1 2 3 4 // a.push_back(6); <- not possible - array is fixed size v . push_back ( 6 ); d . push_back ( 6 ); l . push_back ( 6 ); Push front 1 2 3 4 // a.push_front(6); <- not possible - array is fixed size v . insert ( v . begin (), 6 ); // <- not possible in constant time d . push_front ( 6 ); l . push_front ( 6 ); Subscripts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 for ( size_t i = 0 ; i < a . size (); ++ i ) { std :: cout << a [ i ] << \" \" ; } std :: cout << '\\n' ; for ( size_t i = 0 ; i < v . size (); ++ i ) { std :: cout << v [ i ] << \" \" ; } std :: cout << '\\n' ; for ( size_t i = 0 ; i < d . size (); ++ i ) { std :: cout << d [ i ] << \" \" ; } std :: cout << '\\n' ; // Impossible: list is not random access // for (size_t i = 0; i < l.size(); ++i) { // std::cout << l[i] << \" \"; // } // std::cout << '\\n'; Iterators 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 for ( auto it = a . begin (); it != a . end (); ++ it ) { std :: cout << * it << \" \" ; } std :: cout << '\\n' ; for ( auto it = v . begin (); it != v . end (); ++ it ) { std :: cout << * it << \" \" ; } std :: cout << '\\n' ; for ( auto it = d . begin (); it != d . end (); ++ it ) { std :: cout << * it << \" \" ; } std :: cout << '\\n' ; for ( auto it = l . begin (); it != l . end (); ++ it ) { std :: cout << * it << \" \" ; } std :: cout << '\\n' ; Range-based for loop 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 for ( int x : a ) { std :: cout << x << \" \" ; } std :: cout << '\\n' ; for ( int x : v ) { std :: cout << x << \" \" ; } std :: cout << '\\n' ; for ( int x : d ) { std :: cout << x << \" \" ; } std :: cout << '\\n' ; for ( int x : l ) { std :: cout << x << \" \" ; } std :: cout << '\\n' ; Share Snippets","title":"Sequence Containers"},{"location":"algorithms-data-structures/data-structures/sequence-containers/#sequence-containers","text":"Sequence Containers Sequence containers implement data structures which can be accessed sequentially. array (C++11): static contiguous array vector: dynamic contiguous array deque: double-ended queue forward_list (C++11): singly-linked list list: doubly-linked list Headers 1 2 3 4 #include <array> #include <deque> #include <list> #include <vector> Construct sequence containers 1 2 3 4 std :: array < int , 5 > a = { 1 , 2 , 3 , 4 , 5 }; // from values std :: vector < int > v ( 8 , 9 ); // from size and value std :: deque < int > d ( a . begin (), a . end ()); // from iterators std :: list < int > l ; // empty Container size 1 2 3 4 std :: cout << \"a.size(): \" << a . size () << '\\n' ; std :: cout << \"v.size(): \" << v . size () << '\\n' ; std :: cout << \"d.size(): \" << d . size () << '\\n' ; std :: cout << \"l.size(): \" << l . size () << '\\n' ; Push back / Append 1 2 3 4 // a.push_back(6); <- not possible - array is fixed size v . push_back ( 6 ); d . push_back ( 6 ); l . push_back ( 6 ); Push front 1 2 3 4 // a.push_front(6); <- not possible - array is fixed size v . insert ( v . begin (), 6 ); // <- not possible in constant time d . push_front ( 6 ); l . push_front ( 6 ); Subscripts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 for ( size_t i = 0 ; i < a . size (); ++ i ) { std :: cout << a [ i ] << \" \" ; } std :: cout << '\\n' ; for ( size_t i = 0 ; i < v . size (); ++ i ) { std :: cout << v [ i ] << \" \" ; } std :: cout << '\\n' ; for ( size_t i = 0 ; i < d . size (); ++ i ) { std :: cout << d [ i ] << \" \" ; } std :: cout << '\\n' ; // Impossible: list is not random access // for (size_t i = 0; i < l.size(); ++i) { // std::cout << l[i] << \" \"; // } // std::cout << '\\n'; Iterators 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 for ( auto it = a . begin (); it != a . end (); ++ it ) { std :: cout << * it << \" \" ; } std :: cout << '\\n' ; for ( auto it = v . begin (); it != v . end (); ++ it ) { std :: cout << * it << \" \" ; } std :: cout << '\\n' ; for ( auto it = d . begin (); it != d . end (); ++ it ) { std :: cout << * it << \" \" ; } std :: cout << '\\n' ; for ( auto it = l . begin (); it != l . end (); ++ it ) { std :: cout << * it << \" \" ; } std :: cout << '\\n' ; Range-based for loop 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 for ( int x : a ) { std :: cout << x << \" \" ; } std :: cout << '\\n' ; for ( int x : v ) { std :: cout << x << \" \" ; } std :: cout << '\\n' ; for ( int x : d ) { std :: cout << x << \" \" ; } std :: cout << '\\n' ; for ( int x : l ) { std :: cout << x << \" \" ; } std :: cout << '\\n' ; Share Snippets","title":"Sequence Containers"},{"location":"algorithms-data-structures/data-structures/span/","text":"Span Span The class template span describes an object that can refer to a contiguous sequence of objects with the first element of the sequence at position zero. A span can either have a static extent, in which case the number of elements in the sequence is known at compile-time and encoded in the type, or a dynamic extent. CMakeLists.txt 1 2 add_executable ( span span.cpp ) target_compile_features ( span PRIVATE cxx_std_20 ) Headers 1 #include <span> Slide a span 1 2 3 4 5 template < class T , std :: size_t N > [[ nodiscard ]] constexpr auto slide ( std :: span < T , N > s , std :: size_t offset , std :: size_t width ) { return s . subspan ( offset , offset + width <= s . size () ? width : 0U ); } Check if span starts_with the specified prefix 1 2 3 4 5 6 template < class T , std :: size_t N , std :: size_t M > [[ nodiscard ]] constexpr bool starts_with ( std :: span < T , N > data , std :: span < T , M > prefix ) { return data . size () >= prefix . size () && std :: equal ( prefix . begin (), prefix . end (), data . begin ()); } Check if span ends_with the specified suffix 1 2 3 4 5 6 7 template < class T , std :: size_t N , std :: size_t M > [[ nodiscard ]] constexpr bool ends_with ( std :: span < T , N > data , std :: span < T , M > suffix ) { return data . size () >= suffix . size () && std :: equal ( data . end () - suffix . size (), data . end (), suffix . end () - suffix . size ()); } Check if span contains the specified element 1 2 3 4 5 6 template < class T , std :: size_t N , std :: size_t M > [[ nodiscard ]] constexpr bool contains ( std :: span < T , N > span , std :: span < T , M > sub ) { return std :: search ( span . begin (), span . end (), sub . begin (), sub . end ()) != span . end (); } Construct two arrays 1 2 constexpr int a []{ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 }; constexpr int b []{ 8 , 7 , 6 }; Slide spans 1 2 3 4 5 6 7 for ( std :: size_t offset {};; ++ offset ) { constexpr std :: size_t width { 6 }; auto s = slide ( std :: span { a }, offset , width ); if ( s . empty ()) break ; print ( s ); } Check span properties at compile time 1 2 3 4 5 6 7 8 static_assert ( starts_with ( std :: span { a }, std :: span { a , 4 }) && starts_with ( std :: span { a + 1 , 4 }, std :: span { a + 1 , 3 }) && ! starts_with ( std :: span { a }, std :: span { b }) && ! starts_with ( std :: span { a , 8 }, std :: span { a + 1 , 3 }) && ends_with ( std :: span { a }, std :: span { a + 6 , 3 }) && ! ends_with ( std :: span { a }, std :: span { a + 6 , 2 }) && contains ( std :: span { a }, std :: span { a + 1 , 4 }) && ! contains ( std :: span { a , 8 }, std :: span { a , 9 })); Share Snippets","title":"Span"},{"location":"algorithms-data-structures/data-structures/span/#span","text":"Span The class template span describes an object that can refer to a contiguous sequence of objects with the first element of the sequence at position zero. A span can either have a static extent, in which case the number of elements in the sequence is known at compile-time and encoded in the type, or a dynamic extent. CMakeLists.txt 1 2 add_executable ( span span.cpp ) target_compile_features ( span PRIVATE cxx_std_20 ) Headers 1 #include <span> Slide a span 1 2 3 4 5 template < class T , std :: size_t N > [[ nodiscard ]] constexpr auto slide ( std :: span < T , N > s , std :: size_t offset , std :: size_t width ) { return s . subspan ( offset , offset + width <= s . size () ? width : 0U ); } Check if span starts_with the specified prefix 1 2 3 4 5 6 template < class T , std :: size_t N , std :: size_t M > [[ nodiscard ]] constexpr bool starts_with ( std :: span < T , N > data , std :: span < T , M > prefix ) { return data . size () >= prefix . size () && std :: equal ( prefix . begin (), prefix . end (), data . begin ()); } Check if span ends_with the specified suffix 1 2 3 4 5 6 7 template < class T , std :: size_t N , std :: size_t M > [[ nodiscard ]] constexpr bool ends_with ( std :: span < T , N > data , std :: span < T , M > suffix ) { return data . size () >= suffix . size () && std :: equal ( data . end () - suffix . size (), data . end (), suffix . end () - suffix . size ()); } Check if span contains the specified element 1 2 3 4 5 6 template < class T , std :: size_t N , std :: size_t M > [[ nodiscard ]] constexpr bool contains ( std :: span < T , N > span , std :: span < T , M > sub ) { return std :: search ( span . begin (), span . end (), sub . begin (), sub . end ()) != span . end (); } Construct two arrays 1 2 constexpr int a []{ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 }; constexpr int b []{ 8 , 7 , 6 }; Slide spans 1 2 3 4 5 6 7 for ( std :: size_t offset {};; ++ offset ) { constexpr std :: size_t width { 6 }; auto s = slide ( std :: span { a }, offset , width ); if ( s . empty ()) break ; print ( s ); } Check span properties at compile time 1 2 3 4 5 6 7 8 static_assert ( starts_with ( std :: span { a }, std :: span { a , 4 }) && starts_with ( std :: span { a + 1 , 4 }, std :: span { a + 1 , 3 }) && ! starts_with ( std :: span { a }, std :: span { b }) && ! starts_with ( std :: span { a , 8 }, std :: span { a + 1 , 3 }) && ends_with ( std :: span { a }, std :: span { a + 6 , 3 }) && ! ends_with ( std :: span { a }, std :: span { a + 6 , 2 }) && contains ( std :: span { a }, std :: span { a + 1 , 4 }) && ! contains ( std :: span { a , 8 }, std :: span { a , 9 })); Share Snippets","title":"Span"},{"location":"algorithms-data-structures/data-structures/spatial-containers/","text":"Spatial Containers Spatial Containers Spatial container are an extension of sets and maps that allow us to order data according to multiple dimensions. This is particularly useful in games and graphical interfaces, where objects need to be mapped in space. The standard library does not include spatial containers so an external library needs to be used. CMakeLists.txt 1 2 3 4 5 6 7 8 9 10 11 # Set options to not build pareto examples # - Cache our own BUILD_EXAMPLES var so that pareto # doesn't mess with it set ( BUILD_MATPLOT_TARGETS OFF CACHE BOOL \"\" FORCE ) set ( BUILD_EXAMPLES_PREV ${ BUILD_EXAMPLES } ) set ( BUILD_EXAMPLES OFF CACHE BOOL \"\" FORCE ) FetchContent_Declare ( pareto GIT_REPOSITORY https://github.com/alandefreitas/pareto.git GIT_TAG v1.2.0 ) FetchContent_MakeAvailable ( pareto ) set ( BUILD_EXAMPLES ${ BUILD_EXAMPLES_PREV } CACHE BOOL \"\" FORCE ) add_executable ( spatial_containers spatial_containers.cpp ) target_link_libraries ( spatial_containers PUBLIC pareto ) Headers 1 #include <pareto/spatial_map.h> Construct map 1 2 3 // Unlike a map<map<...>>, which represents a disjunction of indexes, // a spatial map represents a conjunction of indexes. pareto :: spatial_map < double , 2 , unsigned > m ; Inserting 1 2 3 4 5 m ( -2.5 , -1.5 ) = 17 ; m ( -2.1 , -0.5 ) = 32 ; m ( -1.6 , 0.9 ) = 36 ; m ( -0.6 , 0.9 ) = 13 ; m ( -0.5 , 0.8 ) = 32 ; Querying nearest 1 2 3 4 std :: cout << \"Closest elements to [0, 0]:\" << std :: endl ; for ( auto it = m . find_nearest ({ 0. , 0. }, 2 ); it != m . end (); ++ it ) { std :: cout << it -> first << \": \" << it -> second << std :: endl ; } Querying intersection 1 2 3 4 std :: cout << \"Elements between [-1, -1] and [+1, +1]:\" << std :: endl ; for ( auto it = m . find_intersection ({ -1. , -1. }, { + 1 , + 1 }); it != m . end (); ++ it ) { std :: cout << it -> first << \": \" << it -> second << std :: endl ; } Share Snippets","title":"Spatial Containers"},{"location":"algorithms-data-structures/data-structures/spatial-containers/#spatial-containers","text":"Spatial Containers Spatial container are an extension of sets and maps that allow us to order data according to multiple dimensions. This is particularly useful in games and graphical interfaces, where objects need to be mapped in space. The standard library does not include spatial containers so an external library needs to be used. CMakeLists.txt 1 2 3 4 5 6 7 8 9 10 11 # Set options to not build pareto examples # - Cache our own BUILD_EXAMPLES var so that pareto # doesn't mess with it set ( BUILD_MATPLOT_TARGETS OFF CACHE BOOL \"\" FORCE ) set ( BUILD_EXAMPLES_PREV ${ BUILD_EXAMPLES } ) set ( BUILD_EXAMPLES OFF CACHE BOOL \"\" FORCE ) FetchContent_Declare ( pareto GIT_REPOSITORY https://github.com/alandefreitas/pareto.git GIT_TAG v1.2.0 ) FetchContent_MakeAvailable ( pareto ) set ( BUILD_EXAMPLES ${ BUILD_EXAMPLES_PREV } CACHE BOOL \"\" FORCE ) add_executable ( spatial_containers spatial_containers.cpp ) target_link_libraries ( spatial_containers PUBLIC pareto ) Headers 1 #include <pareto/spatial_map.h> Construct map 1 2 3 // Unlike a map<map<...>>, which represents a disjunction of indexes, // a spatial map represents a conjunction of indexes. pareto :: spatial_map < double , 2 , unsigned > m ; Inserting 1 2 3 4 5 m ( -2.5 , -1.5 ) = 17 ; m ( -2.1 , -0.5 ) = 32 ; m ( -1.6 , 0.9 ) = 36 ; m ( -0.6 , 0.9 ) = 13 ; m ( -0.5 , 0.8 ) = 32 ; Querying nearest 1 2 3 4 std :: cout << \"Closest elements to [0, 0]:\" << std :: endl ; for ( auto it = m . find_nearest ({ 0. , 0. }, 2 ); it != m . end (); ++ it ) { std :: cout << it -> first << \": \" << it -> second << std :: endl ; } Querying intersection 1 2 3 4 std :: cout << \"Elements between [-1, -1] and [+1, +1]:\" << std :: endl ; for ( auto it = m . find_intersection ({ -1. , -1. }, { + 1 , + 1 }); it != m . end (); ++ it ) { std :: cout << it -> first << \": \" << it -> second << std :: endl ; } Share Snippets","title":"Spatial Containers"},{"location":"algorithms-data-structures/date-and-time/clock/","text":"Clock Clock A clock consists of a starting point (or epoch) and a tick rate. For example, a clock may have an epoch of January 1, 1970 and tick every second. C++ defines several clock types: system_clock (C++11): wall clock time from the system-wide realtime clock steady_clock (C++11): monotonic clock that will never be adjusted high_resolution_clock (C++11): the clock with the shortest tick period available utc_clock (C++20): Clock for Coordinated Universal Time (UTC) tai_clock (C++20): Clock for International Atomic Time (TAI) gps_clock (C++20): Clock for GPS time file_clock (C++20): Clock used for file time local_t (C++20): pseudo-clock representing local time C++ also inherits the C clock function, which returns the approximate processor time used by the process since the beginning of an implementation-defined era related to the program's execution. To convert result value to seconds divide it by CLOCKS_PER_SEC. The clock function: The only method specified in the standard to measure CPU time It's up to the user to keep track of the duration unit It doesn't work well with threads Ignores the time spent on this_thread::sleep_for std::clock function 1 2 3 4 5 6 7 clock_t start , end ; double cpu_time_used ; start = clock (); very_expensive_function (); end = clock (); cpu_time_used = static_cast < float > ( end - start ) / CLOCKS_PER_SEC ; std :: cout << \"cpu_time_used: \" << cpu_time_used << \" seconds\" << '\\n' ; Modern C++ System Clock 1 2 3 auto start2 = std :: chrono :: system_clock :: now (); very_expensive_function (); auto end2 = std :: chrono :: system_clock :: now (); Duration represented with the default duration type 1 2 3 auto auto_duration = end2 - start2 ; std :: cout << \"auto_duration.count() : \" << auto_duration . count () << \" ticks\" << '\\n' ; // usually nanoseconds Duration represented with double, ratio in seconds 1 2 3 std :: chrono :: duration < double > seconds_as_double = end2 - start2 ; std :: cout << \"seconds_as_double.count() : \" << seconds_as_double . count () << \" seconds\" << '\\n' ; Duration represented with int, ratio in milliseconds 1 std :: chrono :: duration < int , std :: milli > milliseconds_as_int_ ; Cast duration (double, seconds) to duration (int, milliseconds) 1 2 3 4 5 milliseconds_as_int_ = std :: chrono :: duration_cast < std :: chrono :: duration < int , std :: milli >> ( seconds_as_double ); std :: cout << \"milliseconds_as_int_.count() : \" << milliseconds_as_int_ . count () << \" milliseconds\" << '\\n' ; Using ratio directly 1 2 3 4 5 6 7 8 // Same as using hours constexpr int seconds_per_hour = 60 * 60 ; std :: chrono :: duration < int , std :: ratio < seconds_per_hour >> hours_as_int ; hours_as_int = std :: chrono :: duration_cast < std :: chrono :: duration < int , std :: ratio < 60 * 60 >>> ( seconds_as_double ); std :: cout << \"hours_as_int.count() : \" << hours_as_int . count () << \" hours\" << '\\n' ; Modern C++ Steady Clock 1 2 3 auto start3 = std :: chrono :: steady_clock :: now (); very_expensive_function (); auto end3 = std :: chrono :: steady_clock :: now (); Duration represented with the default duration type 1 2 3 auto d3 = end2 - start2 ; std :: cout << \"auto_duration_3.count() : \" << d3 . count () << \" ticks\" << '\\n' ; // usually nanoseconds Time in seconds as double 1 2 3 std :: chrono :: duration < double > seconds_as_double_3 = end3 - start3 ; std :: cout << \"seconds_as_double_3.count() : \" << seconds_as_double_3 . count () << \" seconds\" << '\\n' ; Time in milliseconds as int 1 2 3 4 5 6 std :: chrono :: duration < int , std :: milli > milliseconds_as_int_3 ; milliseconds_as_int_3 = std :: chrono :: duration_cast < std :: chrono :: duration < int , std :: milli >> ( seconds_as_double_3 ); std :: cout << \"milliseconds_as_int_3.count() : \" << milliseconds_as_int_3 . count () << \" milliseconds\" << '\\n' ; Time in hours as int 1 2 3 4 5 6 7 std :: chrono :: duration < int , std :: ratio < seconds_per_hour >> hours_as_int3 ; // same as using std::hours hours_as_int3 = std :: chrono :: duration_cast < std :: chrono :: duration < int , std :: ratio < seconds_per_hour >>> ( seconds_as_double_3 ); std :: cout << \"hours_as_int3.count() : \" << hours_as_int3 . count () << \" hours\" << '\\n' ; \"Parsing\" time 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // While std::std::chrono::parse is not available in all main compilers auto hours = std :: chrono :: duration_cast < std :: chrono :: hours > ( d3 ); if ( hours . count () > 0 ) { std :: cout << hours . count () << \" hours\" ; } d3 -= hours ; auto seconds = std :: chrono :: duration_cast < std :: chrono :: seconds > ( d3 ); if ( seconds . count () > 0 ) { std :: cout << seconds . count () << \" seconds\" ; } d3 -= seconds ; auto milliseconds = std :: chrono :: duration_cast < std :: chrono :: milliseconds > ( d3 ); if ( milliseconds . count () > 0 ) { std :: cout << milliseconds . count () << \" milliseconds\" ; } d3 -= milliseconds ; auto nanoseconds = std :: chrono :: duration_cast < std :: chrono :: nanoseconds > ( d3 ); if ( nanoseconds . count () > 0 ) { std :: cout << nanoseconds . count () << \" nanoseconds\" ; } Share Snippets","title":"Clock"},{"location":"algorithms-data-structures/date-and-time/clock/#clock","text":"Clock A clock consists of a starting point (or epoch) and a tick rate. For example, a clock may have an epoch of January 1, 1970 and tick every second. C++ defines several clock types: system_clock (C++11): wall clock time from the system-wide realtime clock steady_clock (C++11): monotonic clock that will never be adjusted high_resolution_clock (C++11): the clock with the shortest tick period available utc_clock (C++20): Clock for Coordinated Universal Time (UTC) tai_clock (C++20): Clock for International Atomic Time (TAI) gps_clock (C++20): Clock for GPS time file_clock (C++20): Clock used for file time local_t (C++20): pseudo-clock representing local time C++ also inherits the C clock function, which returns the approximate processor time used by the process since the beginning of an implementation-defined era related to the program's execution. To convert result value to seconds divide it by CLOCKS_PER_SEC. The clock function: The only method specified in the standard to measure CPU time It's up to the user to keep track of the duration unit It doesn't work well with threads Ignores the time spent on this_thread::sleep_for std::clock function 1 2 3 4 5 6 7 clock_t start , end ; double cpu_time_used ; start = clock (); very_expensive_function (); end = clock (); cpu_time_used = static_cast < float > ( end - start ) / CLOCKS_PER_SEC ; std :: cout << \"cpu_time_used: \" << cpu_time_used << \" seconds\" << '\\n' ; Modern C++ System Clock 1 2 3 auto start2 = std :: chrono :: system_clock :: now (); very_expensive_function (); auto end2 = std :: chrono :: system_clock :: now (); Duration represented with the default duration type 1 2 3 auto auto_duration = end2 - start2 ; std :: cout << \"auto_duration.count() : \" << auto_duration . count () << \" ticks\" << '\\n' ; // usually nanoseconds Duration represented with double, ratio in seconds 1 2 3 std :: chrono :: duration < double > seconds_as_double = end2 - start2 ; std :: cout << \"seconds_as_double.count() : \" << seconds_as_double . count () << \" seconds\" << '\\n' ; Duration represented with int, ratio in milliseconds 1 std :: chrono :: duration < int , std :: milli > milliseconds_as_int_ ; Cast duration (double, seconds) to duration (int, milliseconds) 1 2 3 4 5 milliseconds_as_int_ = std :: chrono :: duration_cast < std :: chrono :: duration < int , std :: milli >> ( seconds_as_double ); std :: cout << \"milliseconds_as_int_.count() : \" << milliseconds_as_int_ . count () << \" milliseconds\" << '\\n' ; Using ratio directly 1 2 3 4 5 6 7 8 // Same as using hours constexpr int seconds_per_hour = 60 * 60 ; std :: chrono :: duration < int , std :: ratio < seconds_per_hour >> hours_as_int ; hours_as_int = std :: chrono :: duration_cast < std :: chrono :: duration < int , std :: ratio < 60 * 60 >>> ( seconds_as_double ); std :: cout << \"hours_as_int.count() : \" << hours_as_int . count () << \" hours\" << '\\n' ; Modern C++ Steady Clock 1 2 3 auto start3 = std :: chrono :: steady_clock :: now (); very_expensive_function (); auto end3 = std :: chrono :: steady_clock :: now (); Duration represented with the default duration type 1 2 3 auto d3 = end2 - start2 ; std :: cout << \"auto_duration_3.count() : \" << d3 . count () << \" ticks\" << '\\n' ; // usually nanoseconds Time in seconds as double 1 2 3 std :: chrono :: duration < double > seconds_as_double_3 = end3 - start3 ; std :: cout << \"seconds_as_double_3.count() : \" << seconds_as_double_3 . count () << \" seconds\" << '\\n' ; Time in milliseconds as int 1 2 3 4 5 6 std :: chrono :: duration < int , std :: milli > milliseconds_as_int_3 ; milliseconds_as_int_3 = std :: chrono :: duration_cast < std :: chrono :: duration < int , std :: milli >> ( seconds_as_double_3 ); std :: cout << \"milliseconds_as_int_3.count() : \" << milliseconds_as_int_3 . count () << \" milliseconds\" << '\\n' ; Time in hours as int 1 2 3 4 5 6 7 std :: chrono :: duration < int , std :: ratio < seconds_per_hour >> hours_as_int3 ; // same as using std::hours hours_as_int3 = std :: chrono :: duration_cast < std :: chrono :: duration < int , std :: ratio < seconds_per_hour >>> ( seconds_as_double_3 ); std :: cout << \"hours_as_int3.count() : \" << hours_as_int3 . count () << \" hours\" << '\\n' ; \"Parsing\" time 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // While std::std::chrono::parse is not available in all main compilers auto hours = std :: chrono :: duration_cast < std :: chrono :: hours > ( d3 ); if ( hours . count () > 0 ) { std :: cout << hours . count () << \" hours\" ; } d3 -= hours ; auto seconds = std :: chrono :: duration_cast < std :: chrono :: seconds > ( d3 ); if ( seconds . count () > 0 ) { std :: cout << seconds . count () << \" seconds\" ; } d3 -= seconds ; auto milliseconds = std :: chrono :: duration_cast < std :: chrono :: milliseconds > ( d3 ); if ( milliseconds . count () > 0 ) { std :: cout << milliseconds . count () << \" milliseconds\" ; } d3 -= milliseconds ; auto nanoseconds = std :: chrono :: duration_cast < std :: chrono :: nanoseconds > ( d3 ); if ( nanoseconds . count () > 0 ) { std :: cout << nanoseconds . count () << \" nanoseconds\" ; } Share Snippets","title":"Clock"},{"location":"algorithms-data-structures/date-and-time/datetime/","text":"Datetime Datetime C++20 includes date and time utilities in the chrono library. These utilities were originally developed as the date library, and were finally merged to ISO C++ as of C++20. date.h contains chrono extensions to deal with dates: - https://howardhinnant.github.io/date/date.html - https://howardhinnant.github.io/date/tz.html The date library implementation is currently available on more compilers and platforms than the C++20 library. Find datetime library 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 find_package ( Date QUIET ) if ( NOT Date_FOUND ) # Find Threads library find_package ( Threads ) # Find Curl (to download timezone database) find_package ( CURL QUIET ) if ( NOT CURL_FOUND ) set ( USE_SYSTEM_TZ_DB ON CACHE BOOL \"Build tz library\" FORCE ) else () set ( USE_SYSTEM_TZ_DB OFF CACHE BOOL \"Build tz library\" FORCE ) endif () message ( \"USE_SYSTEM_TZ_DB=${USE_SYSTEM_TZ_DB}\" ) set ( BUILD_TZ_LIB ON CACHE BOOL \"Build tz library\" FORCE ) # Fetch date library FetchContent_Declare ( date GIT_REPOSITORY https://github.com/HowardHinnant/date.git GIT_TAG v3.0.1 ) FetchContent_MakeAvailable ( date ) endif () # Link library add_executable ( datetime datetime.cpp ) target_link_libraries ( datetime date::date date::date-tz ) Headers 1 2 #include <date/date.h> #include <date/tz.h> Enable operator<< for time points 1 2 3 4 // Ensure operator<< it's not ambiguous with C++20 datetime #if !defined(__cpp_lib_chrono) || __cpp_lib_chrono < 201907L using date :: operator << ; #endif Printing time points 1 2 3 // - UTC time zone and microsecond precision const std :: chrono :: time_point now = std :: chrono :: system_clock :: now (); std :: cout << \"Now: \" << now << '\\n' ; Print formatted time points 1 2 std :: cout << \"Formatted: \" << date :: format ( \"%a, %b %d, %Y at %I:%M %p %Z\" , now ) << '\\n' ; Print formatted time points in time zone 1 2 3 4 5 6 { using date :: operator << ; std :: cout << date :: format ( std :: locale ( \"de_DE\" ), \"%a, %b %d, %Y at %T %Z\" , now ) << '\\n' ; } Print Epoch 1 2 3 4 std :: cout << \"Epoch: \" << std :: chrono :: time_point < std :: chrono :: system_clock > ( std :: chrono :: seconds ( 0 )) << '\\n' ; Days since 1970 represented as a single integer 1 2 3 4 5 // - This is a serial-based time-point // - Good for day oriented arithmetic date :: sys_days today = date :: floor < date :: days > ( now ); std :: cout << \"today: \" << today . time_since_epoch (). count () << \" days since epoch\" << '\\n' ; Days since 1970 represented as 3 integers: year / month / day 1 2 3 4 5 6 7 8 9 // - This is a field-based time-point // - Good for returning field values // - Good for month/year arithmetic // Last day of March / 2015 using namespace date :: literals ; date :: year_month_day t_ymd = 2015 _y / date :: March / 22 ; std :: cout << \"t_ymd: \" << t_ymd << '\\n' ; std :: cout << \"t_ymd since epoch: \" << date :: sys_days ( t_ymd ). time_since_epoch (). count () << '\\n' ; Days since 1970 represented as 4 integers: year / month / week / 1 2 3 4 5 6 7 8 9 10 11 12 // weekday // This is a field-based time-point date :: year_month_weekday t_ymw = date :: year { 2015 } / date :: month { 3 } / date :: Monday [ 2 ]; std :: cout << \"t_ymw: \" << t_ymw << '\\n' ; std :: cout << \"t_ymw since epoch: \" << date :: sys_days ( t_ymw ). time_since_epoch (). count () << '\\n' ; std :: cout << \"year_month_day(t3): \" << date :: sys_days ( date :: year_month_day ( t_ymw )) . time_since_epoch () . count () << '\\n' ; Converting to/from year/month/date 1 2 auto today_ymd = date :: year_month_day { today }; std :: cout << \"Today is \" << today_ymd << '\\n' ; Durations 1 2 3 4 5 // - Time since midnight (serial-based) auto time_since_midnight = now - today ; std :: cout << \"Serial time since midnight \" << duration_cast < std :: chrono :: seconds > ( time_since_midnight ) << '\\n' ; Time since midnight (field-based) 1 2 3 date :: hh_mm_ss time_since_midnight_hms ( time_since_midnight ); std :: cout << \"Field-based time since midnight: \" << today_ymd << \" - \" << time_since_midnight_hms << '\\n' ; Time since midnight (field-based) 1 2 3 auto time_since_midnight_tod = date :: make_time ( time_since_midnight ); std :: cout << \"Field-based time since midnight: \" << today_ymd << \" - \" << time_since_midnight_tod << '\\n' ; Checking invalid field based dates 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // They are possible, and they might be even useful std :: cout << \"All odd fridays this year: \" ; date :: year this_year = today_ymd . year (); for ( auto m = 1 ; m <= 12 ; ++ m ) { auto first_friday = date :: year_month_day ( this_year / m / date :: Friday [ 1 ]); std :: cout << first_friday << ' ' ; auto third_friday = first_friday . year () / first_friday . month () / ( first_friday . day () + date :: weeks { 2 }); std :: cout << third_friday << ' ' ; auto fifth_friday = third_friday . year () / third_friday . month () / ( third_friday . day () + date :: weeks { 2 }); if ( fifth_friday . ok ()) { std :: cout << fifth_friday << ' ' ; } } std :: cout << '\\n' ; Dealing with time zones 1 2 // Zoned time is a wrapper that also keeps track of the shift from UTC date :: zoned_time local_tp = date :: make_zoned ( date :: current_zone (), now ); Zone pointers 1 2 3 4 5 6 7 8 9 // Little more efficient. Less convenient unless reusing the zone ptr. auto berlin_zone = date :: locate_zone ( \"Europe/Berlin\" ); auto berlin_time = date :: make_zoned ( berlin_zone , floor < std :: chrono :: seconds > ( std :: chrono :: system_clock :: now ())); std :: cout << \"berlin time: \" << date :: format ( std :: locale ( \"de_DE\" ), \"%a, %b %d, %Y at %T %Z\" , berlin_time ) << '\\n' ; Make zoned time 1 2 3 4 5 6 7 8 // Little less efficient. More convenient. auto sp_time = date :: make_zoned ( \"America/Sao_Paulo\" , floor < std :: chrono :: seconds > ( std :: chrono :: system_clock :: now ())); std :: cout << \"sao paulo time: \" << date :: format ( std :: locale ( \"de_DE\" ), \"%a, %b %d, %Y at %T %Z\" , sp_time ) << '\\n' ; Time zone details 1 2 3 std :: cout << \"local_tp: \" << local_tp << '\\n' ; std :: cout << \"abbrev: \" << local_tp . get_info (). abbrev << '\\n' ; std :: cout << \"Sys time: \" << local_tp . get_sys_time () << '\\n' ; Convert zoned time point 1 2 3 std :: cout << \"offset: \" << local_tp . get_info (). offset << '\\n' ; std :: cout << \"save: \" << local_tp . get_info (). save << '\\n' ; std :: cout << \"Local time: \" << local_tp . get_local_time () << '\\n' ; Format zoned time point 1 2 3 4 5 6 std :: cout << \"Formatted: \" << date :: format ( \"%a, %b %d, %Y at %I:%M %p %Z\" , local_tp ) << '\\n' ; std :: cout << date :: format ( std :: locale ( \"de_DE\" ), \"%a, %b %d, %Y at %T %Z\" , local_tp ) << '\\n' ; Change precision 1 2 3 4 auto now_nanoseconds = date :: floor < std :: chrono :: nanoseconds > ( now ); auto local_tp_nanoseconds = date :: make_zoned ( date :: current_zone (), now_nanoseconds ); std :: cout << \"In millisecs: \" << local_tp_nanoseconds << '\\n' ; Change precision to milliseconds 1 2 3 4 auto now_milliseconds = date :: floor < std :: chrono :: milliseconds > ( now ); auto local_tp_milliseconds = date :: make_zoned ( date :: current_zone (), now_milliseconds ); std :: cout << \"In millisecs: \" << local_tp_milliseconds << '\\n' ; Change precision to milliseconds 1 2 3 4 auto now_milliseconds = date :: floor < std :: chrono :: milliseconds > ( now ); auto local_tp_milliseconds = date :: make_zoned ( date :: current_zone (), now_milliseconds ); std :: cout << \"In millisecs: \" << local_tp_milliseconds << '\\n' ; Change precision to milliseconds 1 2 3 4 auto now_milliseconds = date :: floor < std :: chrono :: milliseconds > ( now ); auto local_tp_milliseconds = date :: make_zoned ( date :: current_zone (), now_milliseconds ); std :: cout << \"In millisecs: \" << local_tp_milliseconds << '\\n' ; Change precision to milliseconds 1 2 3 4 auto now_milliseconds = date :: floor < std :: chrono :: milliseconds > ( now ); auto local_tp_milliseconds = date :: make_zoned ( date :: current_zone (), now_milliseconds ); std :: cout << \"In millisecs: \" << local_tp_milliseconds << '\\n' ; Convert time between zones 1 2 3 auto tokyo_tp = date :: make_zoned ( \"Asia/Tokyo\" , sp_time ); std :: cout << sp_time << \" in sao paulo is \" << tokyo_tp << \" in tokyo\" << '\\n' ; Share Snippets","title":"Datetime"},{"location":"algorithms-data-structures/date-and-time/datetime/#datetime","text":"Datetime C++20 includes date and time utilities in the chrono library. These utilities were originally developed as the date library, and were finally merged to ISO C++ as of C++20. date.h contains chrono extensions to deal with dates: - https://howardhinnant.github.io/date/date.html - https://howardhinnant.github.io/date/tz.html The date library implementation is currently available on more compilers and platforms than the C++20 library. Find datetime library 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 find_package ( Date QUIET ) if ( NOT Date_FOUND ) # Find Threads library find_package ( Threads ) # Find Curl (to download timezone database) find_package ( CURL QUIET ) if ( NOT CURL_FOUND ) set ( USE_SYSTEM_TZ_DB ON CACHE BOOL \"Build tz library\" FORCE ) else () set ( USE_SYSTEM_TZ_DB OFF CACHE BOOL \"Build tz library\" FORCE ) endif () message ( \"USE_SYSTEM_TZ_DB=${USE_SYSTEM_TZ_DB}\" ) set ( BUILD_TZ_LIB ON CACHE BOOL \"Build tz library\" FORCE ) # Fetch date library FetchContent_Declare ( date GIT_REPOSITORY https://github.com/HowardHinnant/date.git GIT_TAG v3.0.1 ) FetchContent_MakeAvailable ( date ) endif () # Link library add_executable ( datetime datetime.cpp ) target_link_libraries ( datetime date::date date::date-tz ) Headers 1 2 #include <date/date.h> #include <date/tz.h> Enable operator<< for time points 1 2 3 4 // Ensure operator<< it's not ambiguous with C++20 datetime #if !defined(__cpp_lib_chrono) || __cpp_lib_chrono < 201907L using date :: operator << ; #endif Printing time points 1 2 3 // - UTC time zone and microsecond precision const std :: chrono :: time_point now = std :: chrono :: system_clock :: now (); std :: cout << \"Now: \" << now << '\\n' ; Print formatted time points 1 2 std :: cout << \"Formatted: \" << date :: format ( \"%a, %b %d, %Y at %I:%M %p %Z\" , now ) << '\\n' ; Print formatted time points in time zone 1 2 3 4 5 6 { using date :: operator << ; std :: cout << date :: format ( std :: locale ( \"de_DE\" ), \"%a, %b %d, %Y at %T %Z\" , now ) << '\\n' ; } Print Epoch 1 2 3 4 std :: cout << \"Epoch: \" << std :: chrono :: time_point < std :: chrono :: system_clock > ( std :: chrono :: seconds ( 0 )) << '\\n' ; Days since 1970 represented as a single integer 1 2 3 4 5 // - This is a serial-based time-point // - Good for day oriented arithmetic date :: sys_days today = date :: floor < date :: days > ( now ); std :: cout << \"today: \" << today . time_since_epoch (). count () << \" days since epoch\" << '\\n' ; Days since 1970 represented as 3 integers: year / month / day 1 2 3 4 5 6 7 8 9 // - This is a field-based time-point // - Good for returning field values // - Good for month/year arithmetic // Last day of March / 2015 using namespace date :: literals ; date :: year_month_day t_ymd = 2015 _y / date :: March / 22 ; std :: cout << \"t_ymd: \" << t_ymd << '\\n' ; std :: cout << \"t_ymd since epoch: \" << date :: sys_days ( t_ymd ). time_since_epoch (). count () << '\\n' ; Days since 1970 represented as 4 integers: year / month / week / 1 2 3 4 5 6 7 8 9 10 11 12 // weekday // This is a field-based time-point date :: year_month_weekday t_ymw = date :: year { 2015 } / date :: month { 3 } / date :: Monday [ 2 ]; std :: cout << \"t_ymw: \" << t_ymw << '\\n' ; std :: cout << \"t_ymw since epoch: \" << date :: sys_days ( t_ymw ). time_since_epoch (). count () << '\\n' ; std :: cout << \"year_month_day(t3): \" << date :: sys_days ( date :: year_month_day ( t_ymw )) . time_since_epoch () . count () << '\\n' ; Converting to/from year/month/date 1 2 auto today_ymd = date :: year_month_day { today }; std :: cout << \"Today is \" << today_ymd << '\\n' ; Durations 1 2 3 4 5 // - Time since midnight (serial-based) auto time_since_midnight = now - today ; std :: cout << \"Serial time since midnight \" << duration_cast < std :: chrono :: seconds > ( time_since_midnight ) << '\\n' ; Time since midnight (field-based) 1 2 3 date :: hh_mm_ss time_since_midnight_hms ( time_since_midnight ); std :: cout << \"Field-based time since midnight: \" << today_ymd << \" - \" << time_since_midnight_hms << '\\n' ; Time since midnight (field-based) 1 2 3 auto time_since_midnight_tod = date :: make_time ( time_since_midnight ); std :: cout << \"Field-based time since midnight: \" << today_ymd << \" - \" << time_since_midnight_tod << '\\n' ; Checking invalid field based dates 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // They are possible, and they might be even useful std :: cout << \"All odd fridays this year: \" ; date :: year this_year = today_ymd . year (); for ( auto m = 1 ; m <= 12 ; ++ m ) { auto first_friday = date :: year_month_day ( this_year / m / date :: Friday [ 1 ]); std :: cout << first_friday << ' ' ; auto third_friday = first_friday . year () / first_friday . month () / ( first_friday . day () + date :: weeks { 2 }); std :: cout << third_friday << ' ' ; auto fifth_friday = third_friday . year () / third_friday . month () / ( third_friday . day () + date :: weeks { 2 }); if ( fifth_friday . ok ()) { std :: cout << fifth_friday << ' ' ; } } std :: cout << '\\n' ; Dealing with time zones 1 2 // Zoned time is a wrapper that also keeps track of the shift from UTC date :: zoned_time local_tp = date :: make_zoned ( date :: current_zone (), now ); Zone pointers 1 2 3 4 5 6 7 8 9 // Little more efficient. Less convenient unless reusing the zone ptr. auto berlin_zone = date :: locate_zone ( \"Europe/Berlin\" ); auto berlin_time = date :: make_zoned ( berlin_zone , floor < std :: chrono :: seconds > ( std :: chrono :: system_clock :: now ())); std :: cout << \"berlin time: \" << date :: format ( std :: locale ( \"de_DE\" ), \"%a, %b %d, %Y at %T %Z\" , berlin_time ) << '\\n' ; Make zoned time 1 2 3 4 5 6 7 8 // Little less efficient. More convenient. auto sp_time = date :: make_zoned ( \"America/Sao_Paulo\" , floor < std :: chrono :: seconds > ( std :: chrono :: system_clock :: now ())); std :: cout << \"sao paulo time: \" << date :: format ( std :: locale ( \"de_DE\" ), \"%a, %b %d, %Y at %T %Z\" , sp_time ) << '\\n' ; Time zone details 1 2 3 std :: cout << \"local_tp: \" << local_tp << '\\n' ; std :: cout << \"abbrev: \" << local_tp . get_info (). abbrev << '\\n' ; std :: cout << \"Sys time: \" << local_tp . get_sys_time () << '\\n' ; Convert zoned time point 1 2 3 std :: cout << \"offset: \" << local_tp . get_info (). offset << '\\n' ; std :: cout << \"save: \" << local_tp . get_info (). save << '\\n' ; std :: cout << \"Local time: \" << local_tp . get_local_time () << '\\n' ; Format zoned time point 1 2 3 4 5 6 std :: cout << \"Formatted: \" << date :: format ( \"%a, %b %d, %Y at %I:%M %p %Z\" , local_tp ) << '\\n' ; std :: cout << date :: format ( std :: locale ( \"de_DE\" ), \"%a, %b %d, %Y at %T %Z\" , local_tp ) << '\\n' ; Change precision 1 2 3 4 auto now_nanoseconds = date :: floor < std :: chrono :: nanoseconds > ( now ); auto local_tp_nanoseconds = date :: make_zoned ( date :: current_zone (), now_nanoseconds ); std :: cout << \"In millisecs: \" << local_tp_nanoseconds << '\\n' ; Change precision to milliseconds 1 2 3 4 auto now_milliseconds = date :: floor < std :: chrono :: milliseconds > ( now ); auto local_tp_milliseconds = date :: make_zoned ( date :: current_zone (), now_milliseconds ); std :: cout << \"In millisecs: \" << local_tp_milliseconds << '\\n' ; Change precision to milliseconds 1 2 3 4 auto now_milliseconds = date :: floor < std :: chrono :: milliseconds > ( now ); auto local_tp_milliseconds = date :: make_zoned ( date :: current_zone (), now_milliseconds ); std :: cout << \"In millisecs: \" << local_tp_milliseconds << '\\n' ; Change precision to milliseconds 1 2 3 4 auto now_milliseconds = date :: floor < std :: chrono :: milliseconds > ( now ); auto local_tp_milliseconds = date :: make_zoned ( date :: current_zone (), now_milliseconds ); std :: cout << \"In millisecs: \" << local_tp_milliseconds << '\\n' ; Change precision to milliseconds 1 2 3 4 auto now_milliseconds = date :: floor < std :: chrono :: milliseconds > ( now ); auto local_tp_milliseconds = date :: make_zoned ( date :: current_zone (), now_milliseconds ); std :: cout << \"In millisecs: \" << local_tp_milliseconds << '\\n' ; Convert time between zones 1 2 3 auto tokyo_tp = date :: make_zoned ( \"Asia/Tokyo\" , sp_time ); std :: cout << sp_time << \" in sao paulo is \" << tokyo_tp << \" in tokyo\" << '\\n' ; Share Snippets","title":"Datetime"},{"location":"algorithms-data-structures/heterogeneous-types/any/","text":"Any Any The class std::any describes a type-safe container for single values of any copy constructible type. 1) An object of class any stores an instance of any type that satisfies the constructor requirements or is empty, and this is referred to as the state of the class any object. The stored instance is called the contained object. Two states are equivalent if they are either both empty or if both are not empty and if the contained objects are equivalent. 2) The non-member any_cast functions provide type-safe access to the contained object. Implementations are encouraged to avoid dynamic allocations for small objects, but such an optimization may only be applied to types for which std::is_nothrow_move_constructible returns true . std::any is a container for single values of any type 1 2 // Be careful when using it std :: any a = 1 ; Accessing values (int) 1 std :: cout << a . type (). name () << \": \" << std :: any_cast < int > ( a ) << '\\n' ; Accessing values (double) 1 2 a = 3.14 ; std :: cout << a . type (). name () << \": \" << std :: any_cast < double > ( a ) << '\\n' ; Accessing values (bool) 1 2 a = true ; std :: cout << a . type (). name () << \": \" << std :: any_cast < bool > ( a ) << '\\n' ; Accessing values (string) 1 2 a = std :: string ( \"Any string\" ); std :: cout << a . type (). name () << \": \" << std :: any_cast < std :: string > ( a ) << '\\n' ; Attempting to access values 1 2 3 4 5 6 try { std :: any v = 1 ; std :: cout << std :: any_cast < float > ( v ) << '\\n' ; } catch ( std :: bad_any_cast & e ) { std :: cout << e . what () << '\\n' ; } Checking if variable is empty 1 2 3 4 5 std :: any s2 = 1 ; if ( ! s2 . has_value ()) { const std :: type_info & ti = s2 . type (); std :: cout << ti . name () << '\\n' ; } Access pointer to value 1 2 3 std :: any a3 = 1 ; int * i = std :: any_cast < int > ( & a3 ); std :: cout << * i << '\\n' ; Share Snippets","title":"Any"},{"location":"algorithms-data-structures/heterogeneous-types/any/#any","text":"Any The class std::any describes a type-safe container for single values of any copy constructible type. 1) An object of class any stores an instance of any type that satisfies the constructor requirements or is empty, and this is referred to as the state of the class any object. The stored instance is called the contained object. Two states are equivalent if they are either both empty or if both are not empty and if the contained objects are equivalent. 2) The non-member any_cast functions provide type-safe access to the contained object. Implementations are encouraged to avoid dynamic allocations for small objects, but such an optimization may only be applied to types for which std::is_nothrow_move_constructible returns true . std::any is a container for single values of any type 1 2 // Be careful when using it std :: any a = 1 ; Accessing values (int) 1 std :: cout << a . type (). name () << \": \" << std :: any_cast < int > ( a ) << '\\n' ; Accessing values (double) 1 2 a = 3.14 ; std :: cout << a . type (). name () << \": \" << std :: any_cast < double > ( a ) << '\\n' ; Accessing values (bool) 1 2 a = true ; std :: cout << a . type (). name () << \": \" << std :: any_cast < bool > ( a ) << '\\n' ; Accessing values (string) 1 2 a = std :: string ( \"Any string\" ); std :: cout << a . type (). name () << \": \" << std :: any_cast < std :: string > ( a ) << '\\n' ; Attempting to access values 1 2 3 4 5 6 try { std :: any v = 1 ; std :: cout << std :: any_cast < float > ( v ) << '\\n' ; } catch ( std :: bad_any_cast & e ) { std :: cout << e . what () << '\\n' ; } Checking if variable is empty 1 2 3 4 5 std :: any s2 = 1 ; if ( ! s2 . has_value ()) { const std :: type_info & ti = s2 . type (); std :: cout << ti . name () << '\\n' ; } Access pointer to value 1 2 3 std :: any a3 = 1 ; int * i = std :: any_cast < int > ( & a3 ); std :: cout << * i << '\\n' ; Share Snippets","title":"Any"},{"location":"algorithms-data-structures/heterogeneous-types/optional/","text":"Optional Optional The class template std::optional manages an optional contained value, i.e. a value that may or may not be present. A common use case for optional is the return value of a function that may fail. As opposed to other approaches, such as std::pair , optional handles expensive-to-construct objects well and is more readable, as the intent is expressed explicitly. Any instance of optional<T> at any given point in time either contains a value or does not contain a value. Function that returns a value only if it's even 1 2 3 4 5 6 7 8 std :: optional < int > get_even_random_number () { int i = std :: rand (); if ( i % 2 == 0 ) { return i ; } else { return std :: nullopt ; } } Function that always returns a non-empty optional value 1 2 3 4 std :: optional < int > get_even_random_number2 () { int i = std :: rand (); return std :: make_optional ( int ( i % 2 == 0 )); } Call function that returns optional value 1 2 3 4 5 6 std :: optional < int > i = get_even_random_number (); if ( i ) { std :: cout << std :: sqrt ( static_cast < float > ( * i )) << '\\n' ; } else { std :: cout << \"No value was returned\" << '\\n' ; } Call function that returns non-empty optional value 1 2 3 4 i = get_even_random_number2 (); double d = i . value_or ( 0 ); std :: cout << std :: sqrt ( d ) << '\\n' ; std :: cout << i . value_or ( 0 ) << std :: endl ; Share Snippets","title":"Optional"},{"location":"algorithms-data-structures/heterogeneous-types/optional/#optional","text":"Optional The class template std::optional manages an optional contained value, i.e. a value that may or may not be present. A common use case for optional is the return value of a function that may fail. As opposed to other approaches, such as std::pair , optional handles expensive-to-construct objects well and is more readable, as the intent is expressed explicitly. Any instance of optional<T> at any given point in time either contains a value or does not contain a value. Function that returns a value only if it's even 1 2 3 4 5 6 7 8 std :: optional < int > get_even_random_number () { int i = std :: rand (); if ( i % 2 == 0 ) { return i ; } else { return std :: nullopt ; } } Function that always returns a non-empty optional value 1 2 3 4 std :: optional < int > get_even_random_number2 () { int i = std :: rand (); return std :: make_optional ( int ( i % 2 == 0 )); } Call function that returns optional value 1 2 3 4 5 6 std :: optional < int > i = get_even_random_number (); if ( i ) { std :: cout << std :: sqrt ( static_cast < float > ( * i )) << '\\n' ; } else { std :: cout << \"No value was returned\" << '\\n' ; } Call function that returns non-empty optional value 1 2 3 4 i = get_even_random_number2 (); double d = i . value_or ( 0 ); std :: cout << std :: sqrt ( d ) << '\\n' ; std :: cout << i . value_or ( 0 ) << std :: endl ; Share Snippets","title":"Optional"},{"location":"algorithms-data-structures/heterogeneous-types/tuples/","text":"Tuples Tuples Class template std::tuple is a fixed-size collection of heterogeneous values. It is a generalization of std::pair for more than 2 values. Headers 1 #include <tuple> Returning values by reference 1 2 3 4 5 6 7 8 9 void reference_minmax ( int a , int b , int & min , int & max ) { if ( a < b ) { min = a ; max = b ; } else { min = b ; max = a ; } } Returning values with std::tuple 1 2 3 4 5 6 7 std :: tuple < int , int > tuple_minmax ( int a , int b ) { if ( a < b ) { return std :: make_tuple ( a , b ); } else { return std :: make_tuple ( b , a ); } } Call function \"returning\" by reference 1 2 3 4 5 int min ; int max ; reference_minmax ( 3 , 2 , min , max ); std :: cout << \"min : \" << min << '\\n' ; std :: cout << \"max : \" << max << '\\n' ; Call function returning a tuple 1 2 3 auto t4 = tuple_minmax ( 3 , 2 ); std :: cout << \"min : \" << std :: get < 0 > ( t4 ) << '\\n' ; std :: cout << \"max : \" << std :: get < 1 > ( t4 ) << '\\n' ; Custom pair structure for results 1 2 3 4 5 6 7 struct my_pair { char first ; int second ; }; // ... my_pair s { 'c' , 15 }; std :: cout << \"s.first: \" << s . first << \", s.second: \" << s . second << '\\n' ; std::pair for results 1 2 std :: pair < char , int > p { 'c' , 15 }; std :: cout << \"p.first: \" << p . first << \", p.second: \" << p . second << '\\n' ; std::tuple for results 1 2 std :: pair < char , int > t ( 'c' , 15 ); std :: cout << \"t.first: \" << t . first << \", t.second: \" << t . second << '\\n' ; Using type deduction 1 2 3 auto t2 = std :: make_pair < char , int > ( 'c' , 15 ); std :: cout << \"t2.first: \" << t2 . first << \", t2.second: \" << t2 . second << '\\n' ; Larger tuples 1 2 3 4 5 auto t3 = std :: make_tuple ( 6.3 , \"text\" , 2 , 'o' ); char x = std :: get < 3 > ( t3 ); std :: cout << \"x: \" << x << '\\n' ; std :: cout << \"std::get<0>(t3): \" << std :: get < 0 > ( t3 ) << \", std::get<1>(t3): \" << std :: get < 1 > ( t3 ) << '\\n' ; std::tie 1 2 3 4 5 int a ; char b ; std :: tie ( std :: ignore , std :: ignore , a , b ) = t3 ; std :: cout << \"a: \" << a << '\\n' ; std :: cout << \"b: \" << b << '\\n' ; Unpacking a tuple 1 2 3 4 5 int min2 ; int max2 ; std :: tie ( min2 , max2 ) = tuple_minmax ( 3 , 2 ); std :: cout << \"min : \" << min2 << '\\n' ; std :: cout << \"max : \" << max2 << '\\n' ; Structured binding 1 2 3 auto [ min3 , max3 ] = tuple_minmax ( 3 , 2 ); std :: cout << \"min : \" << min3 << '\\n' ; std :: cout << \"max : \" << max3 << '\\n' ; Share Snippets","title":"Tuples"},{"location":"algorithms-data-structures/heterogeneous-types/tuples/#tuples","text":"Tuples Class template std::tuple is a fixed-size collection of heterogeneous values. It is a generalization of std::pair for more than 2 values. Headers 1 #include <tuple> Returning values by reference 1 2 3 4 5 6 7 8 9 void reference_minmax ( int a , int b , int & min , int & max ) { if ( a < b ) { min = a ; max = b ; } else { min = b ; max = a ; } } Returning values with std::tuple 1 2 3 4 5 6 7 std :: tuple < int , int > tuple_minmax ( int a , int b ) { if ( a < b ) { return std :: make_tuple ( a , b ); } else { return std :: make_tuple ( b , a ); } } Call function \"returning\" by reference 1 2 3 4 5 int min ; int max ; reference_minmax ( 3 , 2 , min , max ); std :: cout << \"min : \" << min << '\\n' ; std :: cout << \"max : \" << max << '\\n' ; Call function returning a tuple 1 2 3 auto t4 = tuple_minmax ( 3 , 2 ); std :: cout << \"min : \" << std :: get < 0 > ( t4 ) << '\\n' ; std :: cout << \"max : \" << std :: get < 1 > ( t4 ) << '\\n' ; Custom pair structure for results 1 2 3 4 5 6 7 struct my_pair { char first ; int second ; }; // ... my_pair s { 'c' , 15 }; std :: cout << \"s.first: \" << s . first << \", s.second: \" << s . second << '\\n' ; std::pair for results 1 2 std :: pair < char , int > p { 'c' , 15 }; std :: cout << \"p.first: \" << p . first << \", p.second: \" << p . second << '\\n' ; std::tuple for results 1 2 std :: pair < char , int > t ( 'c' , 15 ); std :: cout << \"t.first: \" << t . first << \", t.second: \" << t . second << '\\n' ; Using type deduction 1 2 3 auto t2 = std :: make_pair < char , int > ( 'c' , 15 ); std :: cout << \"t2.first: \" << t2 . first << \", t2.second: \" << t2 . second << '\\n' ; Larger tuples 1 2 3 4 5 auto t3 = std :: make_tuple ( 6.3 , \"text\" , 2 , 'o' ); char x = std :: get < 3 > ( t3 ); std :: cout << \"x: \" << x << '\\n' ; std :: cout << \"std::get<0>(t3): \" << std :: get < 0 > ( t3 ) << \", std::get<1>(t3): \" << std :: get < 1 > ( t3 ) << '\\n' ; std::tie 1 2 3 4 5 int a ; char b ; std :: tie ( std :: ignore , std :: ignore , a , b ) = t3 ; std :: cout << \"a: \" << a << '\\n' ; std :: cout << \"b: \" << b << '\\n' ; Unpacking a tuple 1 2 3 4 5 int min2 ; int max2 ; std :: tie ( min2 , max2 ) = tuple_minmax ( 3 , 2 ); std :: cout << \"min : \" << min2 << '\\n' ; std :: cout << \"max : \" << max2 << '\\n' ; Structured binding 1 2 3 auto [ min3 , max3 ] = tuple_minmax ( 3 , 2 ); std :: cout << \"min : \" << min3 << '\\n' ; std :: cout << \"max : \" << max3 << '\\n' ; Share Snippets","title":"Tuples"},{"location":"algorithms-data-structures/heterogeneous-types/variant/","text":"Variant Variant The class template std::variant (C++17) represents a type-safe union. An instance of std::variant at any given time either holds a value of one of its alternative types, or in the case of error - no value. If we define a variant v including lots of types, including booleans and lists, this would be somewhat similar to: PHP: $v = 3.14; // see https://bit.ly/3cVuJvb Python: v = 3.14; Javascript: var v = 3.14; As with unions, if a variant holds a value of some object type T , the object representation of T is allocated directly within the object representation of the variant itself. Variant is not allowed to allocate additional (dynamic) memory. A variant is not permitted to hold references, arrays, or the type void . Empty variants are also ill-formed (std::variant can be used instead). A variant is permitted to hold the same type more than once, and to hold differently cv-qualified versions of the same type. Consistent with the behavior of unions during aggregate initialization, a default-constructed variant holds a value of its first alternative, unless that alternative is not default-constructible (in which case the variant is not default-constructible either). The helper class std::monostate can be used to make such variants default-constructible. Declare an C union 1 2 3 4 5 union my_union { double a ; char b ; int c ; }; Using unions 1 2 3 4 5 // - It only works with fundamental data type // - It doesn't have convenience functions my_union u = { 3.14 }; u = { 'A' }; u = { 15 }; Union size 1 2 3 4 5 // A union is as large as the largest type in the union std :: cout << \"sizeof(double): \" << sizeof ( double ) << '\\n' ; std :: cout << \"sizeof(char): \" << sizeof ( char ) << '\\n' ; std :: cout << \"sizeof(int): \" << sizeof ( int ) << '\\n' ; std :: cout << \"sizeof(my_union): \" << sizeof ( my_union ) << '\\n' ; Declaring a variant type 1 std :: variant < double , char , std :: string > v ; Setting variant values 1 2 3 v = 3.14 ; // becomes double v = 'A' ; // becomes char v = \"Some longer text\" ; // becomes std::string Variant size 1 2 3 4 5 6 7 // A variant is larger than the largest type in the variant // This happens because variants need a flag to indicate the current type std :: cout << \"sizeof(double): \" << sizeof ( double ) << '\\n' ; std :: cout << \"sizeof(char): \" << sizeof ( char ) << '\\n' ; std :: cout << \"sizeof(string): \" << sizeof ( std :: string ) << '\\n' ; std :: cout << \"sizeof(variant<double, char, std::string>): \" << sizeof ( std :: variant < double , char , std :: string > ) << '\\n' ; Accessing values 1 2 3 4 5 6 v = 3.14 ; std :: cout << get < double > ( v ) << '\\n' ; v = 'A' ; std :: cout << get < char > ( v ) << '\\n' ; v = \"Some longer text\" ; std :: cout << get < std :: string > ( v ) << '\\n' ; Visiting variant 1 2 // Applying function to whatever value type it holds std :: visit ([]( auto x ) { std :: cout << x << '\\n' ; }, v ); Checking current alternative index 1 2 3 4 5 6 7 8 9 10 11 switch ( v . index ()) { case 0 : std :: cout << \"This is a double \\n \" ; break ; case 1 : std :: cout << \"This is a char \\n \" ; break ; case 2 : std :: cout << \"This is a string \\n \" ; break ; } Checking current alternative type 1 2 3 4 5 6 7 if ( std :: holds_alternative < double > ( v )) { std :: cout << \"This is a double \\n \" ; } else if ( std :: holds_alternative < char > ( v )) { std :: cout << \"This is a char \\n \" ; } else if ( std :: holds_alternative < std :: string > ( v )) { std :: cout << \"This is a string \\n \" ; } Share Snippets","title":"Variant"},{"location":"algorithms-data-structures/heterogeneous-types/variant/#variant","text":"Variant The class template std::variant (C++17) represents a type-safe union. An instance of std::variant at any given time either holds a value of one of its alternative types, or in the case of error - no value. If we define a variant v including lots of types, including booleans and lists, this would be somewhat similar to: PHP: $v = 3.14; // see https://bit.ly/3cVuJvb Python: v = 3.14; Javascript: var v = 3.14; As with unions, if a variant holds a value of some object type T , the object representation of T is allocated directly within the object representation of the variant itself. Variant is not allowed to allocate additional (dynamic) memory. A variant is not permitted to hold references, arrays, or the type void . Empty variants are also ill-formed (std::variant can be used instead). A variant is permitted to hold the same type more than once, and to hold differently cv-qualified versions of the same type. Consistent with the behavior of unions during aggregate initialization, a default-constructed variant holds a value of its first alternative, unless that alternative is not default-constructible (in which case the variant is not default-constructible either). The helper class std::monostate can be used to make such variants default-constructible. Declare an C union 1 2 3 4 5 union my_union { double a ; char b ; int c ; }; Using unions 1 2 3 4 5 // - It only works with fundamental data type // - It doesn't have convenience functions my_union u = { 3.14 }; u = { 'A' }; u = { 15 }; Union size 1 2 3 4 5 // A union is as large as the largest type in the union std :: cout << \"sizeof(double): \" << sizeof ( double ) << '\\n' ; std :: cout << \"sizeof(char): \" << sizeof ( char ) << '\\n' ; std :: cout << \"sizeof(int): \" << sizeof ( int ) << '\\n' ; std :: cout << \"sizeof(my_union): \" << sizeof ( my_union ) << '\\n' ; Declaring a variant type 1 std :: variant < double , char , std :: string > v ; Setting variant values 1 2 3 v = 3.14 ; // becomes double v = 'A' ; // becomes char v = \"Some longer text\" ; // becomes std::string Variant size 1 2 3 4 5 6 7 // A variant is larger than the largest type in the variant // This happens because variants need a flag to indicate the current type std :: cout << \"sizeof(double): \" << sizeof ( double ) << '\\n' ; std :: cout << \"sizeof(char): \" << sizeof ( char ) << '\\n' ; std :: cout << \"sizeof(string): \" << sizeof ( std :: string ) << '\\n' ; std :: cout << \"sizeof(variant<double, char, std::string>): \" << sizeof ( std :: variant < double , char , std :: string > ) << '\\n' ; Accessing values 1 2 3 4 5 6 v = 3.14 ; std :: cout << get < double > ( v ) << '\\n' ; v = 'A' ; std :: cout << get < char > ( v ) << '\\n' ; v = \"Some longer text\" ; std :: cout << get < std :: string > ( v ) << '\\n' ; Visiting variant 1 2 // Applying function to whatever value type it holds std :: visit ([]( auto x ) { std :: cout << x << '\\n' ; }, v ); Checking current alternative index 1 2 3 4 5 6 7 8 9 10 11 switch ( v . index ()) { case 0 : std :: cout << \"This is a double \\n \" ; break ; case 1 : std :: cout << \"This is a char \\n \" ; break ; case 2 : std :: cout << \"This is a string \\n \" ; break ; } Checking current alternative type 1 2 3 4 5 6 7 if ( std :: holds_alternative < double > ( v )) { std :: cout << \"This is a double \\n \" ; } else if ( std :: holds_alternative < char > ( v )) { std :: cout << \"This is a char \\n \" ; } else if ( std :: holds_alternative < std :: string > ( v )) { std :: cout << \"This is a string \\n \" ; } Share Snippets","title":"Variant"},{"location":"algorithms-data-structures/random/pcg/","text":"PCG PCG The PCG library provides a number of better random number generators. The library has a interface that resembles standard C++ number generators with generators that: Do not fail statistical tests for randomness Ensure unpredictability and safety Are fast and don't require large amounts of memory Provide useful features such as \"jump ahead\" Find PCG 1 2 3 4 5 6 7 8 9 10 11 12 13 find_package ( pcg-cpp QUIET ) if ( NOT pcg-cpp_FOUND ) FetchContent_Declare ( pcg-cpp GIT_REPOSITORY https://github.com/imneme/pcg-cpp.git GIT_TAG v0.98.1 ) FetchContent_GetProperties ( pcg-cpp ) if ( NOT pcg-cpp_POPULATED ) FetchContent_Populate ( pcg-cpp ) # Create header-only library with pcg-cpp include files add_library ( pcg-cpp INTERFACE ) target_include_directories ( pcg-cpp INTERFACE ${ pcg-cpp_SOURCE_DIR } /include ) endif () endif () add_executable ( pcg pcg.cpp ) target_link_libraries ( pcg pcg-cpp ) Initialize generator with two fixed seeds 1 pcg32 rng ( 42u , 54u ); Seed generator with external entropy 1 rng . seed ( pcg_extras :: seed_seq_from < std :: random_device > ()); Random numbers 1 std :: cout << \"Random number: \" << rng () << '\\n' ; Flip coins 1 std :: cout << \"Flip coin: \" << rng ( 2 ) << '\\n' ; Roll dice 1 std :: cout << \"Roll dice: \" << rng ( 6 ) << '\\n' ; Print generator state 1 2 3 std :: cout << \"Generator state: \" << rng << '\\n' ; std :: cout << \"Result size: \" << sizeof ( pcg32 :: result_type ) * 8 << \"bits\" << '\\n' ; std :: cout << \"Period: 2^\" << pcg32 :: period_pow2 () << '\\n' ; Use with C++ distributions 1 2 std :: uniform_real_distribution < double > distribution ( 1.0 , 10.0 ); std :: cout << distribution ( rng ) << '\\n' ; Share Snippets","title":"PCG"},{"location":"algorithms-data-structures/random/pcg/#pcg","text":"PCG The PCG library provides a number of better random number generators. The library has a interface that resembles standard C++ number generators with generators that: Do not fail statistical tests for randomness Ensure unpredictability and safety Are fast and don't require large amounts of memory Provide useful features such as \"jump ahead\" Find PCG 1 2 3 4 5 6 7 8 9 10 11 12 13 find_package ( pcg-cpp QUIET ) if ( NOT pcg-cpp_FOUND ) FetchContent_Declare ( pcg-cpp GIT_REPOSITORY https://github.com/imneme/pcg-cpp.git GIT_TAG v0.98.1 ) FetchContent_GetProperties ( pcg-cpp ) if ( NOT pcg-cpp_POPULATED ) FetchContent_Populate ( pcg-cpp ) # Create header-only library with pcg-cpp include files add_library ( pcg-cpp INTERFACE ) target_include_directories ( pcg-cpp INTERFACE ${ pcg-cpp_SOURCE_DIR } /include ) endif () endif () add_executable ( pcg pcg.cpp ) target_link_libraries ( pcg pcg-cpp ) Initialize generator with two fixed seeds 1 pcg32 rng ( 42u , 54u ); Seed generator with external entropy 1 rng . seed ( pcg_extras :: seed_seq_from < std :: random_device > ()); Random numbers 1 std :: cout << \"Random number: \" << rng () << '\\n' ; Flip coins 1 std :: cout << \"Flip coin: \" << rng ( 2 ) << '\\n' ; Roll dice 1 std :: cout << \"Roll dice: \" << rng ( 6 ) << '\\n' ; Print generator state 1 2 3 std :: cout << \"Generator state: \" << rng << '\\n' ; std :: cout << \"Result size: \" << sizeof ( pcg32 :: result_type ) * 8 << \"bits\" << '\\n' ; std :: cout << \"Period: 2^\" << pcg32 :: period_pow2 () << '\\n' ; Use with C++ distributions 1 2 std :: uniform_real_distribution < double > distribution ( 1.0 , 10.0 ); std :: cout << distribution ( rng ) << '\\n' ; Share Snippets","title":"PCG"},{"location":"algorithms-data-structures/random/random/","text":"Random Random The random number library provides classes that generate random and pseudo-random numbers. These classes include: Uniform random bit generators (URBGs), which include both random number engines, which are pseudo-random number generators that generate integer sequences with a uniform distribution, and true random number generators if available; Random number distributions (e.g. uniform, normal, or poisson distributions) which convert the output of URBGs into various statistical distributions URBGs and distributions are designed to be used together to produce random values. All of the random number engines may be specifically seeded, serialized, and deserialized for use with repeatable simulators. Headers 1 #include <random> Operating system number generator 1 2 // Usually a high-cost generator std :: random_device rd ; Generate seed for a low-cost generator 1 unsigned int seed = rd (); Mix the seed with other sources of entropy 1 2 3 // We recur to a user-defined function to mix other sources // of entropy in the seed seed = mix_seed ( seed ); Use seed for a lower-cost number generator 1 2 // This is the generator we will ultimately use std :: default_random_engine g ( seed ); Create a number distribution (cheap) 1 std :: uniform_real_distribution < double > distribution ( 1.0 , 10.0 ); Using the generator with that distribution 1 std :: cout << distribution ( g ) << '\\n' ; Explicitly create a mt19937 generator 1 std :: mt19937 g2 { seed }; Creating a normal distribution (cheap) 1 std :: normal_distribution < double > d2 ( 0.0 , 1.0 ); Using the generator with that distribution 1 std :: cout << d2 ( g2 ) << '\\n' ; Generate a histogram from the generator 1 2 3 4 5 6 7 std :: vector < int > hist ( 10 , 0 ); for ( int i = 0 ; i < 300 ; ++ i ) { auto bin = d2 ( g2 ) + static_cast < double > ( hist . size ()) / 2 ; if ( bin >= 0. && static_cast < size_t > ( bin ) < hist . size ()) { ++ hist [ static_cast < size_t > ( bin )]; } } Print the histogram 1 2 3 4 5 6 7 for ( int n : hist ) { std :: cout << '-' ; for ( int j = 0 ; j < n ; ++ j ) { std :: cout << '*' ; } std :: cout << '\\n' ; } User-defined function to mix the seed 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 constexpr uint32_t fnv ( uint32_t hash , const char * pos ) { return * pos == '\\0' ? hash : fnv (( hash * 16777619U ) ^ * pos , pos + 1 ); } unsigned int mix_seed ( unsigned int seed ) { // Mix seed with some cross-platform entropy sources // - Mix the current time seed ^= static_cast < unsigned int > ( std :: chrono :: system_clock :: now (). time_since_epoch (). count ()); // - Mix an arbitrary compile-time stamp constexpr uint32_t compile_stamp = fnv ( 2166136261U , __DATE__ __TIME__ __FILE__ ); seed ^= static_cast < unsigned int > ( compile_stamp ); // - Mix an arbitrary heap address auto heap_addr = std :: make_unique < int > ( 0 ); seed ^= static_cast < unsigned int > ( reinterpret_cast < uintptr_t > ( heap_addr . get ())); // - Mix an arbitrary stack address seed ^= static_cast < unsigned int > ( reinterpret_cast < uintptr_t > ( & heap_addr )); // - Mix an arbitrary fixed number / counter seed ^= static_cast < unsigned int > ( 45 ); // - Mix an arbitrary function address (the clock function `now`) seed ^= static_cast < unsigned int > ( reinterpret_cast < uintptr_t > ( & std :: chrono :: system_clock :: now )); // - Mix the exit function address seed ^= static_cast < unsigned int > ( reinterpret_cast < uintptr_t > (( void * ) & _Exit )); // - Mix the random_device generator type hash code seed ^= static_cast < unsigned int > ( typeid ( std :: random_device ). hash_code ()); return seed ; } Share Snippets","title":"Random"},{"location":"algorithms-data-structures/random/random/#random","text":"Random The random number library provides classes that generate random and pseudo-random numbers. These classes include: Uniform random bit generators (URBGs), which include both random number engines, which are pseudo-random number generators that generate integer sequences with a uniform distribution, and true random number generators if available; Random number distributions (e.g. uniform, normal, or poisson distributions) which convert the output of URBGs into various statistical distributions URBGs and distributions are designed to be used together to produce random values. All of the random number engines may be specifically seeded, serialized, and deserialized for use with repeatable simulators. Headers 1 #include <random> Operating system number generator 1 2 // Usually a high-cost generator std :: random_device rd ; Generate seed for a low-cost generator 1 unsigned int seed = rd (); Mix the seed with other sources of entropy 1 2 3 // We recur to a user-defined function to mix other sources // of entropy in the seed seed = mix_seed ( seed ); Use seed for a lower-cost number generator 1 2 // This is the generator we will ultimately use std :: default_random_engine g ( seed ); Create a number distribution (cheap) 1 std :: uniform_real_distribution < double > distribution ( 1.0 , 10.0 ); Using the generator with that distribution 1 std :: cout << distribution ( g ) << '\\n' ; Explicitly create a mt19937 generator 1 std :: mt19937 g2 { seed }; Creating a normal distribution (cheap) 1 std :: normal_distribution < double > d2 ( 0.0 , 1.0 ); Using the generator with that distribution 1 std :: cout << d2 ( g2 ) << '\\n' ; Generate a histogram from the generator 1 2 3 4 5 6 7 std :: vector < int > hist ( 10 , 0 ); for ( int i = 0 ; i < 300 ; ++ i ) { auto bin = d2 ( g2 ) + static_cast < double > ( hist . size ()) / 2 ; if ( bin >= 0. && static_cast < size_t > ( bin ) < hist . size ()) { ++ hist [ static_cast < size_t > ( bin )]; } } Print the histogram 1 2 3 4 5 6 7 for ( int n : hist ) { std :: cout << '-' ; for ( int j = 0 ; j < n ; ++ j ) { std :: cout << '*' ; } std :: cout << '\\n' ; } User-defined function to mix the seed 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 constexpr uint32_t fnv ( uint32_t hash , const char * pos ) { return * pos == '\\0' ? hash : fnv (( hash * 16777619U ) ^ * pos , pos + 1 ); } unsigned int mix_seed ( unsigned int seed ) { // Mix seed with some cross-platform entropy sources // - Mix the current time seed ^= static_cast < unsigned int > ( std :: chrono :: system_clock :: now (). time_since_epoch (). count ()); // - Mix an arbitrary compile-time stamp constexpr uint32_t compile_stamp = fnv ( 2166136261U , __DATE__ __TIME__ __FILE__ ); seed ^= static_cast < unsigned int > ( compile_stamp ); // - Mix an arbitrary heap address auto heap_addr = std :: make_unique < int > ( 0 ); seed ^= static_cast < unsigned int > ( reinterpret_cast < uintptr_t > ( heap_addr . get ())); // - Mix an arbitrary stack address seed ^= static_cast < unsigned int > ( reinterpret_cast < uintptr_t > ( & heap_addr )); // - Mix an arbitrary fixed number / counter seed ^= static_cast < unsigned int > ( 45 ); // - Mix an arbitrary function address (the clock function `now`) seed ^= static_cast < unsigned int > ( reinterpret_cast < uintptr_t > ( & std :: chrono :: system_clock :: now )); // - Mix the exit function address seed ^= static_cast < unsigned int > ( reinterpret_cast < uintptr_t > (( void * ) & _Exit )); // - Mix the random_device generator type hash code seed ^= static_cast < unsigned int > ( typeid ( std :: random_device ). hash_code ()); return seed ; } Share Snippets","title":"Random"},{"location":"algorithms-data-structures/templates/concepts/","text":"Concepts Concepts Concepts (C++20) define named sets of template requirements. Class templates, function templates, and non-template functions (typically members of class templates) may be associated with a template constraint, which specifies the requirements on template arguments, which can be used to select the most appropriate function overloads and template specializations. Each concept is a predicate, evaluated at compile time, and becomes a part of the interface of a template where it is used as a constraint: Find concepts 1 2 add_executable ( concepts concepts.cpp ) target_compile_features ( concepts PRIVATE cxx_std_20 ) Headers 1 #include <concepts> Define concept from a compile-time boolean predicate 1 2 3 4 template < typename T > concept Number = std :: is_arithmetic_v < T > ; // is_arithmetic_v might be misleading since it also includes bool // is_arithmetic_v might be misleading since it doesn't include std::complex Define concept from a another concepts as a boolean predicate 1 template < typename T > concept NotNumber = ! Number < T > ; Define concept from a conjunction of constraints 1 template < typename T > concept SignedNumber = Number < T > && std :: is_signed_v < T > ; Define alternative mutually exclusive Number concept 1 2 template < typename T > concept UnsignedNumber = Number < T > && ! std :: is_signed_v < T > ; Define concept from disjunction of constraints 1 2 template < typename T1 , typename T2 > concept Equivalent = std :: is_convertible_v < T1 , T2 > || std :: is_same_v < T1 , T2 > ; Define concept from requires-expression 1 2 3 4 5 // These expressions must be something that will compile template < typename T > concept Range = requires ( T r ) { * r . begin (); * r . end (); }; Define concept from typename requirement 1 2 3 4 // These expressions must something that will compile template < typename T > concept HasValueType = requires ( T r ) { typename T :: value_type ; // required nested name }; Compound requirement 1 2 3 4 5 // Two requirements at the same time template < typename T > concept Pair = requires ( T p ) { { p . first }; { p . second }; }; Typename requirement from expression type constraint 1 2 3 4 5 6 // The expression should not only compile, but it should also have // a type that passes the concept after -> template < typename T > concept IntPair = requires ( T p ) { { p . first } -> std :: same_as < int > ; { p . second } -> std :: same_as < int > ; }; Requirement with two parameters 1 2 3 4 5 template < typename T > concept EqualityComparable = requires ( T a , T b ) { { a == b }; { a != b }; }; Nested requirements 1 2 3 4 5 // Additional constraint to existing constraints // Functions can use Range or RangeSameType now without ambiguity template < typename T > concept PairSameType = Pair < T > && requires ( T p ) { { p . first } -> std :: same_as < decltype ( p . second ) > ; }; Nested requirements without requires 1 2 template < typename T > concept RangeWithValueType = Range < T > && HasValueType < T > ; template < typename T > concept RangeWithoutValueType = Range < T > && ! HasValueType < T > ; Constrain function to numbers 1 2 3 4 5 6 7 8 9 // Number, but nor SignedNumber neither UnsignedNumber template < Number T > void max_value ( T a , T b ) { if ( a > b ) { std :: cout << \"max_value: \" << a << '\\n' ; } else { std :: cout << \"max_value: \" << b << '\\n' ; } } Constrain function to signed numbers 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // This function is used when Number is SignedNumber template < SignedNumber T > void max_value ( T a , T b ) { if ( a > b ) { if ( a > 0 ) { std :: cout << \"max_value: positive \" << a << '\\n' ; } else { std :: cout << \"max_value: negative \" << - a << '\\n' ; } } else { if ( b > 0 ) { std :: cout << \"max_value: positive \" << b << '\\n' ; } else { std :: cout << \"max_value: negative \" << - b << '\\n' ; } } } Constrain function to unsigned numbers 1 2 3 4 5 6 7 8 9 // This function is used when Number is UnsignedNumber template < UnsignedNumber T > void max_value ( T a , T b ) { if ( a > b ) { std :: cout << \"max_value: +\" << a << '\\n' ; } else { std :: cout << \"max_value: +\" << b << '\\n' ; } } Constrain function to non-numbers 1 2 3 4 5 6 // NotNumber == !Number<T> template < NotNumber T > void max_value ( T a , T b ) { std :: cout << \"a: \" << a << '\\n' ; std :: cout << \"b: \" << b << '\\n' ; } Unconstrained function 1 2 3 4 template < class T > void print_element ( const T & c ) { std :: cout << c << '\\n' ; } Constrain function to Ranges 1 2 3 4 5 6 7 8 // - The most constrained concept is always used template < Range T > void print_element ( const T & c ) { for ( const auto & item : c ) { std :: cout << item << ' ' ; } std :: cout << '\\n' ; } Constrain function to ranges with value type member 1 2 3 4 5 6 7 8 9 // The most constrained concept is used in nested constraints template < RangeWithValueType T > void print_element ( const T & c ) { std :: cout << typeid ( typename T :: value_type ). name () << \": \" ; for ( const auto & item : c ) { std :: cout << item << ' ' ; } std :: cout << '\\n' ; } Constrain with require-clause directly in function declaration 1 2 3 4 5 6 7 8 9 template < typename T > requires EqualityComparable < T > void compare ( const T & a , const T & b ) { if ( a == b ) { std :: cout << a << \" == \" << b << \" is \" << ( a == b ? \"true\" : \"false\" ) << '\\n' ; } else { std :: cout << a << \" != \" << b << \" is \" << ( a != b ? \"true\" : \"false\" ) << '\\n' ; } } Unconstrained function 1 2 3 4 template < typename T > void compare ( const T & a , const T & b ) { std :: cout << typeid ( T ). name () << \": \" << a . c << \" == \" << b . c << \"?\" << '\\n' ; } Constrain function to pairs 1 2 3 4 5 template < Pair T > void print_pair ( const T & p ) { std :: cout << typeid ( p . first ). name () << \": \" << p . first << \", \" << typeid ( p . second ). name () << \": \" << p . second << '\\n' ; } Constrain function to pairs of same type 1 2 3 4 template < PairSameType T > void print_pair ( const T & p ) { std :: cout << typeid ( p . first ). name () << \": \" << p . first << \", \" << p . second << '\\n' ; } Share Snippets","title":"Concepts"},{"location":"algorithms-data-structures/templates/concepts/#concepts","text":"Concepts Concepts (C++20) define named sets of template requirements. Class templates, function templates, and non-template functions (typically members of class templates) may be associated with a template constraint, which specifies the requirements on template arguments, which can be used to select the most appropriate function overloads and template specializations. Each concept is a predicate, evaluated at compile time, and becomes a part of the interface of a template where it is used as a constraint: Find concepts 1 2 add_executable ( concepts concepts.cpp ) target_compile_features ( concepts PRIVATE cxx_std_20 ) Headers 1 #include <concepts> Define concept from a compile-time boolean predicate 1 2 3 4 template < typename T > concept Number = std :: is_arithmetic_v < T > ; // is_arithmetic_v might be misleading since it also includes bool // is_arithmetic_v might be misleading since it doesn't include std::complex Define concept from a another concepts as a boolean predicate 1 template < typename T > concept NotNumber = ! Number < T > ; Define concept from a conjunction of constraints 1 template < typename T > concept SignedNumber = Number < T > && std :: is_signed_v < T > ; Define alternative mutually exclusive Number concept 1 2 template < typename T > concept UnsignedNumber = Number < T > && ! std :: is_signed_v < T > ; Define concept from disjunction of constraints 1 2 template < typename T1 , typename T2 > concept Equivalent = std :: is_convertible_v < T1 , T2 > || std :: is_same_v < T1 , T2 > ; Define concept from requires-expression 1 2 3 4 5 // These expressions must be something that will compile template < typename T > concept Range = requires ( T r ) { * r . begin (); * r . end (); }; Define concept from typename requirement 1 2 3 4 // These expressions must something that will compile template < typename T > concept HasValueType = requires ( T r ) { typename T :: value_type ; // required nested name }; Compound requirement 1 2 3 4 5 // Two requirements at the same time template < typename T > concept Pair = requires ( T p ) { { p . first }; { p . second }; }; Typename requirement from expression type constraint 1 2 3 4 5 6 // The expression should not only compile, but it should also have // a type that passes the concept after -> template < typename T > concept IntPair = requires ( T p ) { { p . first } -> std :: same_as < int > ; { p . second } -> std :: same_as < int > ; }; Requirement with two parameters 1 2 3 4 5 template < typename T > concept EqualityComparable = requires ( T a , T b ) { { a == b }; { a != b }; }; Nested requirements 1 2 3 4 5 // Additional constraint to existing constraints // Functions can use Range or RangeSameType now without ambiguity template < typename T > concept PairSameType = Pair < T > && requires ( T p ) { { p . first } -> std :: same_as < decltype ( p . second ) > ; }; Nested requirements without requires 1 2 template < typename T > concept RangeWithValueType = Range < T > && HasValueType < T > ; template < typename T > concept RangeWithoutValueType = Range < T > && ! HasValueType < T > ; Constrain function to numbers 1 2 3 4 5 6 7 8 9 // Number, but nor SignedNumber neither UnsignedNumber template < Number T > void max_value ( T a , T b ) { if ( a > b ) { std :: cout << \"max_value: \" << a << '\\n' ; } else { std :: cout << \"max_value: \" << b << '\\n' ; } } Constrain function to signed numbers 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // This function is used when Number is SignedNumber template < SignedNumber T > void max_value ( T a , T b ) { if ( a > b ) { if ( a > 0 ) { std :: cout << \"max_value: positive \" << a << '\\n' ; } else { std :: cout << \"max_value: negative \" << - a << '\\n' ; } } else { if ( b > 0 ) { std :: cout << \"max_value: positive \" << b << '\\n' ; } else { std :: cout << \"max_value: negative \" << - b << '\\n' ; } } } Constrain function to unsigned numbers 1 2 3 4 5 6 7 8 9 // This function is used when Number is UnsignedNumber template < UnsignedNumber T > void max_value ( T a , T b ) { if ( a > b ) { std :: cout << \"max_value: +\" << a << '\\n' ; } else { std :: cout << \"max_value: +\" << b << '\\n' ; } } Constrain function to non-numbers 1 2 3 4 5 6 // NotNumber == !Number<T> template < NotNumber T > void max_value ( T a , T b ) { std :: cout << \"a: \" << a << '\\n' ; std :: cout << \"b: \" << b << '\\n' ; } Unconstrained function 1 2 3 4 template < class T > void print_element ( const T & c ) { std :: cout << c << '\\n' ; } Constrain function to Ranges 1 2 3 4 5 6 7 8 // - The most constrained concept is always used template < Range T > void print_element ( const T & c ) { for ( const auto & item : c ) { std :: cout << item << ' ' ; } std :: cout << '\\n' ; } Constrain function to ranges with value type member 1 2 3 4 5 6 7 8 9 // The most constrained concept is used in nested constraints template < RangeWithValueType T > void print_element ( const T & c ) { std :: cout << typeid ( typename T :: value_type ). name () << \": \" ; for ( const auto & item : c ) { std :: cout << item << ' ' ; } std :: cout << '\\n' ; } Constrain with require-clause directly in function declaration 1 2 3 4 5 6 7 8 9 template < typename T > requires EqualityComparable < T > void compare ( const T & a , const T & b ) { if ( a == b ) { std :: cout << a << \" == \" << b << \" is \" << ( a == b ? \"true\" : \"false\" ) << '\\n' ; } else { std :: cout << a << \" != \" << b << \" is \" << ( a != b ? \"true\" : \"false\" ) << '\\n' ; } } Unconstrained function 1 2 3 4 template < typename T > void compare ( const T & a , const T & b ) { std :: cout << typeid ( T ). name () << \": \" << a . c << \" == \" << b . c << \"?\" << '\\n' ; } Constrain function to pairs 1 2 3 4 5 template < Pair T > void print_pair ( const T & p ) { std :: cout << typeid ( p . first ). name () << \": \" << p . first << \", \" << typeid ( p . second ). name () << \": \" << p . second << '\\n' ; } Constrain function to pairs of same type 1 2 3 4 template < PairSameType T > void print_pair ( const T & p ) { std :: cout << typeid ( p . first ). name () << \": \" << p . first << \", \" << p . second << '\\n' ; } Share Snippets","title":"Concepts"},{"location":"algorithms-data-structures/templates/metaprogramming/","text":"Metaprogramming Metaprogramming Template metaprogramming is a family of techniques to create new types and compute values at compile time. C++ templates are Turing complete if there are no limits to the amount of recursive instantiations and the number of allowed state variables. Erwin Unruh was the first to demonstrate template metaprogramming at a committee meeting by instructing the compiler to print out prime numbers in error messages. The standard recommends an implementation support at least 1024 levels of recursive instantiation, and infinite recursion in template instantiations is undefined behavior. Factorial value computed as constant class value 1 2 3 4 5 6 7 template < unsigned n > struct factorial { enum { value = n * factorial < n - 1 >:: value }; }; template <> struct factorial < 0 > { enum { value = 1 }; }; Accessing factorial value calculated at compile-time 1 std :: cout << \"factorial<7>::value : \" << factorial < 7 >:: value << '\\n' ; Computing at compile time with constexpr 1 constexpr int factorial2 ( int n ) { return n <= 1 ? 1 : ( n * factorial2 ( n - 1 )); } Accessing factorial value calculated at compile-time 1 std :: cout << \"factorial<7>::value : \" << factorial < 7 >:: value << '\\n' ; Count number of elements 1 2 3 4 5 6 7 struct MyClass { template < typename ... Tail > static int count () { return 0 ; } template < char Head , char ... Tail > static int count () { return 1 + count < Tail ... > (); } }; Access number of elements 1 2 std :: cout << \"MyClass::count<'f','o','o'>(): \" << MyClass :: count < 'f' , 'o' , 'o' > () << '\\n' ; // 3 Share Snippets","title":"Metaprogramming"},{"location":"algorithms-data-structures/templates/metaprogramming/#metaprogramming","text":"Metaprogramming Template metaprogramming is a family of techniques to create new types and compute values at compile time. C++ templates are Turing complete if there are no limits to the amount of recursive instantiations and the number of allowed state variables. Erwin Unruh was the first to demonstrate template metaprogramming at a committee meeting by instructing the compiler to print out prime numbers in error messages. The standard recommends an implementation support at least 1024 levels of recursive instantiation, and infinite recursion in template instantiations is undefined behavior. Factorial value computed as constant class value 1 2 3 4 5 6 7 template < unsigned n > struct factorial { enum { value = n * factorial < n - 1 >:: value }; }; template <> struct factorial < 0 > { enum { value = 1 }; }; Accessing factorial value calculated at compile-time 1 std :: cout << \"factorial<7>::value : \" << factorial < 7 >:: value << '\\n' ; Computing at compile time with constexpr 1 constexpr int factorial2 ( int n ) { return n <= 1 ? 1 : ( n * factorial2 ( n - 1 )); } Accessing factorial value calculated at compile-time 1 std :: cout << \"factorial<7>::value : \" << factorial < 7 >:: value << '\\n' ; Count number of elements 1 2 3 4 5 6 7 struct MyClass { template < typename ... Tail > static int count () { return 0 ; } template < char Head , char ... Tail > static int count () { return 1 + count < Tail ... > (); } }; Access number of elements 1 2 std :: cout << \"MyClass::count<'f','o','o'>(): \" << MyClass :: count < 'f' , 'o' , 'o' > () << '\\n' ; // 3 Share Snippets","title":"Metaprogramming"},{"location":"algorithms-data-structures/templates/sfinae/","text":"Substitution Failure Is Not An Error Substitution Failure Is Not An Error This rule applies during overload resolution of function templates: When substituting the explicitly specified or deduced type for the template parameter fails, the specialization is discarded from the overload set instead of causing a compile error. Because the attempted substitution is not an error, SFINAE is used as alternative to concepts in compilers that do not support C++20. The technique specifies the template parameters is such a way that only the intended template types are instanciated. Headers 1 #include <type_traits> Constrain parameter type to arithmetic types 1 2 3 4 5 6 7 8 9 // The overload fails if the first parameter is not arithmetic template < class T > void max ( std :: enable_if_t < std :: is_arithmetic_v < T > , T > a , T b ) { if ( a > b ) { std :: cout << \"max: \" << a << '\\n' ; } else { std :: cout << \"max: \" << b << '\\n' ; } } Constrain parameter type to not arithmetic 1 2 3 4 5 6 // The overload fails if the first parameter is arithmetic template < class T > void max ( std :: enable_if_t <! std :: is_arithmetic_v < T > , T > a , T b ) { std :: cout << \"a: \" << a << '\\n' ; std :: cout << \"b: \" << b << '\\n' ; } SFINAE: Substitution Failure is Not An Error 1 2 max ( 5 , 7 ); // call overload for arithmetic types max ( \"foo\" , \"bar\" ); // call overload for non-arithmetic types Constrain on the return type 1 2 3 4 // The return type (bool) is only valid if T is an integral type: template < class T > std :: enable_if_t < std :: is_integral_v < T > , bool > is_odd ( T i ) { return bool ( i % 2 ); } Constrain on the parameter list 1 2 3 4 5 // The second template argument is only valid if T is an integral type template < class T , class = std :: enable_if_t < std :: is_integral_v < T >>> bool is_even ( T i ) { return ! bool ( i % 2 ); } SFINAE on functions 1 2 3 std :: cout << \"i is odd: \" << is_odd ( 1 ) << '\\n' ; // is_odd(1.2) wouldn't work std :: cout << \"i is even: \" << is_even ( 1 ) << '\\n' ; // is_even(1.2) wouldn't work Floating point traits 1 2 3 4 std :: cout << \"int: \" << std :: is_floating_point < int >:: value << '\\n' ; std :: cout << \"float: \" << std :: is_floating_point < float >:: value << '\\n' ; std :: cout << \"const double: \" << std :: is_floating_point < const double >:: value << '\\n' ; Array traits 1 2 3 4 5 6 std :: cout << \"int: \" << std :: is_array < int >:: value << '\\n' ; std :: cout << \"int[3]: \" << std :: is_array < int [ 3 ] >:: value << '\\n' ; std :: cout << \"array<int,3>: \" << std :: is_array < std :: array < int , 3 >>:: value << '\\n' ; std :: cout << \"string: \" << std :: is_array < std :: string >:: value << '\\n' ; std :: cout << \"string[3]: \" << std :: is_array < std :: string [ 3 ] >:: value << '\\n' ; Class traits 1 2 3 4 5 6 7 std :: cout << \"A: \" << std :: is_class < A >:: value << '\\n' ; std :: cout << \"B: \" << std :: is_class < B >:: value << '\\n' ; std :: cout << \"C: \" << std :: is_class < C >:: value << '\\n' ; std :: cout << \"D: \" << std :: is_class < D >:: value << '\\n' ; std :: cout << \"A: \" << std :: is_enum < A >:: value << '\\n' ; std :: cout << \"B: \" << std :: is_enum < B >:: value << '\\n' ; std :: cout << \"C: \" << std :: is_enum < C >:: value << '\\n' ; Function traits 1 2 3 4 5 std :: cout << \"is_odd: \" << std :: is_function < decltype ( is_odd < int > ) >:: value << '\\n' ; std :: cout << \"id_even: \" << std :: is_function < decltype ( is_even < int > ) >:: value << '\\n' ; std :: cout << \"decltype(c): \" << std :: is_function < C >:: value << '\\n' ; Integral traits 1 2 3 std :: cout << \"char: \" << std :: is_integral < char >:: value << '\\n' ; std :: cout << \"int: \" << std :: is_integral < int >:: value << '\\n' ; std :: cout << \"float: \" << std :: is_integral < float >:: value << '\\n' ; Pointer traits 1 2 3 4 5 std :: cout << \"int: \" << std :: is_pointer < int >:: value << '\\n' ; std :: cout << \"int*: \" << std :: is_pointer < int *>:: value << '\\n' ; std :: cout << \"int**: \" << std :: is_pointer < int **>:: value << '\\n' ; std :: cout << \"int(*)(int): \" << std :: is_pointer < int ( * )( int ) >:: value << '\\n' ; Scalar traits 1 2 3 4 5 6 7 8 9 std :: cout << \"int: \" << std :: is_scalar < int >:: value << '\\n' ; std :: cout << \"A: \" << std :: is_scalar < A >:: value << '\\n' ; std :: cout << \"A&: \" << std :: is_scalar < A &>:: value << '\\n' ; std :: cout << \"A*: \" << std :: is_scalar < A *>:: value << '\\n' ; std :: cout << \"int(int): \" << std :: is_scalar < int ( int ) >:: value << '\\n' ; std :: cout << \"int(*)(int): \" << std :: is_scalar < int ( * )( int ) >:: value << '\\n' ; std :: cout << \"char: \" << std :: is_arithmetic < char >:: value << '\\n' ; std :: cout << \"float: \" << std :: is_arithmetic < float >:: value << '\\n' ; std :: cout << \"float*: \" << std :: is_arithmetic < float *>:: value << '\\n' ; Share Snippets","title":"SFINAE"},{"location":"algorithms-data-structures/templates/sfinae/#substitution-failure-is-not-an-error","text":"Substitution Failure Is Not An Error This rule applies during overload resolution of function templates: When substituting the explicitly specified or deduced type for the template parameter fails, the specialization is discarded from the overload set instead of causing a compile error. Because the attempted substitution is not an error, SFINAE is used as alternative to concepts in compilers that do not support C++20. The technique specifies the template parameters is such a way that only the intended template types are instanciated. Headers 1 #include <type_traits> Constrain parameter type to arithmetic types 1 2 3 4 5 6 7 8 9 // The overload fails if the first parameter is not arithmetic template < class T > void max ( std :: enable_if_t < std :: is_arithmetic_v < T > , T > a , T b ) { if ( a > b ) { std :: cout << \"max: \" << a << '\\n' ; } else { std :: cout << \"max: \" << b << '\\n' ; } } Constrain parameter type to not arithmetic 1 2 3 4 5 6 // The overload fails if the first parameter is arithmetic template < class T > void max ( std :: enable_if_t <! std :: is_arithmetic_v < T > , T > a , T b ) { std :: cout << \"a: \" << a << '\\n' ; std :: cout << \"b: \" << b << '\\n' ; } SFINAE: Substitution Failure is Not An Error 1 2 max ( 5 , 7 ); // call overload for arithmetic types max ( \"foo\" , \"bar\" ); // call overload for non-arithmetic types Constrain on the return type 1 2 3 4 // The return type (bool) is only valid if T is an integral type: template < class T > std :: enable_if_t < std :: is_integral_v < T > , bool > is_odd ( T i ) { return bool ( i % 2 ); } Constrain on the parameter list 1 2 3 4 5 // The second template argument is only valid if T is an integral type template < class T , class = std :: enable_if_t < std :: is_integral_v < T >>> bool is_even ( T i ) { return ! bool ( i % 2 ); } SFINAE on functions 1 2 3 std :: cout << \"i is odd: \" << is_odd ( 1 ) << '\\n' ; // is_odd(1.2) wouldn't work std :: cout << \"i is even: \" << is_even ( 1 ) << '\\n' ; // is_even(1.2) wouldn't work Floating point traits 1 2 3 4 std :: cout << \"int: \" << std :: is_floating_point < int >:: value << '\\n' ; std :: cout << \"float: \" << std :: is_floating_point < float >:: value << '\\n' ; std :: cout << \"const double: \" << std :: is_floating_point < const double >:: value << '\\n' ; Array traits 1 2 3 4 5 6 std :: cout << \"int: \" << std :: is_array < int >:: value << '\\n' ; std :: cout << \"int[3]: \" << std :: is_array < int [ 3 ] >:: value << '\\n' ; std :: cout << \"array<int,3>: \" << std :: is_array < std :: array < int , 3 >>:: value << '\\n' ; std :: cout << \"string: \" << std :: is_array < std :: string >:: value << '\\n' ; std :: cout << \"string[3]: \" << std :: is_array < std :: string [ 3 ] >:: value << '\\n' ; Class traits 1 2 3 4 5 6 7 std :: cout << \"A: \" << std :: is_class < A >:: value << '\\n' ; std :: cout << \"B: \" << std :: is_class < B >:: value << '\\n' ; std :: cout << \"C: \" << std :: is_class < C >:: value << '\\n' ; std :: cout << \"D: \" << std :: is_class < D >:: value << '\\n' ; std :: cout << \"A: \" << std :: is_enum < A >:: value << '\\n' ; std :: cout << \"B: \" << std :: is_enum < B >:: value << '\\n' ; std :: cout << \"C: \" << std :: is_enum < C >:: value << '\\n' ; Function traits 1 2 3 4 5 std :: cout << \"is_odd: \" << std :: is_function < decltype ( is_odd < int > ) >:: value << '\\n' ; std :: cout << \"id_even: \" << std :: is_function < decltype ( is_even < int > ) >:: value << '\\n' ; std :: cout << \"decltype(c): \" << std :: is_function < C >:: value << '\\n' ; Integral traits 1 2 3 std :: cout << \"char: \" << std :: is_integral < char >:: value << '\\n' ; std :: cout << \"int: \" << std :: is_integral < int >:: value << '\\n' ; std :: cout << \"float: \" << std :: is_integral < float >:: value << '\\n' ; Pointer traits 1 2 3 4 5 std :: cout << \"int: \" << std :: is_pointer < int >:: value << '\\n' ; std :: cout << \"int*: \" << std :: is_pointer < int *>:: value << '\\n' ; std :: cout << \"int**: \" << std :: is_pointer < int **>:: value << '\\n' ; std :: cout << \"int(*)(int): \" << std :: is_pointer < int ( * )( int ) >:: value << '\\n' ; Scalar traits 1 2 3 4 5 6 7 8 9 std :: cout << \"int: \" << std :: is_scalar < int >:: value << '\\n' ; std :: cout << \"A: \" << std :: is_scalar < A >:: value << '\\n' ; std :: cout << \"A&: \" << std :: is_scalar < A &>:: value << '\\n' ; std :: cout << \"A*: \" << std :: is_scalar < A *>:: value << '\\n' ; std :: cout << \"int(int): \" << std :: is_scalar < int ( int ) >:: value << '\\n' ; std :: cout << \"int(*)(int): \" << std :: is_scalar < int ( * )( int ) >:: value << '\\n' ; std :: cout << \"char: \" << std :: is_arithmetic < char >:: value << '\\n' ; std :: cout << \"float: \" << std :: is_arithmetic < float >:: value << '\\n' ; std :: cout << \"float*: \" << std :: is_arithmetic < float *>:: value << '\\n' ; Share Snippets","title":"Substitution Failure Is Not An Error"},{"location":"algorithms-data-structures/templates/template-aliases/","text":"Template Aliases Template Aliases A type alias is a name that refers to a previously defined type. Alias template is a name that refers to a family of types. Template alias for two-dimensional arrays 1 2 template < class T , size_t N_ROWS , size_t N_COLUMNS > using matrix = std :: array < std :: array < T , N_COLUMNS > , N_ROWS > ; Using a template alias 1 2 3 4 5 6 7 matrix < double , 10 , 3 > m ; double i = 5.6 ; for ( auto & row : m ) { for ( auto & xij : row ) { xij = i ++ ; } } Iterating the matrix 1 2 3 4 5 for ( auto & row : m ) { for ( auto & xij : row ) { std :: cout << \"xij: \" << xij << '\\n' ; } } Share Snippets","title":"Template Aliases"},{"location":"algorithms-data-structures/templates/template-aliases/#template-aliases","text":"Template Aliases A type alias is a name that refers to a previously defined type. Alias template is a name that refers to a family of types. Template alias for two-dimensional arrays 1 2 template < class T , size_t N_ROWS , size_t N_COLUMNS > using matrix = std :: array < std :: array < T , N_COLUMNS > , N_ROWS > ; Using a template alias 1 2 3 4 5 6 7 matrix < double , 10 , 3 > m ; double i = 5.6 ; for ( auto & row : m ) { for ( auto & xij : row ) { xij = i ++ ; } } Iterating the matrix 1 2 3 4 5 for ( auto & row : m ) { for ( auto & xij : row ) { std :: cout << \"xij: \" << xij << '\\n' ; } } Share Snippets","title":"Template Aliases"},{"location":"algorithms-data-structures/templates/template-parameters/","text":"Template Parameters Template Parameters A template defines a family of functions and classes. A template by itself is not a type, or a function, or any other entity. No code is generated from a source file that contains only template definitions. In order for any code to appear, a template must be instantiated: the template arguments must be determined so that the compiler can generate an actual function (or class, from a class template). Templates allow us to reuse the logic of algorithms for different data types. Without templates, our alternative for generic algorithms would be type erasing types. Function with int parameters 1 int max ( int n1 , int n2 ) { return ( n1 > n2 ) ? n1 : n2 ; } Function for any type T 1 template < class T > T max ( T n1 , T n2 ) { return ( n1 > n2 ) ? n1 : n2 ; } Function for any types T1 and T2 1 2 3 template < class T1 , class T2 > T2 max ( T1 n1 , T2 n2 ) { return ( n1 > n2 ) ? n1 : n2 ; } Calling template function for any data type 1 2 3 std :: cout << \"max: \" << max ( 3 , 9 ) << '\\n' ; std :: cout << \"max: \" << max ( 3.5 , 9.3 ) << '\\n' ; std :: cout << \"max: \" << max ( 3 , 9.3 ) << '\\n' ; Type erased max function 1 2 3 4 5 6 // The \"old\" way: max operating on nullified pointers void * max ( void * n1 , void * n2 , bool ( * comp )( void * , void * )) { // `comp` is responsible to internally convert `void*` to the appropriate // data type and perform the comparison. return ( comp ( n1 , n2 )) ? n1 : n2 ; } Type erased comparison function 1 2 // The \"old\" way: an extra function operating on the nullified pointers bool comp ( void * a , void * b ) { return ( * ( int * ) a < * ( int * ) b ); } Calling function with type erased parameters 1 2 3 4 5 6 // In old C++ and C, we need nullify pointers to create generic functions. // It's easy to see why this is inconvenient. int a = 3 ; int b = 9 ; void * m = max ( & a , & b , & comp ); std :: cout << \"m: \" << * ( int * ) m << '\\n' ; Template class 1 2 3 4 template < class T1 , class T2 > struct pair { T1 first ; T2 second ; }; Instances of templated objects 1 2 3 pair < int , double > p { 3 , 3.3 }; std :: cout << \"p.first: \" << p . first << '\\n' ; std :: cout << \"p.second: \" << p . second << '\\n' ; Share Snippets","title":"Template Parameters"},{"location":"algorithms-data-structures/templates/template-parameters/#template-parameters","text":"Template Parameters A template defines a family of functions and classes. A template by itself is not a type, or a function, or any other entity. No code is generated from a source file that contains only template definitions. In order for any code to appear, a template must be instantiated: the template arguments must be determined so that the compiler can generate an actual function (or class, from a class template). Templates allow us to reuse the logic of algorithms for different data types. Without templates, our alternative for generic algorithms would be type erasing types. Function with int parameters 1 int max ( int n1 , int n2 ) { return ( n1 > n2 ) ? n1 : n2 ; } Function for any type T 1 template < class T > T max ( T n1 , T n2 ) { return ( n1 > n2 ) ? n1 : n2 ; } Function for any types T1 and T2 1 2 3 template < class T1 , class T2 > T2 max ( T1 n1 , T2 n2 ) { return ( n1 > n2 ) ? n1 : n2 ; } Calling template function for any data type 1 2 3 std :: cout << \"max: \" << max ( 3 , 9 ) << '\\n' ; std :: cout << \"max: \" << max ( 3.5 , 9.3 ) << '\\n' ; std :: cout << \"max: \" << max ( 3 , 9.3 ) << '\\n' ; Type erased max function 1 2 3 4 5 6 // The \"old\" way: max operating on nullified pointers void * max ( void * n1 , void * n2 , bool ( * comp )( void * , void * )) { // `comp` is responsible to internally convert `void*` to the appropriate // data type and perform the comparison. return ( comp ( n1 , n2 )) ? n1 : n2 ; } Type erased comparison function 1 2 // The \"old\" way: an extra function operating on the nullified pointers bool comp ( void * a , void * b ) { return ( * ( int * ) a < * ( int * ) b ); } Calling function with type erased parameters 1 2 3 4 5 6 // In old C++ and C, we need nullify pointers to create generic functions. // It's easy to see why this is inconvenient. int a = 3 ; int b = 9 ; void * m = max ( & a , & b , & comp ); std :: cout << \"m: \" << * ( int * ) m << '\\n' ; Template class 1 2 3 4 template < class T1 , class T2 > struct pair { T1 first ; T2 second ; }; Instances of templated objects 1 2 3 pair < int , double > p { 3 , 3.3 }; std :: cout << \"p.first: \" << p . first << '\\n' ; std :: cout << \"p.second: \" << p . second << '\\n' ; Share Snippets","title":"Template Parameters"},{"location":"basic-syntax/basic-data-types/aggregate-initialization/","text":"Aggregate initialization Aggregate initialization Aggregate initialization initializes aggregate types. CMakeLists.txt 1 2 add_executable ( aggregate_initialization aggregate_initialization.cpp ) target_compile_features ( aggregate_initialization PRIVATE cxx_std_20 ) An aggregate type 1 2 3 4 5 struct A { int x ; int y ; int z ; }; Initialize type with designated initializers 1 A a {. x = 1 , . y = 4 , . z = 2 }; List initialization 1 A c { 1 , 2 , 3 }; Nested type 1 2 3 4 5 struct B { int x ; A y ; int z ; }; Nested initialization 1 B d {. x = 1 , . y = { 2 , 6 , 5 }, . z = 3 }; Share Snippets","title":"Aggregate initialization"},{"location":"basic-syntax/basic-data-types/aggregate-initialization/#aggregate-initialization","text":"Aggregate initialization Aggregate initialization initializes aggregate types. CMakeLists.txt 1 2 add_executable ( aggregate_initialization aggregate_initialization.cpp ) target_compile_features ( aggregate_initialization PRIVATE cxx_std_20 ) An aggregate type 1 2 3 4 5 struct A { int x ; int y ; int z ; }; Initialize type with designated initializers 1 A a {. x = 1 , . y = 4 , . z = 2 }; List initialization 1 A c { 1 , 2 , 3 }; Nested type 1 2 3 4 5 struct B { int x ; A y ; int z ; }; Nested initialization 1 B d {. x = 1 , . y = { 2 , 6 , 5 }, . z = 3 }; Share Snippets","title":"Aggregate initialization"},{"location":"basic-syntax/basic-data-types/arrays/","text":"Arrays Arrays In modern C++, std::array is a safe container that encapsulates fixed size arrays. Headers 1 #include <array> Fixed size array 1 2 constexpr int n = 3 ; std :: array < int , n > a = { 1 , 2 , 3 }; Iterate arrays 1 2 3 for ( size_t i = 0 ; i < a . size (); ++ i ) { std :: cout << \"a[\" << i << \"]: \" << a [ i ] << '\\n' ; } Member functions 1 2 3 4 std :: cout << \"a.size(): \" << a . size () << '\\n' ; std :: cout << \"a.empty(): \" << a . empty () << '\\n' ; std :: cout << \"a.front(): \" << a . front () << '\\n' ; std :: cout << \"a.back(): \" << a . back () << '\\n' ; Accessing elements 1 2 3 std :: cout << \"a[0]: \" << a [ 0 ] << '\\n' ; std :: cout << \"a[1]: \" << a [ 1 ] << '\\n' ; std :: cout << \"a[2]: \" << a [ 2 ] << '\\n' ; Accessing elements 1 2 3 std :: cout << \"a[0]: \" << a [ 0 ] << '\\n' ; std :: cout << \"a[1]: \" << a [ 1 ] << '\\n' ; std :: cout << \"a[2]: \" << a [ 2 ] << '\\n' ; Underlying raw array 1 2 3 // We might still need the underlying raw array // to interact with old code std :: cout << \"Underlying raw array - a.data(): \" << a . data () << '\\n' ; Array size 1 2 // array<T,N> has a fixed size in bytes std :: cout << \"sizeof(a): \" << sizeof ( a ) << '\\n' ; Multidimensional array 1 2 3 4 5 6 std :: array < std :: array < double , 3 > , 10 > matrix ; for ( size_t i = 0 ; i < matrix . size (); ++ i ) { for ( size_t j = 0 ; j < matrix [ i ]. size (); ++ j ) { matrix [ i ][ j ] = 0.5 * i + 0.8 * j ; } } Range-based loop 1 2 3 4 5 6 7 for ( const auto & row : matrix ) { double sum = 0. ; for ( const auto & col : row ) { sum += col ; } std :: cout << \"Row average \" << sum / row . size () << '\\n' ; } Share Snippets","title":"Arrays"},{"location":"basic-syntax/basic-data-types/arrays/#arrays","text":"Arrays In modern C++, std::array is a safe container that encapsulates fixed size arrays. Headers 1 #include <array> Fixed size array 1 2 constexpr int n = 3 ; std :: array < int , n > a = { 1 , 2 , 3 }; Iterate arrays 1 2 3 for ( size_t i = 0 ; i < a . size (); ++ i ) { std :: cout << \"a[\" << i << \"]: \" << a [ i ] << '\\n' ; } Member functions 1 2 3 4 std :: cout << \"a.size(): \" << a . size () << '\\n' ; std :: cout << \"a.empty(): \" << a . empty () << '\\n' ; std :: cout << \"a.front(): \" << a . front () << '\\n' ; std :: cout << \"a.back(): \" << a . back () << '\\n' ; Accessing elements 1 2 3 std :: cout << \"a[0]: \" << a [ 0 ] << '\\n' ; std :: cout << \"a[1]: \" << a [ 1 ] << '\\n' ; std :: cout << \"a[2]: \" << a [ 2 ] << '\\n' ; Accessing elements 1 2 3 std :: cout << \"a[0]: \" << a [ 0 ] << '\\n' ; std :: cout << \"a[1]: \" << a [ 1 ] << '\\n' ; std :: cout << \"a[2]: \" << a [ 2 ] << '\\n' ; Underlying raw array 1 2 3 // We might still need the underlying raw array // to interact with old code std :: cout << \"Underlying raw array - a.data(): \" << a . data () << '\\n' ; Array size 1 2 // array<T,N> has a fixed size in bytes std :: cout << \"sizeof(a): \" << sizeof ( a ) << '\\n' ; Multidimensional array 1 2 3 4 5 6 std :: array < std :: array < double , 3 > , 10 > matrix ; for ( size_t i = 0 ; i < matrix . size (); ++ i ) { for ( size_t j = 0 ; j < matrix [ i ]. size (); ++ j ) { matrix [ i ][ j ] = 0.5 * i + 0.8 * j ; } } Range-based loop 1 2 3 4 5 6 7 for ( const auto & row : matrix ) { double sum = 0. ; for ( const auto & col : row ) { sum += col ; } std :: cout << \"Row average \" << sum / row . size () << '\\n' ; } Share Snippets","title":"Arrays"},{"location":"basic-syntax/basic-data-types/build-script/","text":"Build script 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 add_executable ( raw_arrays raw_arrays.cpp ) add_executable ( arrays arrays.cpp ) add_executable ( vectors vectors.cpp ) add_executable ( strings strings.cpp ) add_executable ( move move.cpp ) add_executable ( struct struct.cpp ) #[aggregate_initialization CMakeLists.txt add_executable ( aggregate_initialization aggregate_initialization.cpp ) target_compile_features ( aggregate_initialization PRIVATE cxx_std_20 ) #] #[structured_binding CMakeLists.txt add_executable ( structured_binding structured_binding.cpp ) target_compile_features ( structured_binding PRIVATE cxx_std_17 ) #]","title":"Build script"},{"location":"basic-syntax/basic-data-types/build-script/#build-script","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 add_executable ( raw_arrays raw_arrays.cpp ) add_executable ( arrays arrays.cpp ) add_executable ( vectors vectors.cpp ) add_executable ( strings strings.cpp ) add_executable ( move move.cpp ) add_executable ( struct struct.cpp ) #[aggregate_initialization CMakeLists.txt add_executable ( aggregate_initialization aggregate_initialization.cpp ) target_compile_features ( aggregate_initialization PRIVATE cxx_std_20 ) #] #[structured_binding CMakeLists.txt add_executable ( structured_binding structured_binding.cpp ) target_compile_features ( structured_binding PRIVATE cxx_std_17 ) #]","title":"Build script"},{"location":"basic-syntax/basic-data-types/move/","text":"Move Move std::move is used to indicate that an object t may be \"moved from\", i.e. allowing the efficient transfer of resources from one object to another. Headers 1 #include <utility> Copying a vector 1 2 std :: vector < double > v1 ( 30 , 1.0 ); std :: vector < double > v2 = v1 ; Both vectors are valid 1 2 3 4 5 6 7 8 9 10 11 std :: cout << \"v1: \" ; for ( double x : v1 ) { std :: cout << x << \" \" ; } std :: cout << '\\n' ; std :: cout << \"v2: \" ; for ( double x : v2 ) { std :: cout << x << \" \" ; } std :: cout << '\\n' ; Copying a vector 1 2 std :: vector < double > v1 ( 30 , 1.0 ); std :: vector < double > v2 = v1 ; The vector moved-from is invalidated 1 2 3 4 5 6 7 8 9 10 11 12 std :: cout << \"v1: \" ; // NOLINTNEXTLINE(bugprone-use-after-move): making a point for ( double x : v1 ) { std :: cout << x << \" \" ; // prints nothing } std :: cout << '\\n' ; std :: cout << \"v3: \" ; for ( double x : v3 ) { std :: cout << x << \" \" ; } std :: cout << '\\n' ; Share Snippets","title":"Move"},{"location":"basic-syntax/basic-data-types/move/#move","text":"Move std::move is used to indicate that an object t may be \"moved from\", i.e. allowing the efficient transfer of resources from one object to another. Headers 1 #include <utility> Copying a vector 1 2 std :: vector < double > v1 ( 30 , 1.0 ); std :: vector < double > v2 = v1 ; Both vectors are valid 1 2 3 4 5 6 7 8 9 10 11 std :: cout << \"v1: \" ; for ( double x : v1 ) { std :: cout << x << \" \" ; } std :: cout << '\\n' ; std :: cout << \"v2: \" ; for ( double x : v2 ) { std :: cout << x << \" \" ; } std :: cout << '\\n' ; Copying a vector 1 2 std :: vector < double > v1 ( 30 , 1.0 ); std :: vector < double > v2 = v1 ; The vector moved-from is invalidated 1 2 3 4 5 6 7 8 9 10 11 12 std :: cout << \"v1: \" ; // NOLINTNEXTLINE(bugprone-use-after-move): making a point for ( double x : v1 ) { std :: cout << x << \" \" ; // prints nothing } std :: cout << '\\n' ; std :: cout << \"v3: \" ; for ( double x : v3 ) { std :: cout << x << \" \" ; } std :: cout << '\\n' ; Share Snippets","title":"Move"},{"location":"basic-syntax/basic-data-types/raw-arrays/","text":"Raw arrays Raw arrays An array is a sequence of objects of the same type that occupy a contiguous area of memory. Traditional C-style arrays, or Raw Arrays, are the source of many bugs, but are still common, especially in older code bases. In modern C++, we strongly recommend using std::vector or std::array instead of C-style arrays. Explicit size 1 2 3 4 5 6 constexpr int n = 3 ; int a [ n ]; a [ 0 ] = 1 ; a [ 1 ] = 2 ; a [ 2 ] = 3 ; std :: cout << \"a: \" << a << '\\n' ; Accessing elements 1 2 3 std :: cout << \"a[0]: \" << a [ 0 ] << '\\n' ; std :: cout << \"a[1]: \" << a [ 1 ] << '\\n' ; std :: cout << \"a[2]: \" << a [ 2 ] << '\\n' ; Accessing element address 1 2 3 std :: cout << \"&a[0]: \" << & a [ 0 ] << '\\n' ; std :: cout << \"&a[1]: \" << & a [ 1 ] << '\\n' ; std :: cout << \"&a[2]: \" << & a [ 2 ] << '\\n' ; Implicit size 1 int b [] = { 1 , 2 , 3 }; Accessing elements in a loop 1 2 3 for ( size_t i = 0 ; i < n ; ++ i ) { std :: cout << \"b[\" << i << \"]: \" << b [ i ] << '\\n' ; } Array is converted to its initial pointer 1 2 3 4 std :: cout << \"b: \" << b << '\\n' ; std :: cout << \"&b: \" << & b << '\\n' ; std :: cout << \"b[0]: \" << b [ 0 ] << '\\n' ; std :: cout << \"&b[0]: \" << & b [ 0 ] << '\\n' ; Array addresses are sequential 1 2 3 4 std :: cout << \"b[1]: \" << b [ 1 ] << '\\n' ; std :: cout << \"&b[1]: \" << & b [ 1 ] << '\\n' ; std :: cout << \"b[2]: \" << b [ 2 ] << '\\n' ; std :: cout << \"&b[2]: \" << & b [ 2 ] << '\\n' ; Raw strings are just arrays of chars 1 2 3 char c [] = { 'a' , 'b' , 't' , '\\0' }; // same as: char d [] = \"abt\" ; Raw strings are streamed until '\\0' is found 1 2 std :: cout << \"c: \" << c << '\\n' ; std :: cout << \"d: \" << d << '\\n' ; Share Snippets","title":"Raw arrays"},{"location":"basic-syntax/basic-data-types/raw-arrays/#raw-arrays","text":"Raw arrays An array is a sequence of objects of the same type that occupy a contiguous area of memory. Traditional C-style arrays, or Raw Arrays, are the source of many bugs, but are still common, especially in older code bases. In modern C++, we strongly recommend using std::vector or std::array instead of C-style arrays. Explicit size 1 2 3 4 5 6 constexpr int n = 3 ; int a [ n ]; a [ 0 ] = 1 ; a [ 1 ] = 2 ; a [ 2 ] = 3 ; std :: cout << \"a: \" << a << '\\n' ; Accessing elements 1 2 3 std :: cout << \"a[0]: \" << a [ 0 ] << '\\n' ; std :: cout << \"a[1]: \" << a [ 1 ] << '\\n' ; std :: cout << \"a[2]: \" << a [ 2 ] << '\\n' ; Accessing element address 1 2 3 std :: cout << \"&a[0]: \" << & a [ 0 ] << '\\n' ; std :: cout << \"&a[1]: \" << & a [ 1 ] << '\\n' ; std :: cout << \"&a[2]: \" << & a [ 2 ] << '\\n' ; Implicit size 1 int b [] = { 1 , 2 , 3 }; Accessing elements in a loop 1 2 3 for ( size_t i = 0 ; i < n ; ++ i ) { std :: cout << \"b[\" << i << \"]: \" << b [ i ] << '\\n' ; } Array is converted to its initial pointer 1 2 3 4 std :: cout << \"b: \" << b << '\\n' ; std :: cout << \"&b: \" << & b << '\\n' ; std :: cout << \"b[0]: \" << b [ 0 ] << '\\n' ; std :: cout << \"&b[0]: \" << & b [ 0 ] << '\\n' ; Array addresses are sequential 1 2 3 4 std :: cout << \"b[1]: \" << b [ 1 ] << '\\n' ; std :: cout << \"&b[1]: \" << & b [ 1 ] << '\\n' ; std :: cout << \"b[2]: \" << b [ 2 ] << '\\n' ; std :: cout << \"&b[2]: \" << & b [ 2 ] << '\\n' ; Raw strings are just arrays of chars 1 2 3 char c [] = { 'a' , 'b' , 't' , '\\0' }; // same as: char d [] = \"abt\" ; Raw strings are streamed until '\\0' is found 1 2 std :: cout << \"c: \" << c << '\\n' ; std :: cout << \"d: \" << d << '\\n' ; Share Snippets","title":"Raw arrays"},{"location":"basic-syntax/basic-data-types/strings/","text":"Strings Strings std::string is a safe container for char strings of dynamic size. It automatically coordinates the process of allocating and deallocating memory for the elements as required. Headers 1 #include <string> Create string 1 2 // Strings are dynamic arrays of chars std :: string str = \"avocado\" ; Print the whole string 1 std :: cout << str << '\\n' ; Iterate the string chars 1 2 3 for ( size_t i = 0 ; i < str . size (); ++ i ) { std :: cout << \"str[\" << i << \"]: \" << str [ i ] << '\\n' ; } Access index 1 2 3 4 5 if ( str . size () >= 10 ) { std :: cout << \"str[10]: \" << str [ 10 ] << '\\n' ; } else { std :: cout << \"str[10]: (does not exist)\" << '\\n' ; } Container functions 1 2 3 4 std :: cout << \"str.size(): \" << str . size () << '\\n' ; std :: cout << \"str.empty(): \" << str . empty () << '\\n' ; std :: cout << \"str.front(): \" << str . front () << '\\n' ; std :: cout << \"str.back(): \" << str . back () << '\\n' ; Contiguous addresses (like any array) 1 2 std :: cout << \"&str: \" << & str << '\\n' ; std :: cout << \"str.data(): \" << str . data () << '\\n' ; The subscript operator accesses a single char 1 2 3 std :: cout << \"str[0]: \" << str [ 0 ] << '\\n' ; std :: cout << \"str[1]: \" << str [ 1 ] << '\\n' ; std :: cout << \"str[2]: \" << str [ 2 ] << '\\n' ; The address of a char prints from that position 1 2 3 std :: cout << \"&str[0]: \" << & str [ 0 ] << '\\n' ; std :: cout << \"&str[1]: \" << & str [ 1 ] << '\\n' ; std :: cout << \"&str[2]: \" << & str [ 2 ] << '\\n' ; Share Snippets","title":"Strings"},{"location":"basic-syntax/basic-data-types/strings/#strings","text":"Strings std::string is a safe container for char strings of dynamic size. It automatically coordinates the process of allocating and deallocating memory for the elements as required. Headers 1 #include <string> Create string 1 2 // Strings are dynamic arrays of chars std :: string str = \"avocado\" ; Print the whole string 1 std :: cout << str << '\\n' ; Iterate the string chars 1 2 3 for ( size_t i = 0 ; i < str . size (); ++ i ) { std :: cout << \"str[\" << i << \"]: \" << str [ i ] << '\\n' ; } Access index 1 2 3 4 5 if ( str . size () >= 10 ) { std :: cout << \"str[10]: \" << str [ 10 ] << '\\n' ; } else { std :: cout << \"str[10]: (does not exist)\" << '\\n' ; } Container functions 1 2 3 4 std :: cout << \"str.size(): \" << str . size () << '\\n' ; std :: cout << \"str.empty(): \" << str . empty () << '\\n' ; std :: cout << \"str.front(): \" << str . front () << '\\n' ; std :: cout << \"str.back(): \" << str . back () << '\\n' ; Contiguous addresses (like any array) 1 2 std :: cout << \"&str: \" << & str << '\\n' ; std :: cout << \"str.data(): \" << str . data () << '\\n' ; The subscript operator accesses a single char 1 2 3 std :: cout << \"str[0]: \" << str [ 0 ] << '\\n' ; std :: cout << \"str[1]: \" << str [ 1 ] << '\\n' ; std :: cout << \"str[2]: \" << str [ 2 ] << '\\n' ; The address of a char prints from that position 1 2 3 std :: cout << \"&str[0]: \" << & str [ 0 ] << '\\n' ; std :: cout << \"&str[1]: \" << & str [ 1 ] << '\\n' ; std :: cout << \"&str[2]: \" << & str [ 2 ] << '\\n' ; Share Snippets","title":"Strings"},{"location":"basic-syntax/basic-data-types/structured-binding/","text":"Structured binding Structured binding Structured binding binds the specified names to subobjects or elements of the initializer. Like a reference, a structured binding is an alias to an existing object. CMakeLists.txt 1 2 add_executable ( structured_binding structured_binding.cpp ) target_compile_features ( structured_binding PRIVATE cxx_std_17 ) Unpacking pairs 1 2 3 4 std :: vector < int > v = { 7 , 3 , 9 , 3 , 1 , 7 , 4 , 9 }; auto [ min_value , max_value ] = minmax ( v ); std :: cout << \"min_value: \" << min_value << '\\n' ; std :: cout << \"max_value: \" << max_value << '\\n' ; Unpacking tuples 1 2 3 4 5 6 // `stats` returns `std::tuple<int, double, double, double>` auto [ total , mean , variance , stddev ] = stats ( v ); std :: cout << \"total: \" << total << '\\n' ; std :: cout << \"mean: \" << mean << '\\n' ; std :: cout << \"variance: \" << variance << '\\n' ; std :: cout << \"stddev: \" << stddev << '\\n' ; Declare struct 1 2 3 4 5 struct Foo { int i ; char c ; double d ; }; Unpacking structs 1 2 3 4 5 Foo f { 1 , 'a' , 2.3 }; auto [ i , c , d ] = f ; std :: cout << \"f.i: \" << i << '\\n' ; std :: cout << \"f.c: \" << c << '\\n' ; std :: cout << \"f.d: \" << d << '\\n' ; Creating references 1 2 3 4 auto & [ i2 , c2 , d2 ] = f ; std :: cout << \"i2: \" << i2 << '\\n' ; std :: cout << \"c2: \" << c2 << '\\n' ; std :: cout << \"d2: \" << d2 << '\\n' ; Unpacking raw arrays 1 2 3 4 int a [ 2 ] = { 1 , 2 }; auto [ x , y ] = a ; std :: cout << \"x: \" << x << '\\n' ; std :: cout << \"y: \" << y << '\\n' ; range-based loop 1 2 3 4 5 6 7 8 9 std :: map < std :: string , int > my_map = { { \"hello\" , 1 }, { \"world\" , 2 }, { \"it's\" , 3 }, { \"me\" , 4 }, }; for ( auto && [ key , value ] : my_map ) { std :: cout << \"key=\" << key << \" value=\" << value << '\\n' ; } Getting iterator from the insert function 1 2 3 4 5 6 7 if ( auto [ iter , success ] = my_map . insert ( std :: make_pair ( \"Bye\" , 5 )); success ) { auto & [ key , value ] = * iter ; std :: cout << \"insert is successful. The value is \" << quoted ( key ) << '\\n' ; } else { auto & [ key , value ] = * iter ; std :: cout << \"The value \" << quoted ( key ) << \" already exists in the set \\n \" ; } Get min and max elements from a vector 1 2 3 4 5 std :: pair < int , int > minmax ( std :: vector < int > & v ) { // unpack tuple of iterators with min and max auto [ min_iter , max_iter ] = std :: minmax_element ( v . begin (), v . end ()); return std :: make_pair ( * min_iter , * max_iter ); } Share Snippets","title":"Structured binding"},{"location":"basic-syntax/basic-data-types/structured-binding/#structured-binding","text":"Structured binding Structured binding binds the specified names to subobjects or elements of the initializer. Like a reference, a structured binding is an alias to an existing object. CMakeLists.txt 1 2 add_executable ( structured_binding structured_binding.cpp ) target_compile_features ( structured_binding PRIVATE cxx_std_17 ) Unpacking pairs 1 2 3 4 std :: vector < int > v = { 7 , 3 , 9 , 3 , 1 , 7 , 4 , 9 }; auto [ min_value , max_value ] = minmax ( v ); std :: cout << \"min_value: \" << min_value << '\\n' ; std :: cout << \"max_value: \" << max_value << '\\n' ; Unpacking tuples 1 2 3 4 5 6 // `stats` returns `std::tuple<int, double, double, double>` auto [ total , mean , variance , stddev ] = stats ( v ); std :: cout << \"total: \" << total << '\\n' ; std :: cout << \"mean: \" << mean << '\\n' ; std :: cout << \"variance: \" << variance << '\\n' ; std :: cout << \"stddev: \" << stddev << '\\n' ; Declare struct 1 2 3 4 5 struct Foo { int i ; char c ; double d ; }; Unpacking structs 1 2 3 4 5 Foo f { 1 , 'a' , 2.3 }; auto [ i , c , d ] = f ; std :: cout << \"f.i: \" << i << '\\n' ; std :: cout << \"f.c: \" << c << '\\n' ; std :: cout << \"f.d: \" << d << '\\n' ; Creating references 1 2 3 4 auto & [ i2 , c2 , d2 ] = f ; std :: cout << \"i2: \" << i2 << '\\n' ; std :: cout << \"c2: \" << c2 << '\\n' ; std :: cout << \"d2: \" << d2 << '\\n' ; Unpacking raw arrays 1 2 3 4 int a [ 2 ] = { 1 , 2 }; auto [ x , y ] = a ; std :: cout << \"x: \" << x << '\\n' ; std :: cout << \"y: \" << y << '\\n' ; range-based loop 1 2 3 4 5 6 7 8 9 std :: map < std :: string , int > my_map = { { \"hello\" , 1 }, { \"world\" , 2 }, { \"it's\" , 3 }, { \"me\" , 4 }, }; for ( auto && [ key , value ] : my_map ) { std :: cout << \"key=\" << key << \" value=\" << value << '\\n' ; } Getting iterator from the insert function 1 2 3 4 5 6 7 if ( auto [ iter , success ] = my_map . insert ( std :: make_pair ( \"Bye\" , 5 )); success ) { auto & [ key , value ] = * iter ; std :: cout << \"insert is successful. The value is \" << quoted ( key ) << '\\n' ; } else { auto & [ key , value ] = * iter ; std :: cout << \"The value \" << quoted ( key ) << \" already exists in the set \\n \" ; } Get min and max elements from a vector 1 2 3 4 5 std :: pair < int , int > minmax ( std :: vector < int > & v ) { // unpack tuple of iterators with min and max auto [ min_iter , max_iter ] = std :: minmax_element ( v . begin (), v . end ()); return std :: make_pair ( * min_iter , * max_iter ); } Share Snippets","title":"Structured binding"},{"location":"basic-syntax/basic-data-types/vectors/","text":"Vectors Vectors std::vector is a safe container for arrays of dynamic size. It automatically coordinates the process of allocating and deallocating memory for the elements as required. Headers 1 #include <vector> Dynamic size vector 1 std :: vector < int > v = { 1 , 2 , 3 }; Iterate vector elements 1 2 3 for ( size_t i = 0 ; i < v . size (); ++ i ) { std :: cout << \"v[\" << i << \"]: \" << v [ i ] << '\\n' ; } Member functions 1 2 3 4 std :: cout << \"v.size(): \" << v . size () << '\\n' ; std :: cout << \"v.empty(): \" << v . empty () << '\\n' ; std :: cout << \"v.front(): \" << v . front () << '\\n' ; std :: cout << \"v.back(): \" << v . back () << '\\n' ; Access addresses 1 2 3 4 std :: cout << \"&v: \" << & v << '\\n' ; std :: cout << \"&v[0]: \" << & v [ 0 ] << '\\n' ; std :: cout << \"&v[1]: \" << & v [ 1 ] << '\\n' ; std :: cout << \"&v[2]: \" << & v [ 2 ] << '\\n' ; Iterate vector elements 1 2 3 for ( size_t i = 0 ; i < v . size (); ++ i ) { std :: cout << \"v[\" << i << \"]: \" << v [ i ] << '\\n' ; } Modify vector 1 v . push_back ( 5 ); Underlying array 1 2 // We might still need the underlying raw array to interact with old code std :: cout << \"Underlying raw vector: \" << v . data () << '\\n' ; Vector inline size 1 2 3 // vector<T,N> has no fixed size in bytes // sizeof(v) has only the size of the pointers to manage v std :: cout << \"sizeof(v): \" << sizeof ( v ) << '\\n' ; Multidimensional vector 1 2 3 4 5 6 std :: vector < std :: vector < double >> matrix ( 10 , std :: vector < double > ( 3 , 0 )); for ( size_t i = 0 ; i < matrix . size (); ++ i ) { for ( size_t j = 0 ; j < matrix [ i ]. size (); ++ j ) { matrix [ i ][ j ] = 0.5 * i + 0.8 * j ; } } Multidimensional range-based loops 1 2 3 4 5 6 7 for ( const auto & row : matrix ) { double sum = 0. ; for ( const auto & col : row ) { sum += col ; } std :: cout << \"Row average \" << sum / row . size () << '\\n' ; } Share Snippets","title":"Vectors"},{"location":"basic-syntax/basic-data-types/vectors/#vectors","text":"Vectors std::vector is a safe container for arrays of dynamic size. It automatically coordinates the process of allocating and deallocating memory for the elements as required. Headers 1 #include <vector> Dynamic size vector 1 std :: vector < int > v = { 1 , 2 , 3 }; Iterate vector elements 1 2 3 for ( size_t i = 0 ; i < v . size (); ++ i ) { std :: cout << \"v[\" << i << \"]: \" << v [ i ] << '\\n' ; } Member functions 1 2 3 4 std :: cout << \"v.size(): \" << v . size () << '\\n' ; std :: cout << \"v.empty(): \" << v . empty () << '\\n' ; std :: cout << \"v.front(): \" << v . front () << '\\n' ; std :: cout << \"v.back(): \" << v . back () << '\\n' ; Access addresses 1 2 3 4 std :: cout << \"&v: \" << & v << '\\n' ; std :: cout << \"&v[0]: \" << & v [ 0 ] << '\\n' ; std :: cout << \"&v[1]: \" << & v [ 1 ] << '\\n' ; std :: cout << \"&v[2]: \" << & v [ 2 ] << '\\n' ; Iterate vector elements 1 2 3 for ( size_t i = 0 ; i < v . size (); ++ i ) { std :: cout << \"v[\" << i << \"]: \" << v [ i ] << '\\n' ; } Modify vector 1 v . push_back ( 5 ); Underlying array 1 2 // We might still need the underlying raw array to interact with old code std :: cout << \"Underlying raw vector: \" << v . data () << '\\n' ; Vector inline size 1 2 3 // vector<T,N> has no fixed size in bytes // sizeof(v) has only the size of the pointers to manage v std :: cout << \"sizeof(v): \" << sizeof ( v ) << '\\n' ; Multidimensional vector 1 2 3 4 5 6 std :: vector < std :: vector < double >> matrix ( 10 , std :: vector < double > ( 3 , 0 )); for ( size_t i = 0 ; i < matrix . size (); ++ i ) { for ( size_t j = 0 ; j < matrix [ i ]. size (); ++ j ) { matrix [ i ][ j ] = 0.5 * i + 0.8 * j ; } } Multidimensional range-based loops 1 2 3 4 5 6 7 for ( const auto & row : matrix ) { double sum = 0. ; for ( const auto & col : row ) { sum += col ; } std :: cout << \"Row average \" << sum / row . size () << '\\n' ; } Share Snippets","title":"Vectors"},{"location":"basic-syntax/control-flow/conditional/","text":"Conditional Conditional control flow Conditional expressions and conditional constructs are features of a programming language which perform different computations or actions depending on whether a programmer-specified boolean condition evaluates to true or false Simple conditional 1 2 3 if ( first_number % 2 == 0 ) { ++ n_even_numbers ; } Ternary Operator 1 2 // same as: n_even_numbers += second_number % 2 == 0; n_even_numbers += ( first_number % 2 == 0 ) ? 1 : 0 ; Branches 1 2 3 4 5 6 7 8 9 10 if ( n_even_numbers == 0 ) { cout << \"You typed 0 even numbers and 2 odd numbers \\n \" ; } else if ( n_even_numbers == 1 ) { cout << \"You typed 1 even number e 1 odd number \\n \" ; } else if ( n_even_numbers == 2 ) { cout << \"You typed 2 even numbers e 0 odd numbers \\n \" ; } else { cout << \"There's a serious problem here \\n \" ; return 1 ; } Switch on fundamental data types 1 2 3 4 5 6 7 8 9 10 11 12 13 14 switch ( n_even_numbers ) { case 0 : cout << \"Zero even numbers. Two odd numbers. \\n \" ; break ; case 1 : cout << \"One even number and one odd number. \\n \" ; break ; case 2 : cout << \"Two even numbers. No odd numbers. \\n \" ; break ; default : cout << \"We found a serious error with your program \\n \" ; return 1 ; } Common conditional without n_even_numbers 1 2 3 4 5 6 7 if ( first_number % 2 != 0 && second_number % 2 != 0 ) { cout << \"You typed 0 even numbers e 2 odd numbers \\n \" ; } else if ( first_number % 2 == 0 && second_number % 2 == 0 ) { cout << \"You typed 2 even numbers e 0 odd numbers \\n \" ; } else { cout << \"You typed 1 even number e 1 odd number \\n \" ; } Printing directly 1 2 cout << \"You typed \" << n_even_numbers << \" even numbers and \" << number_of_numbers - n_even_numbers << \" odd numbers \\n \" ; Ternary operators for fixing plurals 1 2 3 4 cout << \"You typed \" << n_even_numbers << \" even number\" ; cout << ( n_even_numbers == 1 ? \"\" : \"s\" ); cout << \" and \" << number_of_numbers - n_even_numbers << \" odd number\" ; cout << ( number_of_numbers - n_even_numbers == 1 ? \"\" : \"s\" ); Common conditional 1 2 3 4 5 if ( n_even_numbers > number_of_numbers - n_even_numbers ) { cout << \"You have more even numbers \\n \" ; } else { cout << \"You don't have more even numbers \\n \" ; } Ternary operator 1 2 3 4 cout << \"You \" << (( n_even_numbers > number_of_numbers - n_even_numbers ) ? ( \"\" ) : ( \"don't\" )); cout << \" have more even numbers than odd numbers \\n \" ; Testing constants 1 2 3 4 5 if constexpr ( number_of_numbers > 2 ) { cout << \"You're program is not adapted to that yet \\n \" ; } else { cout << \"Program for testing up to two numbers \\n \" ; } Share Snippets","title":"Conditional"},{"location":"basic-syntax/control-flow/conditional/#conditional","text":"Conditional control flow Conditional expressions and conditional constructs are features of a programming language which perform different computations or actions depending on whether a programmer-specified boolean condition evaluates to true or false Simple conditional 1 2 3 if ( first_number % 2 == 0 ) { ++ n_even_numbers ; } Ternary Operator 1 2 // same as: n_even_numbers += second_number % 2 == 0; n_even_numbers += ( first_number % 2 == 0 ) ? 1 : 0 ; Branches 1 2 3 4 5 6 7 8 9 10 if ( n_even_numbers == 0 ) { cout << \"You typed 0 even numbers and 2 odd numbers \\n \" ; } else if ( n_even_numbers == 1 ) { cout << \"You typed 1 even number e 1 odd number \\n \" ; } else if ( n_even_numbers == 2 ) { cout << \"You typed 2 even numbers e 0 odd numbers \\n \" ; } else { cout << \"There's a serious problem here \\n \" ; return 1 ; } Switch on fundamental data types 1 2 3 4 5 6 7 8 9 10 11 12 13 14 switch ( n_even_numbers ) { case 0 : cout << \"Zero even numbers. Two odd numbers. \\n \" ; break ; case 1 : cout << \"One even number and one odd number. \\n \" ; break ; case 2 : cout << \"Two even numbers. No odd numbers. \\n \" ; break ; default : cout << \"We found a serious error with your program \\n \" ; return 1 ; } Common conditional without n_even_numbers 1 2 3 4 5 6 7 if ( first_number % 2 != 0 && second_number % 2 != 0 ) { cout << \"You typed 0 even numbers e 2 odd numbers \\n \" ; } else if ( first_number % 2 == 0 && second_number % 2 == 0 ) { cout << \"You typed 2 even numbers e 0 odd numbers \\n \" ; } else { cout << \"You typed 1 even number e 1 odd number \\n \" ; } Printing directly 1 2 cout << \"You typed \" << n_even_numbers << \" even numbers and \" << number_of_numbers - n_even_numbers << \" odd numbers \\n \" ; Ternary operators for fixing plurals 1 2 3 4 cout << \"You typed \" << n_even_numbers << \" even number\" ; cout << ( n_even_numbers == 1 ? \"\" : \"s\" ); cout << \" and \" << number_of_numbers - n_even_numbers << \" odd number\" ; cout << ( number_of_numbers - n_even_numbers == 1 ? \"\" : \"s\" ); Common conditional 1 2 3 4 5 if ( n_even_numbers > number_of_numbers - n_even_numbers ) { cout << \"You have more even numbers \\n \" ; } else { cout << \"You don't have more even numbers \\n \" ; } Ternary operator 1 2 3 4 cout << \"You \" << (( n_even_numbers > number_of_numbers - n_even_numbers ) ? ( \"\" ) : ( \"don't\" )); cout << \" have more even numbers than odd numbers \\n \" ; Testing constants 1 2 3 4 5 if constexpr ( number_of_numbers > 2 ) { cout << \"You're program is not adapted to that yet \\n \" ; } else { cout << \"Program for testing up to two numbers \\n \" ; } Share Snippets","title":"Conditional"},{"location":"basic-syntax/control-flow/loops/","text":"Loops Loops A loop is a sequence of statements which is specified once but which may be carried out several times in succession. The code \"inside\" the loop (the body of the loop) is obeyed a specified number of times, or once for each of a collection of items, or until some condition is met, or indefinitely. Basic loop 1 2 3 for ( int i = 0 ; i < 10 ; ++ i ) { std :: cout << \"Hello world!\" << '\\n' ; } Changing the number of repetitions 1 2 3 4 5 6 std :: cout << \"How many hello worlds? \" ; int z ; std :: cin >> z ; for ( int i = 0 ; i < z ; ++ i ) { std :: cout << \"Hello world\" << '\\n' ; } Similar tasks according to the counter 1 2 3 for ( int i = 0 ; i < 10 ; ++ i ) { std :: cout << \"Hello world \" << i << \"! \\n \" ; } Changing external variables 1 2 3 4 5 int total = 0 ; for ( int i = 0 ; i < 10 ; ++ i ) { total += i ; } std :: cout << \"0+1+2+3+4+...+9: \" << total << '\\n' ; Loop + conditional 1 2 3 4 5 6 7 8 total = 0 ; for ( int i = 0 ; i < 50 ; ++ i ) { const bool is_multiple_of_three = i % 3 == 0 ; if ( is_multiple_of_three ) { total += i ; } } std :: cout << \"0+3+6+9+12+...+48: \" << total << '\\n' ; Changing initialization 1 2 3 4 5 6 7 // 5/3 + 7/4 + 9/5 + 11/6 + ... float series = 0. ; for ( int i = 3 ; i < 50 ; ++ i ) { const auto i_float = static_cast < float > ( i ); series += ( i_float * 2 - 1 ) / i_float ; } std :: cout << \"5/3+7/4+9/5+...+97/49: \" << series << '\\n' ; Changing update statement to += 1 2 3 4 5 total = 0 ; for ( int i = 7 ; i < 500 ; i += 7 ) { total += i ; } std :: cout << \"7+14+21+...+497: \" << total << '\\n' ; Changing update statement to *= 1 2 3 for ( int i = 2 ; i <= 1024 ; i *= 2 ) { std :: cout << i << '\\n' ; } Index-based loop for containers with subscript operator[] 1 2 3 4 5 constexpr int n = 100 ; std :: array < double , n > prices {}; for ( size_t i = 0 ; i < prices . size (); ++ i ) { prices [ i ] = 4.0 + 0.1 * i ; } Range-based loop for containers 1 2 3 for ( double & price : prices ) { std :: cout << \"Item price: \" << price << '\\n' ; } Range-based loop with constant references 1 2 3 4 5 double sum = 0. ; for ( const auto & price : prices ) { sum += price ; } std :: cout << \"Average price: \" << sum / n << '\\n' ; Range-based loop with maps 1 2 3 4 5 6 7 std :: map < int , int > t ; t [ 7 ] = 2 ; t [ 8 ] = 4 ; t [ 4 ] = 6 ; for ( const auto & p : t ) { std :: cout << p . first << \": \" << p . second << '\\n' ; } Range-based loop with value pairs 1 2 3 for ( const auto & [ key , value ] : t ) { std :: cout << key << \": \" << value << '\\n' ; } 2D arrays 1 2 3 4 5 6 7 8 constexpr int n1 = 100 ; constexpr int n2 = 3 ; std :: array < std :: array < double , n2 > , n1 > grades {}; for ( int i = 0 ; i < n1 ; ++ i ) { for ( int j = 0 ; j < n2 ; ++ j ) { grades [ i ][ j ] = 6. + i * ( 2. / n1 ) + j * ( 2. / n2 ); } } 2D range based loop 1 2 3 4 5 6 7 for ( const auto & row : grades ) { double row_sum = 0.0 ; for ( const auto & col : row ) { row_sum += col ; } std :: cout << \"Average student grade: \" << row_sum / row . size () << '\\n' ; } Columns in the external for 1 2 3 4 5 6 7 8 for ( int j = 0 ; j < n2 ; ++ j ) { double col_sum = 0.0 ; for ( int i = 0 ; i < n1 ; ++ i ) { col_sum += grades [ i ][ j ]; } std :: cout << \"Average score on test \" << j + 1 << \": \" << col_sum / n1 << '\\n' ; } While loop 1 2 3 4 5 6 int num = 1 ; while ( num != 0 ) { std :: cout << \"Enter a number: \" ; std :: cin >> num ; std :: cout << num << \"^2 = \" << num * num << '\\n' ; } Do-while loop 1 2 3 4 5 do { std :: cout << \"Enter a number: \" ; std :: cin >> num ; std :: cout << num << \"^2 = \" << num * num << '\\n' ; } while ( num != 0 ); Share Snippets","title":"Loops"},{"location":"basic-syntax/control-flow/loops/#loops","text":"Loops A loop is a sequence of statements which is specified once but which may be carried out several times in succession. The code \"inside\" the loop (the body of the loop) is obeyed a specified number of times, or once for each of a collection of items, or until some condition is met, or indefinitely. Basic loop 1 2 3 for ( int i = 0 ; i < 10 ; ++ i ) { std :: cout << \"Hello world!\" << '\\n' ; } Changing the number of repetitions 1 2 3 4 5 6 std :: cout << \"How many hello worlds? \" ; int z ; std :: cin >> z ; for ( int i = 0 ; i < z ; ++ i ) { std :: cout << \"Hello world\" << '\\n' ; } Similar tasks according to the counter 1 2 3 for ( int i = 0 ; i < 10 ; ++ i ) { std :: cout << \"Hello world \" << i << \"! \\n \" ; } Changing external variables 1 2 3 4 5 int total = 0 ; for ( int i = 0 ; i < 10 ; ++ i ) { total += i ; } std :: cout << \"0+1+2+3+4+...+9: \" << total << '\\n' ; Loop + conditional 1 2 3 4 5 6 7 8 total = 0 ; for ( int i = 0 ; i < 50 ; ++ i ) { const bool is_multiple_of_three = i % 3 == 0 ; if ( is_multiple_of_three ) { total += i ; } } std :: cout << \"0+3+6+9+12+...+48: \" << total << '\\n' ; Changing initialization 1 2 3 4 5 6 7 // 5/3 + 7/4 + 9/5 + 11/6 + ... float series = 0. ; for ( int i = 3 ; i < 50 ; ++ i ) { const auto i_float = static_cast < float > ( i ); series += ( i_float * 2 - 1 ) / i_float ; } std :: cout << \"5/3+7/4+9/5+...+97/49: \" << series << '\\n' ; Changing update statement to += 1 2 3 4 5 total = 0 ; for ( int i = 7 ; i < 500 ; i += 7 ) { total += i ; } std :: cout << \"7+14+21+...+497: \" << total << '\\n' ; Changing update statement to *= 1 2 3 for ( int i = 2 ; i <= 1024 ; i *= 2 ) { std :: cout << i << '\\n' ; } Index-based loop for containers with subscript operator[] 1 2 3 4 5 constexpr int n = 100 ; std :: array < double , n > prices {}; for ( size_t i = 0 ; i < prices . size (); ++ i ) { prices [ i ] = 4.0 + 0.1 * i ; } Range-based loop for containers 1 2 3 for ( double & price : prices ) { std :: cout << \"Item price: \" << price << '\\n' ; } Range-based loop with constant references 1 2 3 4 5 double sum = 0. ; for ( const auto & price : prices ) { sum += price ; } std :: cout << \"Average price: \" << sum / n << '\\n' ; Range-based loop with maps 1 2 3 4 5 6 7 std :: map < int , int > t ; t [ 7 ] = 2 ; t [ 8 ] = 4 ; t [ 4 ] = 6 ; for ( const auto & p : t ) { std :: cout << p . first << \": \" << p . second << '\\n' ; } Range-based loop with value pairs 1 2 3 for ( const auto & [ key , value ] : t ) { std :: cout << key << \": \" << value << '\\n' ; } 2D arrays 1 2 3 4 5 6 7 8 constexpr int n1 = 100 ; constexpr int n2 = 3 ; std :: array < std :: array < double , n2 > , n1 > grades {}; for ( int i = 0 ; i < n1 ; ++ i ) { for ( int j = 0 ; j < n2 ; ++ j ) { grades [ i ][ j ] = 6. + i * ( 2. / n1 ) + j * ( 2. / n2 ); } } 2D range based loop 1 2 3 4 5 6 7 for ( const auto & row : grades ) { double row_sum = 0.0 ; for ( const auto & col : row ) { row_sum += col ; } std :: cout << \"Average student grade: \" << row_sum / row . size () << '\\n' ; } Columns in the external for 1 2 3 4 5 6 7 8 for ( int j = 0 ; j < n2 ; ++ j ) { double col_sum = 0.0 ; for ( int i = 0 ; i < n1 ; ++ i ) { col_sum += grades [ i ][ j ]; } std :: cout << \"Average score on test \" << j + 1 << \": \" << col_sum / n1 << '\\n' ; } While loop 1 2 3 4 5 6 int num = 1 ; while ( num != 0 ) { std :: cout << \"Enter a number: \" ; std :: cin >> num ; std :: cout << num << \"^2 = \" << num * num << '\\n' ; } Do-while loop 1 2 3 4 5 do { std :: cout << \"Enter a number: \" ; std :: cin >> num ; std :: cout << num << \"^2 = \" << num * num << '\\n' ; } while ( num != 0 ); Share Snippets","title":"Loops"},{"location":"basic-syntax/control-flow/scopes/","text":"Scopes Scopes The context in which a name is visible is called its scope. For example, if you declare a variable x within a function, x is only visible within that function body. It has local scope. External and internal scopes 1 2 3 4 5 6 7 8 9 int x = 1 ; std :: cout << \"External x: \" << x << '\\n' ; for ( int i = 0 ; i < 2 ; ++ i ) { int y = 2 ; std :: cout << \"Internal i: \" << i << '\\n' ; std :: cout << \"External x: \" << x << '\\n' ; std :: cout << \"Internal y: \" << y << '\\n' ; } std :: cout << \"External x: \" << x << '\\n' ; Variables outside their scope 1 2 3 // This won't work: // std::cout << \"Internal i: \" << i << '\\n'; // std::cout << \"Internal y: \" << y << '\\n'; Share Snippets","title":"Scopes"},{"location":"basic-syntax/control-flow/scopes/#scopes","text":"Scopes The context in which a name is visible is called its scope. For example, if you declare a variable x within a function, x is only visible within that function body. It has local scope. External and internal scopes 1 2 3 4 5 6 7 8 9 int x = 1 ; std :: cout << \"External x: \" << x << '\\n' ; for ( int i = 0 ; i < 2 ; ++ i ) { int y = 2 ; std :: cout << \"Internal i: \" << i << '\\n' ; std :: cout << \"External x: \" << x << '\\n' ; std :: cout << \"Internal y: \" << y << '\\n' ; } std :: cout << \"External x: \" << x << '\\n' ; Variables outside their scope 1 2 3 // This won't work: // std::cout << \"Internal i: \" << i << '\\n'; // std::cout << \"Internal y: \" << y << '\\n'; Share Snippets","title":"Scopes"},{"location":"basic-syntax/control-flow/sequential/","text":"Sequential Sequential control flow In structured programming, the ordered sequencing of successive commands is considered one of the basic control structures, which is used as a building block for programs alongside iteration, recursion and conditionals. Store and output values 1 2 3 double l = 4 ; double area = l * l ; std :: cout << \"Area: \" << area << '\\n' ; Store and output values 1 2 3 double l = 4 ; double area = l * l ; std :: cout << \"Area: \" << area << '\\n' ; Store and output values 1 2 3 double l = 4 ; double area = l * l ; std :: cout << \"Area: \" << area << '\\n' ; Share Snippets","title":"Sequential"},{"location":"basic-syntax/control-flow/sequential/#sequential","text":"Sequential control flow In structured programming, the ordered sequencing of successive commands is considered one of the basic control structures, which is used as a building block for programs alongside iteration, recursion and conditionals. Store and output values 1 2 3 double l = 4 ; double area = l * l ; std :: cout << \"Area: \" << area << '\\n' ; Store and output values 1 2 3 double l = 4 ; double area = l * l ; std :: cout << \"Area: \" << area << '\\n' ; Store and output values 1 2 3 double l = 4 ; double area = l * l ; std :: cout << \"Area: \" << area << '\\n' ; Share Snippets","title":"Sequential"},{"location":"basic-syntax/data-types/auto/","text":"Type deduction Type deduction The auto keyword declares a variable whose type is deduced from the initialization expression in its declaration. Auto for fundamental data types: Avoid using auto for fundamental data types! This is a bad place for auto It does not avoid a long type name It creates ambiguity auto x = 87 could semantically be any number type This is somewhat equivalent to: swift: var dont_do_that = 87 rust: let mut dont_do_that = 87 On the other hand, auto is very useful in generic functions where there types are not ambiguous. Auto for fundamental data types 1 2 auto dont_do_that = 87 ; std :: cout << \"dont_do_that: \" << dont_do_that << '\\n' ; Creating a hash table for the next snippet 1 2 3 4 std :: unordered_map < std :: string , double > t ; t [ \"zero\" ] = 0.0 ; t [ \"pi\" ] = 3.14 ; t [ \"ten\" ] = 10.0 ; Accessing container without auto 1 2 3 4 5 // NOLINTNEXTLINE(modernize-use-auto) std :: unordered_map < std :: string , double >:: iterator it = t . find ( \"pi\" ); if ( it != t . end ()) { std :: cout << it -> first << \": \" << it -> second << '\\n' ; } Accessing container with auto 1 2 3 4 5 6 7 8 // This is the perfect place for auto // - It avoids a long type name // - There's no ambiguity // - Find will always return an iterator auto it2 = t . find ( \"zero\" ); if ( it2 != t . end ()) { std :: cout << it2 -> first << \": \" << it2 -> second << '\\n' ; } Get type from another variable 1 2 3 4 5 6 decltype ( it ) it3 ; it3 = it ; ++ it3 ; if ( it3 != t . end ()) { std :: cout << it3 -> first << \": \" << it3 -> second << '\\n' ; } auto in generic functions 1 2 3 4 5 6 auto print_map_container = []( const auto & m ) { for ( auto && item : m ) { std :: cout << item . first << \": \" << item . second << '\\n' ; } }; print_map_container ( t ); Share Snippets","title":"Type deduction"},{"location":"basic-syntax/data-types/auto/#type-deduction","text":"Type deduction The auto keyword declares a variable whose type is deduced from the initialization expression in its declaration. Auto for fundamental data types: Avoid using auto for fundamental data types! This is a bad place for auto It does not avoid a long type name It creates ambiguity auto x = 87 could semantically be any number type This is somewhat equivalent to: swift: var dont_do_that = 87 rust: let mut dont_do_that = 87 On the other hand, auto is very useful in generic functions where there types are not ambiguous. Auto for fundamental data types 1 2 auto dont_do_that = 87 ; std :: cout << \"dont_do_that: \" << dont_do_that << '\\n' ; Creating a hash table for the next snippet 1 2 3 4 std :: unordered_map < std :: string , double > t ; t [ \"zero\" ] = 0.0 ; t [ \"pi\" ] = 3.14 ; t [ \"ten\" ] = 10.0 ; Accessing container without auto 1 2 3 4 5 // NOLINTNEXTLINE(modernize-use-auto) std :: unordered_map < std :: string , double >:: iterator it = t . find ( \"pi\" ); if ( it != t . end ()) { std :: cout << it -> first << \": \" << it -> second << '\\n' ; } Accessing container with auto 1 2 3 4 5 6 7 8 // This is the perfect place for auto // - It avoids a long type name // - There's no ambiguity // - Find will always return an iterator auto it2 = t . find ( \"zero\" ); if ( it2 != t . end ()) { std :: cout << it2 -> first << \": \" << it2 -> second << '\\n' ; } Get type from another variable 1 2 3 4 5 6 decltype ( it ) it3 ; it3 = it ; ++ it3 ; if ( it3 != t . end ()) { std :: cout << it3 -> first << \": \" << it3 -> second << '\\n' ; } auto in generic functions 1 2 3 4 5 6 auto print_map_container = []( const auto & m ) { for ( auto && item : m ) { std :: cout << item . first << \": \" << item . second << '\\n' ; } }; print_map_container ( t ); Share Snippets","title":"Type deduction"},{"location":"basic-syntax/data-types/constants/","text":"Constants constants When you do not want others (or yourself) to override existing variable values, use the const keyword. This will declare the variable as \"constant\", which means unchangeable and read-only. Mutable variable 1 2 3 int a = 2 ; a = 3 ; std :: cout << \"a : \" << a << '\\n' ; Constants as a promise 1 2 3 const int b = 3 ; // b = 4; <- this fails. `b` is constant. std :: cout << \"b : \" << b << '\\n' ; const from mutable value 1 2 3 4 // `b2` can be initialized with any value, but cannot be changed after this. // This is possible, but makes it impossible to know b2 in compile-time. const int b2 = a ; std :: cout << \"b2 : \" << b2 << '\\n' ; Constant \"more constant than const\" 1 2 3 4 // `c` can only use values available at compile-time // `c` cannot be initialized with a mutable value constexpr int c = 4 ; std :: cout << \"c : \" << c << '\\n' ; Constant \"more constant than const\" 1 2 3 4 // `c` can only use values available at compile-time // `c` cannot be initialized with a mutable value constexpr int c = 4 ; std :: cout << \"c : \" << c << '\\n' ; Creating arrays from mutable value 1 2 3 // The compiler needs to know the size at compile time // Impossible: // std::array<int,a> v1; Creating arrays from compile-time const values 1 2 3 // Sometimes possible, if b was not initialized with a mutable value std :: array < int , b > v2 = { 5 , 6 , 5 }; std :: cout << \"v2.size(): \" << v2 . size () << '\\n' ; Creating arrays from runtime const values 1 2 // Impossible (b2 depends on a variable): // std::array<int,b2> v2b; Creating arrays from compile-time constexpr values 1 2 3 // Always possible std :: array < int , c > v3 = { 7 , 8 , 7 , 8 }; std :: cout << \"v3.size(): \" << v3 . size () << '\\n' ; Share Snippets","title":"Constants"},{"location":"basic-syntax/data-types/constants/#constants","text":"constants When you do not want others (or yourself) to override existing variable values, use the const keyword. This will declare the variable as \"constant\", which means unchangeable and read-only. Mutable variable 1 2 3 int a = 2 ; a = 3 ; std :: cout << \"a : \" << a << '\\n' ; Constants as a promise 1 2 3 const int b = 3 ; // b = 4; <- this fails. `b` is constant. std :: cout << \"b : \" << b << '\\n' ; const from mutable value 1 2 3 4 // `b2` can be initialized with any value, but cannot be changed after this. // This is possible, but makes it impossible to know b2 in compile-time. const int b2 = a ; std :: cout << \"b2 : \" << b2 << '\\n' ; Constant \"more constant than const\" 1 2 3 4 // `c` can only use values available at compile-time // `c` cannot be initialized with a mutable value constexpr int c = 4 ; std :: cout << \"c : \" << c << '\\n' ; Constant \"more constant than const\" 1 2 3 4 // `c` can only use values available at compile-time // `c` cannot be initialized with a mutable value constexpr int c = 4 ; std :: cout << \"c : \" << c << '\\n' ; Creating arrays from mutable value 1 2 3 // The compiler needs to know the size at compile time // Impossible: // std::array<int,a> v1; Creating arrays from compile-time const values 1 2 3 // Sometimes possible, if b was not initialized with a mutable value std :: array < int , b > v2 = { 5 , 6 , 5 }; std :: cout << \"v2.size(): \" << v2 . size () << '\\n' ; Creating arrays from runtime const values 1 2 // Impossible (b2 depends on a variable): // std::array<int,b2> v2b; Creating arrays from compile-time constexpr values 1 2 3 // Always possible std :: array < int , c > v3 = { 7 , 8 , 7 , 8 }; std :: cout << \"v3.size(): \" << v3 . size () << '\\n' ; Share Snippets","title":"Constants"},{"location":"basic-syntax/data-types/fundamental-data-types/","text":"Fundamental Data Types Fundamental Data Types A fundamental or primitive type is a data type where the values that it can represent have a very simple nature (a number, a character or a truth-value); the primitive types are the most basic building blocks for any programming language and are the base for more complex data types. Basic types: bool 1 2 3 4 bool a = true ; std :: cout << \"bool a: \" << a << std :: endl ; std :: cout << \"sizeof(a): \" << sizeof ( a ) << \" bytes\" << std :: endl ; std :: cout << to_bitset ( a ) << std :: endl ; Basic types: int 1 2 3 4 int b = 25 ; std :: cout << \"int b: \" << b << std :: endl ; std :: cout << \"sizeof(b): \" << sizeof ( b ) << \" bytes\" << std :: endl ; std :: cout << to_bitset ( b ) << std :: endl ; Basic types: double 1 2 3 4 double c = 1.34 ; std :: cout << \"double c: \" << c << std :: endl ; std :: cout << \"sizeof(c): \" << sizeof ( c ) << \" bytes\" << std :: endl ; std :: cout << to_bitset ( c ) << std :: endl ; Basic types: char 1 2 3 4 char d = 'g' ; std :: cout << \"char d: \" << d << std :: endl ; std :: cout << \"sizeof(d): \" << sizeof ( d ) << \" bytes\" << std :: endl ; std :: cout << to_bitset ( d ) << std :: endl ; Integer implicit precision: long 1 2 3 4 long g = 25 ; std :: cout << \"long g: \" << g << std :: endl ; std :: cout << \"sizeof(g): \" << sizeof ( g ) << \" bytes\" << std :: endl ; std :: cout << to_bitset ( g ) << std :: endl ; Integer implicit precision: long long 1 2 3 4 long long h = 8271 ; std :: cout << \"long long h: \" << h << std :: endl ; std :: cout << \"sizeof(h): \" << sizeof ( h ) << \" bytes\" << std :: endl ; std :: cout << to_bitset ( h ) << std :: endl ; Unsigned integer - implicit precision: unsigned long 1 2 3 4 unsigned long i = 987312 ; std :: cout << \"unsigned long i: \" << i << std :: endl ; std :: cout << \"sizeof(i): \" << sizeof ( i ) << \" bytes\" << std :: endl ; std :: cout << to_bitset ( i ) << std :: endl ; Unsigned integer - implicit precision: unsigned long long 1 2 3 4 unsigned long long j = 4398271 ; std :: cout << \"unsigned long long j: \" << j << std :: endl ; std :: cout << \"sizeof(j): \" << sizeof ( j ) << \" bytes\" << std :: endl ; std :: cout << to_bitset ( j ) << std :: endl ; Integer explicit precision: int8_t 1 2 3 4 int8_t k = 25 ; std :: cout << \"int8_t k: \" << k << std :: endl ; std :: cout << \"sizeof(k): \" << sizeof ( k ) << \" bytes\" << std :: endl ; std :: cout << to_bitset ( k ) << std :: endl ; Integer explicit precision: int64_t 1 2 3 4 int64_t l = 542 ; std :: cout << \"int64_t l: \" << l << std :: endl ; std :: cout << \"sizeof(l): \" << sizeof ( l ) << \" bytes\" << std :: endl ; std :: cout << to_bitset ( l ) << std :: endl ; Floating point precision: float 1 2 3 4 float o = 25.54 ; std :: cout << \"float o: \" << o << std :: endl ; std :: cout << \"sizeof(o): \" << sizeof ( o ) << \" bytes\" << std :: endl ; std :: cout << to_bitset ( o ) << std :: endl ; Floating point precision: long double 1 2 3 4 long double p = 987312.325 ; std :: cout << \"long double p: \" << p << std :: endl ; std :: cout << \"sizeof(p): \" << sizeof ( p ) << \" bytes\" << std :: endl ; std :: cout << to_bitset ( p ) << std :: endl ; Basic types: char 1 2 3 4 char d = 'g' ; std :: cout << \"char d: \" << d << std :: endl ; std :: cout << \"sizeof(d): \" << sizeof ( d ) << \" bytes\" << std :: endl ; std :: cout << to_bitset ( d ) << std :: endl ; Share Snippets","title":"Fundamental Data Types"},{"location":"basic-syntax/data-types/fundamental-data-types/#fundamental-data-types","text":"Fundamental Data Types A fundamental or primitive type is a data type where the values that it can represent have a very simple nature (a number, a character or a truth-value); the primitive types are the most basic building blocks for any programming language and are the base for more complex data types. Basic types: bool 1 2 3 4 bool a = true ; std :: cout << \"bool a: \" << a << std :: endl ; std :: cout << \"sizeof(a): \" << sizeof ( a ) << \" bytes\" << std :: endl ; std :: cout << to_bitset ( a ) << std :: endl ; Basic types: int 1 2 3 4 int b = 25 ; std :: cout << \"int b: \" << b << std :: endl ; std :: cout << \"sizeof(b): \" << sizeof ( b ) << \" bytes\" << std :: endl ; std :: cout << to_bitset ( b ) << std :: endl ; Basic types: double 1 2 3 4 double c = 1.34 ; std :: cout << \"double c: \" << c << std :: endl ; std :: cout << \"sizeof(c): \" << sizeof ( c ) << \" bytes\" << std :: endl ; std :: cout << to_bitset ( c ) << std :: endl ; Basic types: char 1 2 3 4 char d = 'g' ; std :: cout << \"char d: \" << d << std :: endl ; std :: cout << \"sizeof(d): \" << sizeof ( d ) << \" bytes\" << std :: endl ; std :: cout << to_bitset ( d ) << std :: endl ; Integer implicit precision: long 1 2 3 4 long g = 25 ; std :: cout << \"long g: \" << g << std :: endl ; std :: cout << \"sizeof(g): \" << sizeof ( g ) << \" bytes\" << std :: endl ; std :: cout << to_bitset ( g ) << std :: endl ; Integer implicit precision: long long 1 2 3 4 long long h = 8271 ; std :: cout << \"long long h: \" << h << std :: endl ; std :: cout << \"sizeof(h): \" << sizeof ( h ) << \" bytes\" << std :: endl ; std :: cout << to_bitset ( h ) << std :: endl ; Unsigned integer - implicit precision: unsigned long 1 2 3 4 unsigned long i = 987312 ; std :: cout << \"unsigned long i: \" << i << std :: endl ; std :: cout << \"sizeof(i): \" << sizeof ( i ) << \" bytes\" << std :: endl ; std :: cout << to_bitset ( i ) << std :: endl ; Unsigned integer - implicit precision: unsigned long long 1 2 3 4 unsigned long long j = 4398271 ; std :: cout << \"unsigned long long j: \" << j << std :: endl ; std :: cout << \"sizeof(j): \" << sizeof ( j ) << \" bytes\" << std :: endl ; std :: cout << to_bitset ( j ) << std :: endl ; Integer explicit precision: int8_t 1 2 3 4 int8_t k = 25 ; std :: cout << \"int8_t k: \" << k << std :: endl ; std :: cout << \"sizeof(k): \" << sizeof ( k ) << \" bytes\" << std :: endl ; std :: cout << to_bitset ( k ) << std :: endl ; Integer explicit precision: int64_t 1 2 3 4 int64_t l = 542 ; std :: cout << \"int64_t l: \" << l << std :: endl ; std :: cout << \"sizeof(l): \" << sizeof ( l ) << \" bytes\" << std :: endl ; std :: cout << to_bitset ( l ) << std :: endl ; Floating point precision: float 1 2 3 4 float o = 25.54 ; std :: cout << \"float o: \" << o << std :: endl ; std :: cout << \"sizeof(o): \" << sizeof ( o ) << \" bytes\" << std :: endl ; std :: cout << to_bitset ( o ) << std :: endl ; Floating point precision: long double 1 2 3 4 long double p = 987312.325 ; std :: cout << \"long double p: \" << p << std :: endl ; std :: cout << \"sizeof(p): \" << sizeof ( p ) << \" bytes\" << std :: endl ; std :: cout << to_bitset ( p ) << std :: endl ; Basic types: char 1 2 3 4 char d = 'g' ; std :: cout << \"char d: \" << d << std :: endl ; std :: cout << \"sizeof(d): \" << sizeof ( d ) << \" bytes\" << std :: endl ; std :: cout << to_bitset ( d ) << std :: endl ; Share Snippets","title":"Fundamental Data Types"},{"location":"basic-syntax/data-types/operators/","text":"Operators Operators Operators are symbols that perform operations on variables and values. For example, + is an operator used for addition, while - is an operator used for subtraction. Operators 1 2 3 4 5 6 7 int n1 = 8 ; int n2 = 3 ; std :: cout << n1 << \" + \" << n2 << \": \" << n1 + n2 << '\\n' ; std :: cout << n1 << \" - \" << n2 << \": \" << n1 - n2 << '\\n' ; std :: cout << n1 << \" * \" << n2 << \": \" << n1 * n2 << '\\n' ; std :: cout << n1 << \" / \" << n2 << \": \" << n1 / n2 << '\\n' ; std :: cout << n1 << \" % \" << n2 << \": \" << n1 % n2 << '\\n' ; Operators for floating point types 1 2 3 4 5 6 double n3 = 8. ; double n4 = 3. ; std :: cout << n3 << \" + \" << n4 << \": \" << n3 + n4 << '\\n' ; std :: cout << n3 << \" - \" << n4 << \": \" << n3 - n4 << '\\n' ; std :: cout << n3 << \" * \" << n4 << \": \" << n3 * n4 << '\\n' ; std :: cout << n3 << \" / \" << n4 << \": \" << n3 / n4 << '\\n' ; There is no % for floating point types 1 2 std :: cout << \"fmod(\" << n3 << \", \" << n4 << \"): \" << fmod ( n3 , n4 ) << '\\n' ; // This won't work: std::cout << n3 << \" % \" << n4 << \": \" << n3 % n4 << '\\n'; Attribution operator 1 2 3 4 5 6 7 8 9 10 n1 += n2 ; // n1 = n1 + n2; std :: cout << \"n1 after += is \" << n1 << '\\n' ; n1 -= n2 ; std :: cout << \"n1 after -= is \" << n1 << '\\n' ; n1 *= n2 ; std :: cout << \"n1 after *= is \" << n1 << '\\n' ; n1 /= n2 ; std :: cout << \"n1 after /= is \" << n1 << '\\n' ; n1 %= n2 ; std :: cout << \"n1 after %= is \" << n1 << '\\n' ; Postfixed increment/decrement 1 2 3 4 n1 ++ ; // or n1 += 1; // or n1 = n1 + 1; std :: cout << \"n1 after ++ is \" << n1 << '\\n' ; n1 -- ; std :: cout << \"n1 after -- is \" << n1 << '\\n' ; Prefixed increment 1 2 3 // same as n1 += 1; // or n1 = n1 + 1; ++ n1 ; std :: cout << \"n1 after ++ is \" << n1 << '\\n' ; Prefixed decrement 1 2 3 // same as n1 -= 1; // or n1 = n1 - 1; -- n1 ; std :: cout << \"n1 after -- is \" << n1 << '\\n' ; Postfixed inside an expression: use and increment 1 std :: cout << \"n1: \" << n1 ++ << '\\n' ; Prefixed inside an expression: increment and use 1 std :: cout << \"n1: \" << ++ n1 << '\\n' ; Share Snippets","title":"Operators"},{"location":"basic-syntax/data-types/operators/#operators","text":"Operators Operators are symbols that perform operations on variables and values. For example, + is an operator used for addition, while - is an operator used for subtraction. Operators 1 2 3 4 5 6 7 int n1 = 8 ; int n2 = 3 ; std :: cout << n1 << \" + \" << n2 << \": \" << n1 + n2 << '\\n' ; std :: cout << n1 << \" - \" << n2 << \": \" << n1 - n2 << '\\n' ; std :: cout << n1 << \" * \" << n2 << \": \" << n1 * n2 << '\\n' ; std :: cout << n1 << \" / \" << n2 << \": \" << n1 / n2 << '\\n' ; std :: cout << n1 << \" % \" << n2 << \": \" << n1 % n2 << '\\n' ; Operators for floating point types 1 2 3 4 5 6 double n3 = 8. ; double n4 = 3. ; std :: cout << n3 << \" + \" << n4 << \": \" << n3 + n4 << '\\n' ; std :: cout << n3 << \" - \" << n4 << \": \" << n3 - n4 << '\\n' ; std :: cout << n3 << \" * \" << n4 << \": \" << n3 * n4 << '\\n' ; std :: cout << n3 << \" / \" << n4 << \": \" << n3 / n4 << '\\n' ; There is no % for floating point types 1 2 std :: cout << \"fmod(\" << n3 << \", \" << n4 << \"): \" << fmod ( n3 , n4 ) << '\\n' ; // This won't work: std::cout << n3 << \" % \" << n4 << \": \" << n3 % n4 << '\\n'; Attribution operator 1 2 3 4 5 6 7 8 9 10 n1 += n2 ; // n1 = n1 + n2; std :: cout << \"n1 after += is \" << n1 << '\\n' ; n1 -= n2 ; std :: cout << \"n1 after -= is \" << n1 << '\\n' ; n1 *= n2 ; std :: cout << \"n1 after *= is \" << n1 << '\\n' ; n1 /= n2 ; std :: cout << \"n1 after /= is \" << n1 << '\\n' ; n1 %= n2 ; std :: cout << \"n1 after %= is \" << n1 << '\\n' ; Postfixed increment/decrement 1 2 3 4 n1 ++ ; // or n1 += 1; // or n1 = n1 + 1; std :: cout << \"n1 after ++ is \" << n1 << '\\n' ; n1 -- ; std :: cout << \"n1 after -- is \" << n1 << '\\n' ; Prefixed increment 1 2 3 // same as n1 += 1; // or n1 = n1 + 1; ++ n1 ; std :: cout << \"n1 after ++ is \" << n1 << '\\n' ; Prefixed decrement 1 2 3 // same as n1 -= 1; // or n1 = n1 - 1; -- n1 ; std :: cout << \"n1 after -- is \" << n1 << '\\n' ; Postfixed inside an expression: use and increment 1 std :: cout << \"n1: \" << n1 ++ << '\\n' ; Prefixed inside an expression: increment and use 1 std :: cout << \"n1: \" << ++ n1 << '\\n' ; Share Snippets","title":"Operators"},{"location":"basic-syntax/files/file-streams/","text":"File streams File streams C++ provides file streams to perform output and input of characters to/from files. These classes are derived directly or indirectly from the classes std::istream and std::ostream. We have already used objects whose types were these classes: std::cin is an object of class std::istream and std::cout is an object of class ostream. We can use our file streams the same way we are already used to use std::cin and std::cout , with the only difference that we have to associate these streams with physical files.: Create a vector of numbers 1 2 3 4 5 6 std :: vector < int > numbers ; constexpr size_t n = 15 ; numbers . resize ( n ); for ( size_t i = 0 ; i < n ; ++ i ) { numbers [ i ] = i * 1000 + 1 ; } Save numbers in text file 1 2 3 4 5 std :: ofstream fout ( \"numbers.txt\" ); for ( int number : numbers ) { fout << number << \" \" ; } fout . close (); Load numbers from text file 1 2 3 4 5 6 7 8 9 10 std :: vector < int > m_numbers ; std :: ifstream fin ( \"numbers.txt\" ); do { int x ; fin >> x ; if ( fin ) { m_numbers . emplace_back ( x ); } } while ( fin ); fin . close (); Print numbers from file 1 2 3 4 5 6 7 8 for ( const auto & number : numbers ) { std :: cout << number << \" \" ; } std :: cout << '\\n' ; for ( const auto & number : m_numbers ) { std :: cout << number << \" \" ; } std :: cout << '\\n' ; Save numbers in binary file 1 2 3 4 5 6 7 fout . open ( \"numbers.bin\" , std :: ios :: binary ); for ( int & number : numbers ) { char * pointer_to_number = ( char * ) & number ; size_t bytes_per_number = sizeof ( number ); fout . write ( pointer_to_number , bytes_per_number ); } fout . close (); Load numbers from binary file 1 2 3 4 5 6 7 8 9 10 m_numbers . clear (); fin . open ( \"numbers.bin\" , std :: ios :: binary ); for ( size_t i = 0 ; i < numbers . size (); ++ i ) { int x ; char * pointer_to_number = ( char * ) & x ; size_t bytes_per_number = sizeof ( x ); fin . read ( pointer_to_number , bytes_per_number ); m_numbers . emplace_back ( x ); } fin . close (); Print numbers from file 1 2 3 4 5 6 7 8 for ( const auto & number : numbers ) { std :: cout << number << \" \" ; } std :: cout << '\\n' ; for ( const auto & number : m_numbers ) { std :: cout << number << \" \" ; } std :: cout << '\\n' ; Compare file sizes 1 2 3 4 std :: cout << \"File size (text): \" << std :: filesystem :: file_size ( \"numbers.txt\" ) << \" bytes \\n \" ; std :: cout << \"File size (binary): \" << std :: filesystem :: file_size ( \"numbers.bin\" ) << \" bytes \\n \" ; Share Snippets","title":"File streams"},{"location":"basic-syntax/files/file-streams/#file-streams","text":"File streams C++ provides file streams to perform output and input of characters to/from files. These classes are derived directly or indirectly from the classes std::istream and std::ostream. We have already used objects whose types were these classes: std::cin is an object of class std::istream and std::cout is an object of class ostream. We can use our file streams the same way we are already used to use std::cin and std::cout , with the only difference that we have to associate these streams with physical files.: Create a vector of numbers 1 2 3 4 5 6 std :: vector < int > numbers ; constexpr size_t n = 15 ; numbers . resize ( n ); for ( size_t i = 0 ; i < n ; ++ i ) { numbers [ i ] = i * 1000 + 1 ; } Save numbers in text file 1 2 3 4 5 std :: ofstream fout ( \"numbers.txt\" ); for ( int number : numbers ) { fout << number << \" \" ; } fout . close (); Load numbers from text file 1 2 3 4 5 6 7 8 9 10 std :: vector < int > m_numbers ; std :: ifstream fin ( \"numbers.txt\" ); do { int x ; fin >> x ; if ( fin ) { m_numbers . emplace_back ( x ); } } while ( fin ); fin . close (); Print numbers from file 1 2 3 4 5 6 7 8 for ( const auto & number : numbers ) { std :: cout << number << \" \" ; } std :: cout << '\\n' ; for ( const auto & number : m_numbers ) { std :: cout << number << \" \" ; } std :: cout << '\\n' ; Save numbers in binary file 1 2 3 4 5 6 7 fout . open ( \"numbers.bin\" , std :: ios :: binary ); for ( int & number : numbers ) { char * pointer_to_number = ( char * ) & number ; size_t bytes_per_number = sizeof ( number ); fout . write ( pointer_to_number , bytes_per_number ); } fout . close (); Load numbers from binary file 1 2 3 4 5 6 7 8 9 10 m_numbers . clear (); fin . open ( \"numbers.bin\" , std :: ios :: binary ); for ( size_t i = 0 ; i < numbers . size (); ++ i ) { int x ; char * pointer_to_number = ( char * ) & x ; size_t bytes_per_number = sizeof ( x ); fin . read ( pointer_to_number , bytes_per_number ); m_numbers . emplace_back ( x ); } fin . close (); Print numbers from file 1 2 3 4 5 6 7 8 for ( const auto & number : numbers ) { std :: cout << number << \" \" ; } std :: cout << '\\n' ; for ( const auto & number : m_numbers ) { std :: cout << number << \" \" ; } std :: cout << '\\n' ; Compare file sizes 1 2 3 4 std :: cout << \"File size (text): \" << std :: filesystem :: file_size ( \"numbers.txt\" ) << \" bytes \\n \" ; std :: cout << \"File size (binary): \" << std :: filesystem :: file_size ( \"numbers.bin\" ) << \" bytes \\n \" ; Share Snippets","title":"File streams"},{"location":"basic-syntax/files/filesystem/","text":"Filesystem Filesystem The Filesystem library provides facilities for performing operations on file systems and their components, such as paths, regular files, and directories. The filesystem library was originally developed as boost.filesystem , was published as the technical specification ISO/IEC TS 18822:2015, and finally merged to ISO C++ as of C++17. The boost implementation is currently available on more compilers and platforms than the C++17 library. Find package 1 2 3 4 # Use CMake script to identify if Filesystem library is available # This will look for the headers <filesystem> or <experimental/filesystem> # See CMake Functions find_package ( Filesystem ) Find boost.filesystem if C++17 is not available 1 2 3 4 # See https://cmake.org/cmake/help/latest/module/FindBoost.html if ( NOT Filesystem_FOUND ) find_package ( Boost COMPONENTS filesystem ) endif () Use C++17 filesystem or Boost.Filesystem 1 2 3 4 5 6 7 8 9 10 add_executable ( filesystem_manage filesystem.cpp ) if ( Filesystem_FOUND ) target_link_libraries ( filesystem_manage PRIVATE std::filesystem ) target_compile_definitions ( filesystem_manage PRIVATE -DCXX_FILESYSTEM_HEADER=< ${ CXX_FILESYSTEM_HEADER } > ) target_compile_definitions ( filesystem_manage PRIVATE -DCXX_FILESYSTEM_NAMESPACE= ${ CXX_FILESYSTEM_NAMESPACE } ) elseif ( Boost_FOUND ) target_link_libraries ( filesystem_manage PRIVATE Boost::filesystem ) target_compile_definitions ( filesystem_manage PRIVATE -DCXX_FILESYSTEM_HEADER=<boost/filesystem.hpp> ) target_compile_definitions ( filesystem_manage PRIVATE -DCXX_FILESYSTEM_NAMESPACE=boost::filesystem ) endif () Include headers found by CMake 1 #include CXX_FILESYSTEM_HEADER Define fs as the namespace for the filesystem library 1 namespace fs = CXX_FILESYSTEM_NAMESPACE ; Writing to file 1 2 3 4 5 6 7 std :: ofstream fout ; fout . open ( \"example.txt\" ); if ( fout . is_open ()) { fout << \"This is a line. \\n \" ; fout << \"This is another line. \\n \" ; fout . close (); } Reading from file 1 2 3 4 5 6 7 8 std :: string line ; std :: ifstream fin ( \"example.txt\" ); if ( fin . is_open ()) { while ( getline ( fin , line )) { std :: cout << line << '\\n' ; } fin . close (); } Describing paths 1 2 3 4 5 fs :: path p1 { \"C: \\\\ \" }; fs :: path p2 { \"C: \\\\ Windows\" }; fs :: path p3 { L \"C: \\\\ Boost C++ \\u5E93 \" }; std :: cout << \"p2.string(): \" << p2 . string () << '\\n' ; std :: cout << \"p2.generic_string(): \" << p2 . generic_string () << '\\n' ; Portable paths 1 2 3 fs :: path root_p { \"/\" }; std :: cout << \"root_p.string(): \" << root_p . string () << '\\n' ; std :: cout << \"root_p.generic_string(): \" << root_p . generic_string () << '\\n' ; Path components 1 2 3 4 5 6 7 8 9 fs :: path p { \"C: \\\\ Windows \\\\ System \\\\ photo.jpg\" }; std :: cout << \"p.root_name(): \" << p . root_name () << '\\n' ; std :: cout << \"p.root_directory(): \" << p . root_directory () << '\\n' ; std :: cout << \"p.root_path(): \" << p . root_path () << '\\n' ; std :: cout << \"p.relative_path(): \" << p . relative_path () << '\\n' ; std :: cout << \"p.parent_path(): \" << p . parent_path () << '\\n' ; std :: cout << \"p.filename(): \" << p . filename () << '\\n' ; std :: cout << \"p.stem(): \" << p . stem () << '\\n' ; std :: cout << \"p.extension(): \" << p . extension () << '\\n' ; Relative paths 1 2 3 4 5 6 7 8 9 10 11 12 fs :: path pl { \"/Linux/System/photo.jpg\" }; std :: cout << \"pl: \" << pl << '\\n' ; std :: cout << \"pl.lexically_proximate( \\\" /Linux/ \\\" ): \" << pl . lexically_proximate ( \"/Linux/\" ) << '\\n' ; std :: cout << \"pl.root_name(): \" << pl . root_name () << '\\n' ; std :: cout << \"pl.root_directory(): \" << pl . root_directory () << '\\n' ; std :: cout << \"pl.root_path(): \" << pl . root_path () << '\\n' ; std :: cout << \"pl.relative_path(): \" << pl . relative_path () << '\\n' ; std :: cout << \"pl.parent_path(): \" << pl . parent_path () << '\\n' ; std :: cout << \"pl.filename(): \" << pl . filename () << '\\n' ; std :: cout << \"pl.stem(): \" << pl . stem () << '\\n' ; std :: cout << \"pl.extension(): \" << pl . extension () << '\\n' ; Iterate Path components 1 2 3 4 fs :: path p4 { \"C: \\\\ Windows \\\\ System \\\\ photo.jpg\" }; for ( const fs :: path & pp : p4 ) { std :: cout << pp << '\\n' ; } Iterate Path components 1 2 3 4 fs :: path p5 { \"/Linux/System/photo.jpg\" }; for ( const fs :: path & pp : p5 ) { std :: cout << pp << '\\n' ; } Concatenate paths 1 2 3 4 5 fs :: path p6 { \"/\" }; p6 /= \"Linux/System\" ; for ( const fs :: path & pp : p6 ) { std :: cout << pp << '\\n' ; } Files and Directories 1 2 3 4 5 6 7 fs :: path p7 { \"/\" }; try { fs :: file_status s = status ( p7 ); std :: cout << std :: boolalpha << fs :: is_directory ( s ) << '\\n' ; } catch ( fs :: filesystem_error const & e ) { std :: cerr << e . what () << '\\n' ; } File size 1 2 3 4 5 6 7 8 fs :: path p8 { \"C: \\\\ Windows \\\\ win.ini\" }; std :: error_code ec ; size_t filesize = fs :: file_size ( p8 , ec ); if ( ! ec ) { std :: cout << filesize << '\\n' ; } else { std :: cout << ec << '\\n' ; } Last time write 1 2 3 4 5 6 7 8 9 10 11 12 13 14 fs :: path p9 { \"C: \\\\ Windows \\\\ win.ini\" }; try { // Maybe unused as an example, because the next code snippet // is not portable fs :: file_time_type t = last_write_time ( p9 ); /* The following is not portable: * https://en.cppreference.com/w/cpp/filesystem/file_time_type std::time_t cftime = fs::file_time_type::clock::to_time_t(t); std::cout << cftime << '\\n'; */ ( void ) t ; // t is unused because the previous snippet is not portable } catch ( fs :: filesystem_error & e ) { std :: cout << e . what () << '\\n' ; } Retrieve total and remaining disk space 1 2 3 4 5 6 7 8 9 fs :: path p10 { \"/\" }; try { fs :: space_info s = space ( p10 ); std :: cout << \"s.capacity: \" << s . capacity << \" bytes\" << '\\n' ; std :: cout << \"s.free: \" << s . free << \" bytes\" << '\\n' ; std :: cout << \"s.available: \" << s . available << \" bytes\" << '\\n' ; } catch ( fs :: filesystem_error & e ) { std :: cerr << e . what () << '\\n' ; } Creating, renaming, and deleting directories 1 2 3 4 5 6 7 8 9 10 11 12 13 14 fs :: path p11 = fs :: current_path (); p /= \"test_directory\" ; try { if ( create_directory ( p11 )) { fs :: path p12 = fs :: current_path (); p12 /= \"test_directory2\" ; rename ( p , p12 ); fs :: remove ( p12 ); } else { std :: cout << \"The path could not be created\" << '\\n' ; } } catch ( fs :: filesystem_error & e ) { std :: cerr << e . what () << '\\n' ; } absolute path based on a file name 1 2 3 4 5 try { std :: cout << fs :: absolute ( \"photo.jpg\" ) << '\\n' ; } catch ( fs :: filesystem_error & e ) { std :: cerr << e . what () << '\\n' ; } Iterating over directory files 1 2 3 4 5 fs :: path p13 = fs :: current_path (); fs :: directory_iterator range { p13 }; for ( auto & dir_p : range ) { std :: cout << dir_p . path (). filename () << '\\n' ; } Iterating over directory files 1 2 3 4 5 fs :: path p13 = fs :: current_path (); fs :: directory_iterator range { p13 }; for ( auto & dir_p : range ) { std :: cout << dir_p . path (). filename () << '\\n' ; } File Streams from paths 1 2 3 4 fs :: path p15 = fs :: absolute ( \"example_text.txt\" ); std :: ofstream ofs { p15 }; ofs << \"Hello, world! \\n \" ; ofs << \"Bye, world! \\n \" ; Share Snippets","title":"Filesystem"},{"location":"basic-syntax/files/filesystem/#filesystem","text":"Filesystem The Filesystem library provides facilities for performing operations on file systems and their components, such as paths, regular files, and directories. The filesystem library was originally developed as boost.filesystem , was published as the technical specification ISO/IEC TS 18822:2015, and finally merged to ISO C++ as of C++17. The boost implementation is currently available on more compilers and platforms than the C++17 library. Find package 1 2 3 4 # Use CMake script to identify if Filesystem library is available # This will look for the headers <filesystem> or <experimental/filesystem> # See CMake Functions find_package ( Filesystem ) Find boost.filesystem if C++17 is not available 1 2 3 4 # See https://cmake.org/cmake/help/latest/module/FindBoost.html if ( NOT Filesystem_FOUND ) find_package ( Boost COMPONENTS filesystem ) endif () Use C++17 filesystem or Boost.Filesystem 1 2 3 4 5 6 7 8 9 10 add_executable ( filesystem_manage filesystem.cpp ) if ( Filesystem_FOUND ) target_link_libraries ( filesystem_manage PRIVATE std::filesystem ) target_compile_definitions ( filesystem_manage PRIVATE -DCXX_FILESYSTEM_HEADER=< ${ CXX_FILESYSTEM_HEADER } > ) target_compile_definitions ( filesystem_manage PRIVATE -DCXX_FILESYSTEM_NAMESPACE= ${ CXX_FILESYSTEM_NAMESPACE } ) elseif ( Boost_FOUND ) target_link_libraries ( filesystem_manage PRIVATE Boost::filesystem ) target_compile_definitions ( filesystem_manage PRIVATE -DCXX_FILESYSTEM_HEADER=<boost/filesystem.hpp> ) target_compile_definitions ( filesystem_manage PRIVATE -DCXX_FILESYSTEM_NAMESPACE=boost::filesystem ) endif () Include headers found by CMake 1 #include CXX_FILESYSTEM_HEADER Define fs as the namespace for the filesystem library 1 namespace fs = CXX_FILESYSTEM_NAMESPACE ; Writing to file 1 2 3 4 5 6 7 std :: ofstream fout ; fout . open ( \"example.txt\" ); if ( fout . is_open ()) { fout << \"This is a line. \\n \" ; fout << \"This is another line. \\n \" ; fout . close (); } Reading from file 1 2 3 4 5 6 7 8 std :: string line ; std :: ifstream fin ( \"example.txt\" ); if ( fin . is_open ()) { while ( getline ( fin , line )) { std :: cout << line << '\\n' ; } fin . close (); } Describing paths 1 2 3 4 5 fs :: path p1 { \"C: \\\\ \" }; fs :: path p2 { \"C: \\\\ Windows\" }; fs :: path p3 { L \"C: \\\\ Boost C++ \\u5E93 \" }; std :: cout << \"p2.string(): \" << p2 . string () << '\\n' ; std :: cout << \"p2.generic_string(): \" << p2 . generic_string () << '\\n' ; Portable paths 1 2 3 fs :: path root_p { \"/\" }; std :: cout << \"root_p.string(): \" << root_p . string () << '\\n' ; std :: cout << \"root_p.generic_string(): \" << root_p . generic_string () << '\\n' ; Path components 1 2 3 4 5 6 7 8 9 fs :: path p { \"C: \\\\ Windows \\\\ System \\\\ photo.jpg\" }; std :: cout << \"p.root_name(): \" << p . root_name () << '\\n' ; std :: cout << \"p.root_directory(): \" << p . root_directory () << '\\n' ; std :: cout << \"p.root_path(): \" << p . root_path () << '\\n' ; std :: cout << \"p.relative_path(): \" << p . relative_path () << '\\n' ; std :: cout << \"p.parent_path(): \" << p . parent_path () << '\\n' ; std :: cout << \"p.filename(): \" << p . filename () << '\\n' ; std :: cout << \"p.stem(): \" << p . stem () << '\\n' ; std :: cout << \"p.extension(): \" << p . extension () << '\\n' ; Relative paths 1 2 3 4 5 6 7 8 9 10 11 12 fs :: path pl { \"/Linux/System/photo.jpg\" }; std :: cout << \"pl: \" << pl << '\\n' ; std :: cout << \"pl.lexically_proximate( \\\" /Linux/ \\\" ): \" << pl . lexically_proximate ( \"/Linux/\" ) << '\\n' ; std :: cout << \"pl.root_name(): \" << pl . root_name () << '\\n' ; std :: cout << \"pl.root_directory(): \" << pl . root_directory () << '\\n' ; std :: cout << \"pl.root_path(): \" << pl . root_path () << '\\n' ; std :: cout << \"pl.relative_path(): \" << pl . relative_path () << '\\n' ; std :: cout << \"pl.parent_path(): \" << pl . parent_path () << '\\n' ; std :: cout << \"pl.filename(): \" << pl . filename () << '\\n' ; std :: cout << \"pl.stem(): \" << pl . stem () << '\\n' ; std :: cout << \"pl.extension(): \" << pl . extension () << '\\n' ; Iterate Path components 1 2 3 4 fs :: path p4 { \"C: \\\\ Windows \\\\ System \\\\ photo.jpg\" }; for ( const fs :: path & pp : p4 ) { std :: cout << pp << '\\n' ; } Iterate Path components 1 2 3 4 fs :: path p5 { \"/Linux/System/photo.jpg\" }; for ( const fs :: path & pp : p5 ) { std :: cout << pp << '\\n' ; } Concatenate paths 1 2 3 4 5 fs :: path p6 { \"/\" }; p6 /= \"Linux/System\" ; for ( const fs :: path & pp : p6 ) { std :: cout << pp << '\\n' ; } Files and Directories 1 2 3 4 5 6 7 fs :: path p7 { \"/\" }; try { fs :: file_status s = status ( p7 ); std :: cout << std :: boolalpha << fs :: is_directory ( s ) << '\\n' ; } catch ( fs :: filesystem_error const & e ) { std :: cerr << e . what () << '\\n' ; } File size 1 2 3 4 5 6 7 8 fs :: path p8 { \"C: \\\\ Windows \\\\ win.ini\" }; std :: error_code ec ; size_t filesize = fs :: file_size ( p8 , ec ); if ( ! ec ) { std :: cout << filesize << '\\n' ; } else { std :: cout << ec << '\\n' ; } Last time write 1 2 3 4 5 6 7 8 9 10 11 12 13 14 fs :: path p9 { \"C: \\\\ Windows \\\\ win.ini\" }; try { // Maybe unused as an example, because the next code snippet // is not portable fs :: file_time_type t = last_write_time ( p9 ); /* The following is not portable: * https://en.cppreference.com/w/cpp/filesystem/file_time_type std::time_t cftime = fs::file_time_type::clock::to_time_t(t); std::cout << cftime << '\\n'; */ ( void ) t ; // t is unused because the previous snippet is not portable } catch ( fs :: filesystem_error & e ) { std :: cout << e . what () << '\\n' ; } Retrieve total and remaining disk space 1 2 3 4 5 6 7 8 9 fs :: path p10 { \"/\" }; try { fs :: space_info s = space ( p10 ); std :: cout << \"s.capacity: \" << s . capacity << \" bytes\" << '\\n' ; std :: cout << \"s.free: \" << s . free << \" bytes\" << '\\n' ; std :: cout << \"s.available: \" << s . available << \" bytes\" << '\\n' ; } catch ( fs :: filesystem_error & e ) { std :: cerr << e . what () << '\\n' ; } Creating, renaming, and deleting directories 1 2 3 4 5 6 7 8 9 10 11 12 13 14 fs :: path p11 = fs :: current_path (); p /= \"test_directory\" ; try { if ( create_directory ( p11 )) { fs :: path p12 = fs :: current_path (); p12 /= \"test_directory2\" ; rename ( p , p12 ); fs :: remove ( p12 ); } else { std :: cout << \"The path could not be created\" << '\\n' ; } } catch ( fs :: filesystem_error & e ) { std :: cerr << e . what () << '\\n' ; } absolute path based on a file name 1 2 3 4 5 try { std :: cout << fs :: absolute ( \"photo.jpg\" ) << '\\n' ; } catch ( fs :: filesystem_error & e ) { std :: cerr << e . what () << '\\n' ; } Iterating over directory files 1 2 3 4 5 fs :: path p13 = fs :: current_path (); fs :: directory_iterator range { p13 }; for ( auto & dir_p : range ) { std :: cout << dir_p . path (). filename () << '\\n' ; } Iterating over directory files 1 2 3 4 5 fs :: path p13 = fs :: current_path (); fs :: directory_iterator range { p13 }; for ( auto & dir_p : range ) { std :: cout << dir_p . path (). filename () << '\\n' ; } File Streams from paths 1 2 3 4 fs :: path p15 = fs :: absolute ( \"example_text.txt\" ); std :: ofstream ofs { p15 }; ofs << \"Hello, world! \\n \" ; ofs << \"Bye, world! \\n \" ; Share Snippets","title":"Filesystem"},{"location":"basic-syntax/functions/build-script/","text":"Build script 1 2 3 add_executable ( functions functions.cpp ) add_executable ( lambda lambda.cpp )","title":"Build script"},{"location":"basic-syntax/functions/build-script/#build-script","text":"1 2 3 add_executable ( functions functions.cpp ) add_executable ( lambda lambda.cpp )","title":"Build script"},{"location":"basic-syntax/functions/function/","text":"Functions About functions These snippets are about the syntax for defining functions. They are not about how to achieve tasks with these functions. The tasks are just placeholders and the C++ STL already provides much better alternatives for most of these algorithms . Function declaration 1 void show_menu (); Function definition 1 2 3 4 5 6 void show_menu () { std :: cout << \"Options: \\n \" \"[0] Exit \\n \" \"[1] Sum \\n \" \"[2] Multiply \\n \" ; } Calling Function 1 2 3 4 // Call function 3 times for ( int i = 0 ; i < 3 ; ++ i ) { show_menu (); } Declare and define constexpr function - return value double 1 constexpr double pi () { return 3.14159265358979323846 ; } Call constexpr function 1 std :: cout << \"\u03c0 = \" << pi () << '\\n' ; Declare and define function with one parameter 1 double power_three ( double x ) { return x * x * x ; } Call function with one parameter 1 std :: cout << \"4.4^3 = \" << power_three ( 4.4 ) << '\\n' ; Function with two parameters 1 2 3 4 5 6 7 double power ( double x , int y ) { double result = 1 ; for ( int i = 0 ; i < y ; ++ i ) { result *= x ; } return result ; } Call function with two parameters 1 std :: cout << \"4.4^5 = \" << power ( 4.4 , 5 ) << '\\n' ; Function with parameters by reference - No return 1 void times_two ( int & x ) { x *= 2 ; } Call function with parameters by reference 1 2 3 int x = 5 ; times_two ( x ); std :: cout << \"x = \" << x << '\\n' ; // 10 Parameters by reference and default parameter 1 2 3 4 5 6 // Always pass arrays by reference to avoid copying void increment_all ( std :: array < int , 1000 > & a , int increment_value = 1 ) { for ( int & x : a ) { x += increment_value ; } } Call function with parameter by reference 1 2 3 4 5 6 std :: array < int , 1000 > v {}; increment_all ( v ); for ( int i : v ) { std :: cout << i << \" \" ; } std :: cout << '\\n' ; Call function without default parameter 1 2 3 4 5 increment_all ( v , 10 ); for ( int i : v ) { std :: cout << i << \" \" ; } std :: cout << '\\n' ; Parameters by const reference 1 2 3 4 5 6 7 8 9 10 11 // Parameters by constant reference // - We don't want to copy // - But we also don't want to change it bool has_element ( const std :: array < int , 1000 > & a , int element ) { for ( int x : a ) { if ( x == element ) { return true ; } } return false ; } Call function with parameters by const reference 1 2 3 4 5 6 7 8 9 std :: array < int , 1000 > v {}; for ( size_t i = 0 ; i < v . size (); ++ i ) { v [ i ] = i ; } if ( has_element ( v , 400 )) { std :: cout << \"Array v has the element 400\" << '\\n' ; } else { std :: cout << \"Array v doesn't have the element 400\" << '\\n' ; } \"Return\" two values by reference 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void minmax ( int a , int b , int c , int & minimum , int & maximum ) { if ( a > b ) { minimum = b ; maximum = a ; } else { minimum = a ; maximum = b ; } if ( c > maximum ) { maximum = c ; } if ( c < minimum ) { minimum = c ; } // values of external variables are set } \"Returning\" two values by reference 1 2 3 4 int maximum ; int minimum ; minmax ( 5 , 3 , 8 , minimum , maximum ); std :: cout << \"Minimum and maximum: \" << minimum << \", \" << maximum << '\\n' ; Return two values with a pair 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 std :: pair < int , int > minmax ( int a , int b , int c ) { int minimum ; int maximum ; if ( a > b ) { minimum = b ; maximum = a ; } else { minimum = a ; maximum = b ; } if ( c > maximum ) { maximum = c ; } if ( c < minimum ) { minimum = c ; } return std :: make_pair ( minimum , maximum ); } Returning two values with a pair 1 2 std :: pair < int , int > p = minmax ( 5 , 3 , 8 ); std :: cout << \"Minimum and maximum: \" << p . first << \", \" << p . second << '\\n' ; Returning two values with structured binding 1 2 auto [ m1 , m2 ] = minmax ( 5 , 3 , 8 ); std :: cout << \"Minimum and maximum: \" << m1 << \", \" << m2 << '\\n' ; Returning two values with tie 1 2 std :: tie ( m1 , m2 ) = minmax ( 5 , 3 , 8 ); std :: cout << \"Minimum and maximum: \" << m1 << \", \" << m2 << '\\n' ; \"Return\" three values by reference 1 2 3 4 5 6 7 8 9 10 11 12 void sort ( int a , int b , int c , int & minimum , int & middle , int & maximum ) { minmax ( a , b , c , minimum , maximum ); if ( a != minimum && a != maximum ) { middle = a ; return ; } if ( b != minimum && b != maximum ) { middle = b ; return ; } middle = c ; } \"Returning\" three values by reference 1 2 3 4 5 6 int minimum ; int middle ; int maximum ; sort ( 5 , 3 , 8 , minimum , middle , maximum ); std :: cout << \"Sorting 5, 3, 8 = \" << minimum << \", \" << middle << \", \" << maximum << '\\n' ; Return three values with a tuple 1 2 3 4 5 6 7 8 9 10 std :: tuple < int , int , int > sort ( int a , int b , int c ) { auto [ minimum , maximum ] = minmax ( a , b , c ); if ( a != minimum && a != maximum ) { return std :: make_tuple ( minimum , a , maximum ); } if ( b != minimum && b != maximum ) { return std :: make_tuple ( minimum , b , maximum ); } return std :: make_tuple ( minimum , b , maximum ); } Returning three values with a tuple 1 2 3 std :: tuple < int , int , int > t = sort ( 5 , 3 , 8 ); std :: cout << \"Sorting 5, 3, 8: \" << get < 0 > ( t ) << \", \" << get < 1 > ( t ) << \", \" << get < 2 > ( t ) << '\\n' ; Returning three values with structured binding 1 2 3 auto [ minimum3 , middle3 , maximum3 ] = sort ( 5 , 3 , 8 ); std :: cout << \"Sorting 5, 3, 8: \" << minimum3 << \", \" << middle3 << \", \" << maximum3 << '\\n' ; Returning three values with tie 1 2 3 std :: tie ( minimum3 , middle3 , maximum3 ) = sort ( 5 , 3 , 8 ); std :: cout << \"Sorting 5, 3, 8: \" << minimum3 << \", \" << middle3 << \", \" << maximum3 << '\\n' ; Parameter by pointer by value 1 2 3 4 5 6 7 // Pass pointers by value: https://youtu.be/xGDLkt-jBJ4?t=869 // As small as the reference and no other level of indirection void pointer_to_cube ( std :: shared_ptr < int > p ) { if ( p ) { * p = * p * * p * * p ; } } Parameter by pointer by value 1 2 3 std :: shared_ptr < int > ptr = std :: make_shared < int > ( 5 ); pointer_to_cube ( ptr ); std :: cout << \"5^3 = \" << * ptr << '\\n' ; Iterative Fibonacci function 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int fibonacci_iterative ( int n ) { if ( n == 0 ) { return 0 ; } else if ( n <= 2 ) { return 1 ; } int fib ; int fib_previous = 1 ; int fib_previous_2 = 1 ; for ( int i = 3 ; i <= n ; ++ i ) { fib = fib_previous + fib_previous_2 ; fib_previous_2 = fib_previous ; fib_previous = fib ; } return fib ; } Recursive Fibonacci function 1 2 3 4 5 6 7 int fibonacci_recursive ( int n ) { if ( n > 2 ) { return fibonacci_recursive ( n - 1 ) + fibonacci_recursive ( n - 2 ); } else { return n == 0 ? 0 : 1 ; } } Iterative and Recursive functions 1 2 std :: cout << \"fibonacci_iterative(6) = \" << fibonacci_iterative ( 6 ) << '\\n' ; std :: cout << \"fibonacci_recursive(6) = \" << fibonacci_recursive ( 6 ) << '\\n' ; Share Snippets","title":"Functions"},{"location":"basic-syntax/functions/function/#functions","text":"About functions These snippets are about the syntax for defining functions. They are not about how to achieve tasks with these functions. The tasks are just placeholders and the C++ STL already provides much better alternatives for most of these algorithms . Function declaration 1 void show_menu (); Function definition 1 2 3 4 5 6 void show_menu () { std :: cout << \"Options: \\n \" \"[0] Exit \\n \" \"[1] Sum \\n \" \"[2] Multiply \\n \" ; } Calling Function 1 2 3 4 // Call function 3 times for ( int i = 0 ; i < 3 ; ++ i ) { show_menu (); } Declare and define constexpr function - return value double 1 constexpr double pi () { return 3.14159265358979323846 ; } Call constexpr function 1 std :: cout << \"\u03c0 = \" << pi () << '\\n' ; Declare and define function with one parameter 1 double power_three ( double x ) { return x * x * x ; } Call function with one parameter 1 std :: cout << \"4.4^3 = \" << power_three ( 4.4 ) << '\\n' ; Function with two parameters 1 2 3 4 5 6 7 double power ( double x , int y ) { double result = 1 ; for ( int i = 0 ; i < y ; ++ i ) { result *= x ; } return result ; } Call function with two parameters 1 std :: cout << \"4.4^5 = \" << power ( 4.4 , 5 ) << '\\n' ; Function with parameters by reference - No return 1 void times_two ( int & x ) { x *= 2 ; } Call function with parameters by reference 1 2 3 int x = 5 ; times_two ( x ); std :: cout << \"x = \" << x << '\\n' ; // 10 Parameters by reference and default parameter 1 2 3 4 5 6 // Always pass arrays by reference to avoid copying void increment_all ( std :: array < int , 1000 > & a , int increment_value = 1 ) { for ( int & x : a ) { x += increment_value ; } } Call function with parameter by reference 1 2 3 4 5 6 std :: array < int , 1000 > v {}; increment_all ( v ); for ( int i : v ) { std :: cout << i << \" \" ; } std :: cout << '\\n' ; Call function without default parameter 1 2 3 4 5 increment_all ( v , 10 ); for ( int i : v ) { std :: cout << i << \" \" ; } std :: cout << '\\n' ; Parameters by const reference 1 2 3 4 5 6 7 8 9 10 11 // Parameters by constant reference // - We don't want to copy // - But we also don't want to change it bool has_element ( const std :: array < int , 1000 > & a , int element ) { for ( int x : a ) { if ( x == element ) { return true ; } } return false ; } Call function with parameters by const reference 1 2 3 4 5 6 7 8 9 std :: array < int , 1000 > v {}; for ( size_t i = 0 ; i < v . size (); ++ i ) { v [ i ] = i ; } if ( has_element ( v , 400 )) { std :: cout << \"Array v has the element 400\" << '\\n' ; } else { std :: cout << \"Array v doesn't have the element 400\" << '\\n' ; } \"Return\" two values by reference 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void minmax ( int a , int b , int c , int & minimum , int & maximum ) { if ( a > b ) { minimum = b ; maximum = a ; } else { minimum = a ; maximum = b ; } if ( c > maximum ) { maximum = c ; } if ( c < minimum ) { minimum = c ; } // values of external variables are set } \"Returning\" two values by reference 1 2 3 4 int maximum ; int minimum ; minmax ( 5 , 3 , 8 , minimum , maximum ); std :: cout << \"Minimum and maximum: \" << minimum << \", \" << maximum << '\\n' ; Return two values with a pair 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 std :: pair < int , int > minmax ( int a , int b , int c ) { int minimum ; int maximum ; if ( a > b ) { minimum = b ; maximum = a ; } else { minimum = a ; maximum = b ; } if ( c > maximum ) { maximum = c ; } if ( c < minimum ) { minimum = c ; } return std :: make_pair ( minimum , maximum ); } Returning two values with a pair 1 2 std :: pair < int , int > p = minmax ( 5 , 3 , 8 ); std :: cout << \"Minimum and maximum: \" << p . first << \", \" << p . second << '\\n' ; Returning two values with structured binding 1 2 auto [ m1 , m2 ] = minmax ( 5 , 3 , 8 ); std :: cout << \"Minimum and maximum: \" << m1 << \", \" << m2 << '\\n' ; Returning two values with tie 1 2 std :: tie ( m1 , m2 ) = minmax ( 5 , 3 , 8 ); std :: cout << \"Minimum and maximum: \" << m1 << \", \" << m2 << '\\n' ; \"Return\" three values by reference 1 2 3 4 5 6 7 8 9 10 11 12 void sort ( int a , int b , int c , int & minimum , int & middle , int & maximum ) { minmax ( a , b , c , minimum , maximum ); if ( a != minimum && a != maximum ) { middle = a ; return ; } if ( b != minimum && b != maximum ) { middle = b ; return ; } middle = c ; } \"Returning\" three values by reference 1 2 3 4 5 6 int minimum ; int middle ; int maximum ; sort ( 5 , 3 , 8 , minimum , middle , maximum ); std :: cout << \"Sorting 5, 3, 8 = \" << minimum << \", \" << middle << \", \" << maximum << '\\n' ; Return three values with a tuple 1 2 3 4 5 6 7 8 9 10 std :: tuple < int , int , int > sort ( int a , int b , int c ) { auto [ minimum , maximum ] = minmax ( a , b , c ); if ( a != minimum && a != maximum ) { return std :: make_tuple ( minimum , a , maximum ); } if ( b != minimum && b != maximum ) { return std :: make_tuple ( minimum , b , maximum ); } return std :: make_tuple ( minimum , b , maximum ); } Returning three values with a tuple 1 2 3 std :: tuple < int , int , int > t = sort ( 5 , 3 , 8 ); std :: cout << \"Sorting 5, 3, 8: \" << get < 0 > ( t ) << \", \" << get < 1 > ( t ) << \", \" << get < 2 > ( t ) << '\\n' ; Returning three values with structured binding 1 2 3 auto [ minimum3 , middle3 , maximum3 ] = sort ( 5 , 3 , 8 ); std :: cout << \"Sorting 5, 3, 8: \" << minimum3 << \", \" << middle3 << \", \" << maximum3 << '\\n' ; Returning three values with tie 1 2 3 std :: tie ( minimum3 , middle3 , maximum3 ) = sort ( 5 , 3 , 8 ); std :: cout << \"Sorting 5, 3, 8: \" << minimum3 << \", \" << middle3 << \", \" << maximum3 << '\\n' ; Parameter by pointer by value 1 2 3 4 5 6 7 // Pass pointers by value: https://youtu.be/xGDLkt-jBJ4?t=869 // As small as the reference and no other level of indirection void pointer_to_cube ( std :: shared_ptr < int > p ) { if ( p ) { * p = * p * * p * * p ; } } Parameter by pointer by value 1 2 3 std :: shared_ptr < int > ptr = std :: make_shared < int > ( 5 ); pointer_to_cube ( ptr ); std :: cout << \"5^3 = \" << * ptr << '\\n' ; Iterative Fibonacci function 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int fibonacci_iterative ( int n ) { if ( n == 0 ) { return 0 ; } else if ( n <= 2 ) { return 1 ; } int fib ; int fib_previous = 1 ; int fib_previous_2 = 1 ; for ( int i = 3 ; i <= n ; ++ i ) { fib = fib_previous + fib_previous_2 ; fib_previous_2 = fib_previous ; fib_previous = fib ; } return fib ; } Recursive Fibonacci function 1 2 3 4 5 6 7 int fibonacci_recursive ( int n ) { if ( n > 2 ) { return fibonacci_recursive ( n - 1 ) + fibonacci_recursive ( n - 2 ); } else { return n == 0 ? 0 : 1 ; } } Iterative and Recursive functions 1 2 std :: cout << \"fibonacci_iterative(6) = \" << fibonacci_iterative ( 6 ) << '\\n' ; std :: cout << \"fibonacci_recursive(6) = \" << fibonacci_recursive ( 6 ) << '\\n' ; Share Snippets","title":"Functions"},{"location":"basic-syntax/functions/lambda/","text":"Lambda Functions Lambda functions A lambda is a convenient way of defining an anonymous function object right at the location where it's invoked. Typically lambdas are used to encapsulate a few lines of code that are passed to algorithms to customize their behavior. Defining a functor manually 1 2 3 4 class add { public : double operator ()( double left , double right ) { return left + right ; } }; Calling a functor 1 2 3 // Function objects overload operator() so they act like functions double number = add ()( 2 , 3 ); std :: cout << number << '\\n' ; Keeping inline lambda functions in variables 1 2 // Automatically creates a functor for the function auto function = []() { std :: cout << \"Hello, world! \" ; }; Calling a lambda 1 function (); Lambdas as arguments 1 2 3 4 // Sort in increasing order std :: vector < int > v { 4 , 3 , 1 , 2 }; auto comparison = []( int a , int b ) { return a < b ; }; std :: sort ( v . begin (), v . end (), comparison ); Lambdas in function calls 1 2 3 4 5 6 // Sort in decreasing order std :: sort ( v . begin (), v . end (), []( int a , int b ) { return a > b ; }); // Print each element std :: for_each ( v . begin (), v . end (), []( const double c ) { std :: cout << c << \" \" ; }); std :: cout << '\\n' ; Store lambda as std::function 1 2 std :: function < int ( int ) > func = []( int i ) { return i + 10 ; }; std :: cout << \"func(6): \" << func ( 6 ) << '\\n' ; Capturing values in lambda function 1 2 3 4 // These values are external to the function parameters int x = 10 ; std :: function < int ( int ) > func2 = [ x ]( int i ) { return i + x ; }; std :: cout << \"func2(6): \" << func2 ( 6 ) << '\\n' ; Parameter type deduction 1 2 3 auto decreasing_comparison = []( auto a , auto b ) { return b < a ; }; std :: vector < double > v2 = { 3.6 , 3.2 , 7.5 , 2.4 }; std :: sort ( v . begin (), v . end (), decreasing_comparison ); Binding parameters to the function 1 2 3 4 5 6 7 8 9 // Creates new functions from existing functions // Create base function my_divide auto my_divide = []( double x , double y ) { return x / y ; }; std :: cout << \"my_divide(4,7): \" << my_divide ( 4 , 7 ) << '\\n' ; // Make x and y always 10 and 2 // Function fn_five has no parameters now auto fn_five = std :: bind ( my_divide , 10 , 2 ); std :: cout << \"fn_five(): \" << fn_five () << '\\n' ; Bind a single parameter 1 2 3 4 // Function has only one parameter now auto fn_half = std :: bind ( my_divide , std :: placeholders :: _1 , 2 ); // returns x/2 std :: cout << \"fn_half(10): \" << fn_half ( 10 ) << '\\n' ; Keep parameters and convert the return type 1 2 3 auto fn_floor = std :: bind < int > ( my_divide , std :: placeholders :: _1 , std :: placeholders :: _2 ); // returns int(x/y) std :: cout << \"fn_floor(10,2): \" << fn_floor ( 13 , 2 ) << '\\n' ; Sorting with lambdas 1 2 3 4 std :: vector < int > myvector = { 32 , 71 , 12 , 45 , 26 , 80 , 53 , 33 }; std :: sort ( myvector . begin (), myvector . begin () + 4 ); // uses operator < std :: sort ( myvector . begin () + 4 , myvector . end (), []( auto x , auto y ) { return x > y ; }); // use operator > Checking conditions on all elements 1 2 3 4 5 6 // Many algorithms hardly make much sense without lambdas std :: vector < int > foo = { 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 }; auto is_odd = []( int i ) { return i % 2 ; }; if ( std :: all_of ( foo . begin (), foo . end (), is_odd )) { std :: cout << \"All the elements are odd numbers. \\n \" ; } Check any of elements 1 2 3 4 std :: array < int , 7 > foo2 = { 0 , 1 , -1 , 3 , -3 , 5 , -5 }; if ( std :: any_of ( foo2 . begin (), foo2 . end (), []( int i ) { return i < 0 ; })) { std :: cout << \"There are negative elements in the range. \\n \" ; } Check none of the element 1 2 3 4 std :: array < int , 8 > foo3 = { 1 , 2 , 4 , 8 , 16 , 32 , 64 , 128 }; if ( std :: none_of ( foo3 . begin (), foo3 . end (), []( int i ) { return i < 0 ; })) { std :: cout << \"There are no negative elements in the range. \\n \" ; } Find if element 1 2 3 4 std :: vector < int > v3 = { 10 , 25 , 40 , 55 }; auto it = std :: find_if ( v3 . begin (), v3 . end (), []( auto i ) { return i % 2 == 1 ; }); std :: cout << \"The first odd value is \" << * it << '\\n' ; Removing if element 1 2 3 std :: vector < int > v4 { 1 , 2 , 3 , 4 , 5 , 6 , 7 }; auto last = remove_if ( v4 . begin (), v4 . end (), []( int n ) { return n < 6 ; }); v4 . erase ( last , v4 . end ()); Removing if element 1 2 3 x = 5 ; v4 . erase ( remove_if ( v4 . begin (), v4 . end (), [ x ]( int n ) { return n < x ; }), v4 . end ()); Counting if elements 1 2 3 4 5 std :: vector < int > v5 ( 9 ); std :: iota ( v5 . begin (), v5 . end (), 1 ); int mycount = std :: count_if ( v5 . begin (), v5 . end (), []( int i ) { return (( i % 2 ) == 1 ); }); std :: cout << \"My vector contains \" << mycount << \" odd values. \\n \" ; Replacing if match 1 2 3 4 std :: vector < int > v6 ( 9 ); std :: iota ( v6 . begin (), v6 . end (), 1 ); replace_if ( v6 . begin (), v6 . end (), []( int i ) { return (( i % 2 ) == 1 ); }, 0 ); Share Snippets","title":"Lambdas"},{"location":"basic-syntax/functions/lambda/#lambda-functions","text":"Lambda functions A lambda is a convenient way of defining an anonymous function object right at the location where it's invoked. Typically lambdas are used to encapsulate a few lines of code that are passed to algorithms to customize their behavior. Defining a functor manually 1 2 3 4 class add { public : double operator ()( double left , double right ) { return left + right ; } }; Calling a functor 1 2 3 // Function objects overload operator() so they act like functions double number = add ()( 2 , 3 ); std :: cout << number << '\\n' ; Keeping inline lambda functions in variables 1 2 // Automatically creates a functor for the function auto function = []() { std :: cout << \"Hello, world! \" ; }; Calling a lambda 1 function (); Lambdas as arguments 1 2 3 4 // Sort in increasing order std :: vector < int > v { 4 , 3 , 1 , 2 }; auto comparison = []( int a , int b ) { return a < b ; }; std :: sort ( v . begin (), v . end (), comparison ); Lambdas in function calls 1 2 3 4 5 6 // Sort in decreasing order std :: sort ( v . begin (), v . end (), []( int a , int b ) { return a > b ; }); // Print each element std :: for_each ( v . begin (), v . end (), []( const double c ) { std :: cout << c << \" \" ; }); std :: cout << '\\n' ; Store lambda as std::function 1 2 std :: function < int ( int ) > func = []( int i ) { return i + 10 ; }; std :: cout << \"func(6): \" << func ( 6 ) << '\\n' ; Capturing values in lambda function 1 2 3 4 // These values are external to the function parameters int x = 10 ; std :: function < int ( int ) > func2 = [ x ]( int i ) { return i + x ; }; std :: cout << \"func2(6): \" << func2 ( 6 ) << '\\n' ; Parameter type deduction 1 2 3 auto decreasing_comparison = []( auto a , auto b ) { return b < a ; }; std :: vector < double > v2 = { 3.6 , 3.2 , 7.5 , 2.4 }; std :: sort ( v . begin (), v . end (), decreasing_comparison ); Binding parameters to the function 1 2 3 4 5 6 7 8 9 // Creates new functions from existing functions // Create base function my_divide auto my_divide = []( double x , double y ) { return x / y ; }; std :: cout << \"my_divide(4,7): \" << my_divide ( 4 , 7 ) << '\\n' ; // Make x and y always 10 and 2 // Function fn_five has no parameters now auto fn_five = std :: bind ( my_divide , 10 , 2 ); std :: cout << \"fn_five(): \" << fn_five () << '\\n' ; Bind a single parameter 1 2 3 4 // Function has only one parameter now auto fn_half = std :: bind ( my_divide , std :: placeholders :: _1 , 2 ); // returns x/2 std :: cout << \"fn_half(10): \" << fn_half ( 10 ) << '\\n' ; Keep parameters and convert the return type 1 2 3 auto fn_floor = std :: bind < int > ( my_divide , std :: placeholders :: _1 , std :: placeholders :: _2 ); // returns int(x/y) std :: cout << \"fn_floor(10,2): \" << fn_floor ( 13 , 2 ) << '\\n' ; Sorting with lambdas 1 2 3 4 std :: vector < int > myvector = { 32 , 71 , 12 , 45 , 26 , 80 , 53 , 33 }; std :: sort ( myvector . begin (), myvector . begin () + 4 ); // uses operator < std :: sort ( myvector . begin () + 4 , myvector . end (), []( auto x , auto y ) { return x > y ; }); // use operator > Checking conditions on all elements 1 2 3 4 5 6 // Many algorithms hardly make much sense without lambdas std :: vector < int > foo = { 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 }; auto is_odd = []( int i ) { return i % 2 ; }; if ( std :: all_of ( foo . begin (), foo . end (), is_odd )) { std :: cout << \"All the elements are odd numbers. \\n \" ; } Check any of elements 1 2 3 4 std :: array < int , 7 > foo2 = { 0 , 1 , -1 , 3 , -3 , 5 , -5 }; if ( std :: any_of ( foo2 . begin (), foo2 . end (), []( int i ) { return i < 0 ; })) { std :: cout << \"There are negative elements in the range. \\n \" ; } Check none of the element 1 2 3 4 std :: array < int , 8 > foo3 = { 1 , 2 , 4 , 8 , 16 , 32 , 64 , 128 }; if ( std :: none_of ( foo3 . begin (), foo3 . end (), []( int i ) { return i < 0 ; })) { std :: cout << \"There are no negative elements in the range. \\n \" ; } Find if element 1 2 3 4 std :: vector < int > v3 = { 10 , 25 , 40 , 55 }; auto it = std :: find_if ( v3 . begin (), v3 . end (), []( auto i ) { return i % 2 == 1 ; }); std :: cout << \"The first odd value is \" << * it << '\\n' ; Removing if element 1 2 3 std :: vector < int > v4 { 1 , 2 , 3 , 4 , 5 , 6 , 7 }; auto last = remove_if ( v4 . begin (), v4 . end (), []( int n ) { return n < 6 ; }); v4 . erase ( last , v4 . end ()); Removing if element 1 2 3 x = 5 ; v4 . erase ( remove_if ( v4 . begin (), v4 . end (), [ x ]( int n ) { return n < x ; }), v4 . end ()); Counting if elements 1 2 3 4 5 std :: vector < int > v5 ( 9 ); std :: iota ( v5 . begin (), v5 . end (), 1 ); int mycount = std :: count_if ( v5 . begin (), v5 . end (), []( int i ) { return (( i % 2 ) == 1 ); }); std :: cout << \"My vector contains \" << mycount << \" odd values. \\n \" ; Replacing if match 1 2 3 4 std :: vector < int > v6 ( 9 ); std :: iota ( v6 . begin (), v6 . end (), 1 ); replace_if ( v6 . begin (), v6 . end (), []( int i ) { return (( i % 2 ) == 1 ); }, 0 ); Share Snippets","title":"Lambda Functions"},{"location":"basic-syntax/input-output/format/","text":"Format About fmt / format fmt/format has been accepted into C++20 It has the best of printf and cout Many compilers don't implement it yet We still depend on <fmt/format.h> Find and link fmt library 1 2 3 4 5 6 7 8 9 10 11 find_package ( fmt QUIET ) if ( NOT fmt_FOUND ) FetchContent_Declare ( fmt GIT_REPOSITORY https://github.com/fmtlib/fmt GIT_TAG 8.1.1 ) FetchContent_MakeAvailable ( fmt ) endif () add_executable ( format format.cpp ) target_link_libraries ( format fmt::fmt ) Headers 1 2 3 4 5 #include <fmt/chrono.h> // time formatters #include <fmt/color.h> // color formatters #include <fmt/format.h> // main header #include <fmt/ostream.h> // ostream formatters #include <fmt/ranges.h> // range formatters Simple print 1 fmt :: print ( \"Hello, world! \\n \" ); Format to string 1 std :: cout << fmt :: format ( \"The answer is {}. \\n \" , 42 ); Format with order 1 std :: cout << fmt :: format ( \"I'd rather be {1} than {0}. \\n \" , \"right\" , \"happy\" ); Chrono literals 1 2 using namespace std :: literals :: chrono_literals ; fmt :: print ( \"Default format: {} {} \\n \" , 42 s , 100 ms ); strftime-like format 1 fmt :: print ( \"strftime-like format: {:%H:%M:%S} \\n \" , 3 h + 15 min + 30 s ); Format ranges 1 2 std :: vector < int > v = { 1 , 2 , 3 }; fmt :: print ( \"{} \\n \" , v ); Format tuple 1 2 std :: tuple < char , int , float > t2 { 'a' , 1 , 2.0f }; fmt :: print ( \"{}\" , t2 ); Color support 1 2 3 4 5 fmt :: print ( fg ( fmt :: color :: crimson ) | fmt :: emphasis :: bold , \"Hello, {}! \\n \" , \"world\" ); auto style = fg ( fmt :: color :: floral_white ) | bg ( fmt :: color :: slate_gray ) | fmt :: emphasis :: underline ; fmt :: print ( style , \"Hello, {}! \\n \" , \"\u043c\u0438\u0440\" ); UTF-8 1 print ( fg ( fmt :: color :: steel_blue ) | fmt :: emphasis :: italic , \"Hello, {}! \\n \" , \"\u4e16\u754c\" ); Format to memory 1 2 3 std :: vector < char > out ; fmt :: format_to ( std :: back_inserter ( out ), \"For a moment, {} happened.\" , \"nothing\" ); fmt :: print ( \"{}\" , out . data ()); Share Snippets","title":"Format"},{"location":"basic-syntax/input-output/format/#format","text":"About fmt / format fmt/format has been accepted into C++20 It has the best of printf and cout Many compilers don't implement it yet We still depend on <fmt/format.h> Find and link fmt library 1 2 3 4 5 6 7 8 9 10 11 find_package ( fmt QUIET ) if ( NOT fmt_FOUND ) FetchContent_Declare ( fmt GIT_REPOSITORY https://github.com/fmtlib/fmt GIT_TAG 8.1.1 ) FetchContent_MakeAvailable ( fmt ) endif () add_executable ( format format.cpp ) target_link_libraries ( format fmt::fmt ) Headers 1 2 3 4 5 #include <fmt/chrono.h> // time formatters #include <fmt/color.h> // color formatters #include <fmt/format.h> // main header #include <fmt/ostream.h> // ostream formatters #include <fmt/ranges.h> // range formatters Simple print 1 fmt :: print ( \"Hello, world! \\n \" ); Format to string 1 std :: cout << fmt :: format ( \"The answer is {}. \\n \" , 42 ); Format with order 1 std :: cout << fmt :: format ( \"I'd rather be {1} than {0}. \\n \" , \"right\" , \"happy\" ); Chrono literals 1 2 using namespace std :: literals :: chrono_literals ; fmt :: print ( \"Default format: {} {} \\n \" , 42 s , 100 ms ); strftime-like format 1 fmt :: print ( \"strftime-like format: {:%H:%M:%S} \\n \" , 3 h + 15 min + 30 s ); Format ranges 1 2 std :: vector < int > v = { 1 , 2 , 3 }; fmt :: print ( \"{} \\n \" , v ); Format tuple 1 2 std :: tuple < char , int , float > t2 { 'a' , 1 , 2.0f }; fmt :: print ( \"{}\" , t2 ); Color support 1 2 3 4 5 fmt :: print ( fg ( fmt :: color :: crimson ) | fmt :: emphasis :: bold , \"Hello, {}! \\n \" , \"world\" ); auto style = fg ( fmt :: color :: floral_white ) | bg ( fmt :: color :: slate_gray ) | fmt :: emphasis :: underline ; fmt :: print ( style , \"Hello, {}! \\n \" , \"\u043c\u0438\u0440\" ); UTF-8 1 print ( fg ( fmt :: color :: steel_blue ) | fmt :: emphasis :: italic , \"Hello, {}! \\n \" , \"\u4e16\u754c\" ); Format to memory 1 2 3 std :: vector < char > out ; fmt :: format_to ( std :: back_inserter ( out ), \"For a moment, {} happened.\" , \"nothing\" ); fmt :: print ( \"{}\" , out . data ()); Share Snippets","title":"Format"},{"location":"basic-syntax/input-output/hello-world/","text":"Hello World Your first C++ program CMakeLists.txt 1 2 3 4 5 6 #include <iostream> int main () { std :: cout << \"Hello world\" << std :: endl ; return 0 ; } 1 add_executable ( hello_world hello_world.cpp )","title":"Hello World"},{"location":"basic-syntax/input-output/hello-world/#hello-world","text":"Your first C++ program CMakeLists.txt 1 2 3 4 5 6 #include <iostream> int main () { std :: cout << \"Hello world\" << std :: endl ; return 0 ; } 1 add_executable ( hello_world hello_world.cpp )","title":"Hello World"},{"location":"basic-syntax/input-output/input/","text":"Input Headers 1 #include <iostream> User input 1 2 3 int age ; std :: cout << \"How old are you? \" ; std :: cin >> age ; User input (Handling error) 1 2 3 4 5 std :: cout << \"How old are you again? \" ; if ( ! ( std :: cin >> age )) { std :: cout << \"There is an error in your input \\n \" ; return 1 ; } Consuming input 1 2 3 4 5 6 if ( age >= 18 ) { std :: cout << \"Welcome! \\n \" ; } else { std :: cout << \"Sorry. \\n \" ; return 1 ; } Share Snippets","title":"Input"},{"location":"basic-syntax/input-output/input/#input","text":"Headers 1 #include <iostream> User input 1 2 3 int age ; std :: cout << \"How old are you? \" ; std :: cin >> age ; User input (Handling error) 1 2 3 4 5 std :: cout << \"How old are you again? \" ; if ( ! ( std :: cin >> age )) { std :: cout << \"There is an error in your input \\n \" ; return 1 ; } Consuming input 1 2 3 4 5 6 if ( age >= 18 ) { std :: cout << \"Welcome! \\n \" ; } else { std :: cout << \"Sorry. \\n \" ; return 1 ; } Share Snippets","title":"Input"},{"location":"basic-syntax/input-output/output/","text":"Output printf 1 printf ( \"Sorry.\" ); std::cout 1 std :: cout << \"Sorry.\" << '\\n' ; Flushing std::cout 1 std :: cout << \"Sorry.\" << std :: endl ; printf with parameters 1 printf ( \"Welcome! You are %d years old.\" , age ); std::cout with parameters 1 std :: cout << \"Welcome! You are \" << age << \" years old.\" << '\\n' ; Flushing std::cout with parameters 1 std :: cout << \"Welcome! You are \" << age << \" years old.\" << std :: endl ; Share Snippets Some people told me std::endl is evil. Is that true? Introductory snippets usually use std::endl instead of '\\n' , while some guides recommend always using '\\n' . Flushing with std::endl does have a semantic meaning different from '\\n , which is a nice convention for small snippets std::endl means \"please include a line break in the buffer and show me what's in the output buffer right now\" '\\n' means \"please include a line break in the buffer\" The reason people correctly say that std::endl costs more than '\\n' . But it costs more because it does not do the same thing. It exists for a reason. There are some situations where it makes sense to flush the stream. What's important is to be informed about what it does and how much it costs. When not working with files , which in the common scenario of introductory snippets, the time difference between flushing std::cout to the console (not files!) tends to be negligible Almost no application is spending more time flushing than calculating things to flush. Unless it's a flushing benchmark. On the other hand, some people will simply say std::endl is evil, but this is misleading. They are usually generalizing from benchmarks that explore specific edge cases to prove a point. These benchmarks are usually meant to show the difference between '\\n' and std::endl and not as proof that std::endl is evil per se, or significantly more expensive than '\\n' in all possible use cases. We can't tell you which is better because they do different things. But we can tell you their differences and their cost: The definitions: The buffer: The streams usually store the data in a buffer, which is meant to make things more efficient. The buffer reduces the number of trips to their final destination. Flushing: Once the buffer is full, then the data goes to its final destination, which is usually the console or a file. For convenience, when that happens, we say the stream is flushing the buffer. Commands: C++ gives you the option to flush what is in the buffer immediately or you might wait for the stream to flush automatically according to some internal heuristic. Automatically flushing: This heuristic is usually when the buffer is full, or when the buffer is about to be destructed. Sometimes, it flushes automatically when it sees a new line. That depends on the implementation. What the commands mean: Flushing does have a semantic meaning different from '\\n' , and this might be a good convention for some pieces of code, especially when you want to make sure you will see the output immediately, particularly for std::cout . '\\n' means \"put a newline in the buffer\" std::flush means \"show me what's in the buffer now\" std::endl means \"put a newline in the buffer and then show me what's in the buffer now\" Their cost: By the definition above, std::endl logically costs more than '\\n' because it's doing what '\\n' does plus one more thing. Some people often use examples and benchmarks flushing files as evidence that std::endl is evil per se. But there's a catch here: There's very little reason to flush to files because we don't usually care if the data gets in the file a little later. Flushing to files is much more comparatively expensive than flushing to std::cout . If you benchmark this difference, you will see the time difference of flushing std::cout to the console (not files!) is negligible: GCC -O2: Flush: 2.32234e-06 / Don't Flush: 2.26303e-06 Clang -O2: Flush: 2.33343e-06 / Don't Flush: 2.23031e-06 Besides this small difference, flushing to console is much more likely to be useful than flushing to a file. Also, this difference is almost certainly smaller in a real application. Almost no application is spending more time flushing than calculating things to flush. Unless it's a flushing benchmark like the one above. In the end, flushing to a file is almost always a bad idea. Flushing to the console won't probably have any significant impact on performance. In that second case, if not flushing can cause you any problems, just flush.","title":"Output"},{"location":"basic-syntax/input-output/output/#output","text":"printf 1 printf ( \"Sorry.\" ); std::cout 1 std :: cout << \"Sorry.\" << '\\n' ; Flushing std::cout 1 std :: cout << \"Sorry.\" << std :: endl ; printf with parameters 1 printf ( \"Welcome! You are %d years old.\" , age ); std::cout with parameters 1 std :: cout << \"Welcome! You are \" << age << \" years old.\" << '\\n' ; Flushing std::cout with parameters 1 std :: cout << \"Welcome! You are \" << age << \" years old.\" << std :: endl ; Share Snippets Some people told me std::endl is evil. Is that true? Introductory snippets usually use std::endl instead of '\\n' , while some guides recommend always using '\\n' . Flushing with std::endl does have a semantic meaning different from '\\n , which is a nice convention for small snippets std::endl means \"please include a line break in the buffer and show me what's in the output buffer right now\" '\\n' means \"please include a line break in the buffer\" The reason people correctly say that std::endl costs more than '\\n' . But it costs more because it does not do the same thing. It exists for a reason. There are some situations where it makes sense to flush the stream. What's important is to be informed about what it does and how much it costs. When not working with files , which in the common scenario of introductory snippets, the time difference between flushing std::cout to the console (not files!) tends to be negligible Almost no application is spending more time flushing than calculating things to flush. Unless it's a flushing benchmark. On the other hand, some people will simply say std::endl is evil, but this is misleading. They are usually generalizing from benchmarks that explore specific edge cases to prove a point. These benchmarks are usually meant to show the difference between '\\n' and std::endl and not as proof that std::endl is evil per se, or significantly more expensive than '\\n' in all possible use cases. We can't tell you which is better because they do different things. But we can tell you their differences and their cost: The definitions: The buffer: The streams usually store the data in a buffer, which is meant to make things more efficient. The buffer reduces the number of trips to their final destination. Flushing: Once the buffer is full, then the data goes to its final destination, which is usually the console or a file. For convenience, when that happens, we say the stream is flushing the buffer. Commands: C++ gives you the option to flush what is in the buffer immediately or you might wait for the stream to flush automatically according to some internal heuristic. Automatically flushing: This heuristic is usually when the buffer is full, or when the buffer is about to be destructed. Sometimes, it flushes automatically when it sees a new line. That depends on the implementation. What the commands mean: Flushing does have a semantic meaning different from '\\n' , and this might be a good convention for some pieces of code, especially when you want to make sure you will see the output immediately, particularly for std::cout . '\\n' means \"put a newline in the buffer\" std::flush means \"show me what's in the buffer now\" std::endl means \"put a newline in the buffer and then show me what's in the buffer now\" Their cost: By the definition above, std::endl logically costs more than '\\n' because it's doing what '\\n' does plus one more thing. Some people often use examples and benchmarks flushing files as evidence that std::endl is evil per se. But there's a catch here: There's very little reason to flush to files because we don't usually care if the data gets in the file a little later. Flushing to files is much more comparatively expensive than flushing to std::cout . If you benchmark this difference, you will see the time difference of flushing std::cout to the console (not files!) is negligible: GCC -O2: Flush: 2.32234e-06 / Don't Flush: 2.26303e-06 Clang -O2: Flush: 2.33343e-06 / Don't Flush: 2.23031e-06 Besides this small difference, flushing to console is much more likely to be useful than flushing to a file. Also, this difference is almost certainly smaller in a real application. Almost no application is spending more time flushing than calculating things to flush. Unless it's a flushing benchmark like the one above. In the end, flushing to a file is almost always a bad idea. Flushing to the console won't probably have any significant impact on performance. In that second case, if not flushing can cause you any problems, just flush.","title":"Output"},{"location":"basic-syntax/pointers/address-operator/","text":"Address Operator Address Operator An address-of operator is a mechanism within C++ that returns the memory address of a variable. These addresses returned by the address-of operator are known as pointers, because they \"point\" to the variable in memory. Print variable and its address 1 2 3 4 int a = 10 ; cout << \"a: \" << a << '\\n' ; cout << \"&a (hex): \" << & a << '\\n' ; cout << \"&a: (dec) \" << reinterpret_cast < uintptr_t > ( & a ) << '\\n' ; Create another stack variable 1 2 3 4 int b = 10 ; cout << \"b: \" << b << '\\n' ; cout << \"&b (hex): \" << & b << '\\n' ; cout << \"&b: (dec) \" << reinterpret_cast < uintptr_t > ( & b ) << '\\n' ; Create a value in the heap 1 2 3 4 auto c = std :: make_unique < int > ( 10 ); cout << \"*c: \" << * c << '\\n' ; cout << \"c (hex): \" << c << '\\n' ; // address should be distant from a and b cout << \"c: (dec) \" << reinterpret_cast < uintptr_t > ( c . get ()) << '\\n' ; Distance between two stack variables 1 2 cout << \"Distance &b - &a = \" << & b - & a << \" ints \\n \" ; cout << \"Distance &b - &a = \" << reinterpret_cast < unsigned char *> ( & b ) - reinterpret_cast < unsigned char *> ( & a ) << \" bytes \\n \" ; Distance between stack and heap variables 1 2 cout << \"Distance c.get() - &a = \" << c . get () - & a << \" ints \\n \" ; cout << \"Distance c.get() - &a = \" << reinterpret_cast < unsigned char *> ( c . get ()) - reinterpret_cast < unsigned char *> ( & a ) << \" bytes \\n \" ; Share Snippets","title":"Address Operator"},{"location":"basic-syntax/pointers/address-operator/#address-operator","text":"Address Operator An address-of operator is a mechanism within C++ that returns the memory address of a variable. These addresses returned by the address-of operator are known as pointers, because they \"point\" to the variable in memory. Print variable and its address 1 2 3 4 int a = 10 ; cout << \"a: \" << a << '\\n' ; cout << \"&a (hex): \" << & a << '\\n' ; cout << \"&a: (dec) \" << reinterpret_cast < uintptr_t > ( & a ) << '\\n' ; Create another stack variable 1 2 3 4 int b = 10 ; cout << \"b: \" << b << '\\n' ; cout << \"&b (hex): \" << & b << '\\n' ; cout << \"&b: (dec) \" << reinterpret_cast < uintptr_t > ( & b ) << '\\n' ; Create a value in the heap 1 2 3 4 auto c = std :: make_unique < int > ( 10 ); cout << \"*c: \" << * c << '\\n' ; cout << \"c (hex): \" << c << '\\n' ; // address should be distant from a and b cout << \"c: (dec) \" << reinterpret_cast < uintptr_t > ( c . get ()) << '\\n' ; Distance between two stack variables 1 2 cout << \"Distance &b - &a = \" << & b - & a << \" ints \\n \" ; cout << \"Distance &b - &a = \" << reinterpret_cast < unsigned char *> ( & b ) - reinterpret_cast < unsigned char *> ( & a ) << \" bytes \\n \" ; Distance between stack and heap variables 1 2 cout << \"Distance c.get() - &a = \" << c . get () - & a << \" ints \\n \" ; cout << \"Distance c.get() - &a = \" << reinterpret_cast < unsigned char *> ( c . get ()) - reinterpret_cast < unsigned char *> ( & a ) << \" bytes \\n \" ; Share Snippets","title":"Address Operator"},{"location":"basic-syntax/pointers/build-script/","text":"Build script 1 2 3 4 5 6 7 add_executable ( address_operator address_operator.cpp ) add_executable ( raw_pointers raw_pointers.cpp ) add_executable ( references references.cpp ) add_executable ( smart_pointers smart_pointers.cpp )","title":"Build script"},{"location":"basic-syntax/pointers/build-script/#build-script","text":"1 2 3 4 5 6 7 add_executable ( address_operator address_operator.cpp ) add_executable ( raw_pointers raw_pointers.cpp ) add_executable ( references references.cpp ) add_executable ( smart_pointers smart_pointers.cpp )","title":"Build script"},{"location":"basic-syntax/pointers/raw-pointers/","text":"Raw pointers Raw pointers A pointer is a type of variable. It stores the address of an object in memory, and is used to access that object. A raw pointer is a pointer whose lifetime isn't controlled by an encapsulating object, such as a smart pointer. Raw pointers might be dangerous. Try to avoid them. Pointer to an int on the heap 1 int * x = new int ( 5 ); Print pointer address 1 std :: cout << \"x: \" << x << '\\n' ; Print pointed value if any 1 2 3 4 5 if ( x ) { std :: cout << \"*x: \" << * x << '\\n' ; } else { std :: cout << \"*x: empty\" << '\\n' ; } Delete value pointed 1 2 3 4 5 // - Forgetting to delete causes memory leaks // - Forgetting to update to nullptr might lead to segmentation faults // - Use smart pointers to delete the data automatically delete x ; x = nullptr ; Raw dynamic arrays 1 2 3 4 5 6 7 8 // - This is what existed before vectors // - Point to a sequence of values // - Always use vectors instead of this // - If you need to access the raw data, use vector::data() int * x2 = new int [ 10 ]; for ( int i2 = 0 ; i2 < 10 ; ++ i2 ) { x2 [ i2 ] = 10 + i2 * 10 ; } Print addresses 1 2 3 std :: cout << \"x2: \" << x2 << '\\n' ; std :: cout << \"&x2[0]: \" << & x2 [ 0 ] << '\\n' ; std :: cout << \"x2[0]: \" << x2 [ 0 ] << '\\n' ; Points to the first number in the sequence 1 2 3 std :: cout << \"*x2: \" << * x2 << '\\n' ; std :: cout << \"x2[3]: \" << x2 [ 3 ] << '\\n' ; std :: cout << \"*(x2+3): \" << * ( x2 + 3 ) << '\\n' ; Deallocate sequence 1 2 3 // - Slightly different command: more danger delete [] x2 ; x2 = nullptr ; Share Snippets","title":"Raw pointers"},{"location":"basic-syntax/pointers/raw-pointers/#raw-pointers","text":"Raw pointers A pointer is a type of variable. It stores the address of an object in memory, and is used to access that object. A raw pointer is a pointer whose lifetime isn't controlled by an encapsulating object, such as a smart pointer. Raw pointers might be dangerous. Try to avoid them. Pointer to an int on the heap 1 int * x = new int ( 5 ); Print pointer address 1 std :: cout << \"x: \" << x << '\\n' ; Print pointed value if any 1 2 3 4 5 if ( x ) { std :: cout << \"*x: \" << * x << '\\n' ; } else { std :: cout << \"*x: empty\" << '\\n' ; } Delete value pointed 1 2 3 4 5 // - Forgetting to delete causes memory leaks // - Forgetting to update to nullptr might lead to segmentation faults // - Use smart pointers to delete the data automatically delete x ; x = nullptr ; Raw dynamic arrays 1 2 3 4 5 6 7 8 // - This is what existed before vectors // - Point to a sequence of values // - Always use vectors instead of this // - If you need to access the raw data, use vector::data() int * x2 = new int [ 10 ]; for ( int i2 = 0 ; i2 < 10 ; ++ i2 ) { x2 [ i2 ] = 10 + i2 * 10 ; } Print addresses 1 2 3 std :: cout << \"x2: \" << x2 << '\\n' ; std :: cout << \"&x2[0]: \" << & x2 [ 0 ] << '\\n' ; std :: cout << \"x2[0]: \" << x2 [ 0 ] << '\\n' ; Points to the first number in the sequence 1 2 3 std :: cout << \"*x2: \" << * x2 << '\\n' ; std :: cout << \"x2[3]: \" << x2 [ 3 ] << '\\n' ; std :: cout << \"*(x2+3): \" << * ( x2 + 3 ) << '\\n' ; Deallocate sequence 1 2 3 // - Slightly different command: more danger delete [] x2 ; x2 = nullptr ; Share Snippets","title":"Raw pointers"},{"location":"basic-syntax/pointers/references/","text":"References References They solve some problems with raw pointers Once initialized, a reference cannot be changed. This makes them less dangerous. Instead of \"pointing\" to an address, a reference only \"refers\" to a fixed address / variable References to stack value 1 2 3 4 int n = 1 ; int & r1 = n ; int & r2 = r1 ; int & r3 = n ; References as aliases 1 2 3 4 std :: cout << \"n: \" << n << '\\n' ; std :: cout << \"r1: \" << r1 << '\\n' ; std :: cout << \"r2: \" << r2 << '\\n' ; std :: cout << \"r3: \" << r3 << '\\n' ; Reference to array 1 2 int ar [ 3 ]; int ( & ra )[ 3 ] = ar ; Reference as array alias 1 2 std :: cout << \"ar: \" << ar << '\\n' ; std :: cout << \"ra: \" << ra << '\\n' ; Reference to pointer 1 2 int * p = new int ( 3 ); int *& ppr = p ; Reference as array alias 1 2 std :: cout << \"ar: \" << ar << '\\n' ; std :: cout << \"ra: \" << ra << '\\n' ; Reference to value pointed by p 1 2 int & prr = * p ; std :: cout << \"prr: \" << prr << '\\n' ; Deleting pointer is not the responsibility of the reference 1 2 delete p ; // ppr and prr are now dangling references Share Snippets","title":"References"},{"location":"basic-syntax/pointers/references/#references","text":"References They solve some problems with raw pointers Once initialized, a reference cannot be changed. This makes them less dangerous. Instead of \"pointing\" to an address, a reference only \"refers\" to a fixed address / variable References to stack value 1 2 3 4 int n = 1 ; int & r1 = n ; int & r2 = r1 ; int & r3 = n ; References as aliases 1 2 3 4 std :: cout << \"n: \" << n << '\\n' ; std :: cout << \"r1: \" << r1 << '\\n' ; std :: cout << \"r2: \" << r2 << '\\n' ; std :: cout << \"r3: \" << r3 << '\\n' ; Reference to array 1 2 int ar [ 3 ]; int ( & ra )[ 3 ] = ar ; Reference as array alias 1 2 std :: cout << \"ar: \" << ar << '\\n' ; std :: cout << \"ra: \" << ra << '\\n' ; Reference to pointer 1 2 int * p = new int ( 3 ); int *& ppr = p ; Reference as array alias 1 2 std :: cout << \"ar: \" << ar << '\\n' ; std :: cout << \"ra: \" << ra << '\\n' ; Reference to value pointed by p 1 2 int & prr = * p ; std :: cout << \"prr: \" << prr << '\\n' ; Deleting pointer is not the responsibility of the reference 1 2 delete p ; // ppr and prr are now dangling references Share Snippets","title":"References"},{"location":"basic-syntax/pointers/smart-pointers/","text":"Smart pointers Smart pointers Use smart pointers instead of raw pointer whenever possible: But you can't do it without understanding raw pointers Recur to raw non-owning pointers if they are needed In general, use: 1) No pointers at all 2) Raw non-owning pointers or references if they are needed 3) Smart pointers IF owning pointers can not be averted 4) Owning raw pointers if you know exactly what you are doing and need them (e.g. interfacing with C code). There are 2 important types of smart pointers: Unique pointer: Only one pointer can point to an address Deletes data automatically when the pointer is destroyed Shared pointer: More than one pointer can point to the same address Deletes data automatically when the last pointer is destroyed More expensive than unique pointers Unique pointer with no pointed value 1 2 3 4 5 6 7 // Only one unique pointer can point to an address std :: unique_ptr < int > c ; if ( c ) { std :: cout << \"*c : \" << * c << '\\n' ; } else { std :: cout << \"c is empty\" << '\\n' ; } Changing value of unique pointer 1 2 3 4 5 6 7 // Previous value is deleted if needed c = std :: make_unique < int > ( 2 ); if ( c ) { std :: cout << \"*c : \" << * c << '\\n' ; } else { std :: cout << \"c is empty\" << '\\n' ; } Initialize unique pointer with value 1 auto c2 = std :: make_unique < int > ( 3 ); Swap unique pointers 1 2 3 // Swapping values is valid c . swap ( c2 ); // c = c2; <- but copying doesn't work Moving values is valid 1 2 3 4 5 6 c = std :: move ( c2 ); if ( c ) { std :: cout << \"New *c : \" << * c << '\\n' ; } else { std :: cout << \"c is empty\" << '\\n' ; } Create shared pointer 1 2 3 4 5 6 auto sp = std :: make_shared < int > ( 2 ); if ( sp ) { std :: cout << \"New *sp : \" << * sp << '\\n' ; } else { std :: cout << \"sp is empty\" << '\\n' ; } Share pointed value 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 std :: shared_ptr < int > sp2 = sp ; * sp2 = 3 ; if ( sp ) { std :: cout << \"New *sp : \" << * sp << '\\n' ; // 3 } else { std :: cout << \"sp is empty\" << '\\n' ; } if ( sp2 ) { std :: cout << \"New *sp2 : \" << * sp << '\\n' ; // 3 } else { std :: cout << \"sp2 is empty\" << '\\n' ; } //[count Count number of shared pointers // How many pointers are pointing to this number? std :: cout << \"There are \" << sp . use_count () << \" pointers to \" << sp . get () << '\\n' ; Count number of shared pointers 1 2 3 // How many pointers are pointing to this number? std :: cout << \"There are \" << sp . use_count () << \" pointers to \" << sp . get () << '\\n' ; Share Snippets","title":"Smart pointers"},{"location":"basic-syntax/pointers/smart-pointers/#smart-pointers","text":"Smart pointers Use smart pointers instead of raw pointer whenever possible: But you can't do it without understanding raw pointers Recur to raw non-owning pointers if they are needed In general, use: 1) No pointers at all 2) Raw non-owning pointers or references if they are needed 3) Smart pointers IF owning pointers can not be averted 4) Owning raw pointers if you know exactly what you are doing and need them (e.g. interfacing with C code). There are 2 important types of smart pointers: Unique pointer: Only one pointer can point to an address Deletes data automatically when the pointer is destroyed Shared pointer: More than one pointer can point to the same address Deletes data automatically when the last pointer is destroyed More expensive than unique pointers Unique pointer with no pointed value 1 2 3 4 5 6 7 // Only one unique pointer can point to an address std :: unique_ptr < int > c ; if ( c ) { std :: cout << \"*c : \" << * c << '\\n' ; } else { std :: cout << \"c is empty\" << '\\n' ; } Changing value of unique pointer 1 2 3 4 5 6 7 // Previous value is deleted if needed c = std :: make_unique < int > ( 2 ); if ( c ) { std :: cout << \"*c : \" << * c << '\\n' ; } else { std :: cout << \"c is empty\" << '\\n' ; } Initialize unique pointer with value 1 auto c2 = std :: make_unique < int > ( 3 ); Swap unique pointers 1 2 3 // Swapping values is valid c . swap ( c2 ); // c = c2; <- but copying doesn't work Moving values is valid 1 2 3 4 5 6 c = std :: move ( c2 ); if ( c ) { std :: cout << \"New *c : \" << * c << '\\n' ; } else { std :: cout << \"c is empty\" << '\\n' ; } Create shared pointer 1 2 3 4 5 6 auto sp = std :: make_shared < int > ( 2 ); if ( sp ) { std :: cout << \"New *sp : \" << * sp << '\\n' ; } else { std :: cout << \"sp is empty\" << '\\n' ; } Share pointed value 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 std :: shared_ptr < int > sp2 = sp ; * sp2 = 3 ; if ( sp ) { std :: cout << \"New *sp : \" << * sp << '\\n' ; // 3 } else { std :: cout << \"sp is empty\" << '\\n' ; } if ( sp2 ) { std :: cout << \"New *sp2 : \" << * sp << '\\n' ; // 3 } else { std :: cout << \"sp2 is empty\" << '\\n' ; } //[count Count number of shared pointers // How many pointers are pointing to this number? std :: cout << \"There are \" << sp . use_count () << \" pointers to \" << sp . get () << '\\n' ; Count number of shared pointers 1 2 3 // How many pointers are pointing to this number? std :: cout << \"There are \" << sp . use_count () << \" pointers to \" << sp . get () << '\\n' ; Share Snippets","title":"Smart pointers"},{"location":"cmake-functions/project-flags/","text":"Project Flags Set variable indicating if this is a master project 1 2 3 4 5 if ( ${ CMAKE_CURRENT_SOURCE_DIR } STREQUAL ${ CMAKE_SOURCE_DIR } ) set ( MASTER_PROJECT ON ) else () set ( MASTER_PROJECT OFF ) endif () Set variables indicating if mode is Debug or Release 1 2 3 4 5 6 7 8 9 10 11 if ( CMAKE_BUILD_TYPE STREQUAL \"Debug\" ) set ( DEBUG_MODE ON ) set ( NOT_DEBUG_MODE OFF ) set ( RELEASE_MODE OFF ) set ( NOT_RELEASE_MODE ON ) else () set ( DEBUG_MODE OFF ) set ( NOT_DEBUG_MODE ON ) set ( RELEASE_MODE ON ) set ( NOT_RELEASE_MODE OFF ) endif () Create booleans GCC and CLANG to identify the compiler more easily 1 2 3 4 5 6 7 set ( CLANG OFF ) set ( GCC OFF ) if ( CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\" OR CMAKE_CXX_COMPILER_ID STREQUAL \"AppleClang\" ) set ( CLANG ON ) elseif ( CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\" ) set ( GCC ON ) endif () Set the default optimization flags 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # This will set the flags only if the user didn't explicitly choose them with -DCMAKE_CXX_FLAGS if ( NOT CMAKE_CXX_FLAGS ) if ( CMAKE_BUILD_TYPE STREQUAL \"Debug\" ) if ( MSVC ) list ( APPEND CMAKE_CXX_FLAGS \"/O0\" ) else () list ( APPEND CMAKE_CXX_FLAGS \"-O0\" ) endif () else () if ( MSVC ) list ( APPEND CMAKE_CXX_FLAGS \"/O2\" ) else () list ( APPEND CMAKE_CXX_FLAGS \"-O2\" ) endif () endif () message ( \"Setting CXX flags to default for ${CMAKE_BUILD_TYPE} mode (${CMAKE_CXX_FLAGS})\" ) else () message ( \"CXX flags are already set to ${CMAKE_CXX_FLAGS}\" ) endif () Share Snippets","title":"Project Flags"},{"location":"cmake-functions/project-flags/#project-flags","text":"Set variable indicating if this is a master project 1 2 3 4 5 if ( ${ CMAKE_CURRENT_SOURCE_DIR } STREQUAL ${ CMAKE_SOURCE_DIR } ) set ( MASTER_PROJECT ON ) else () set ( MASTER_PROJECT OFF ) endif () Set variables indicating if mode is Debug or Release 1 2 3 4 5 6 7 8 9 10 11 if ( CMAKE_BUILD_TYPE STREQUAL \"Debug\" ) set ( DEBUG_MODE ON ) set ( NOT_DEBUG_MODE OFF ) set ( RELEASE_MODE OFF ) set ( NOT_RELEASE_MODE ON ) else () set ( DEBUG_MODE OFF ) set ( NOT_DEBUG_MODE ON ) set ( RELEASE_MODE ON ) set ( NOT_RELEASE_MODE OFF ) endif () Create booleans GCC and CLANG to identify the compiler more easily 1 2 3 4 5 6 7 set ( CLANG OFF ) set ( GCC OFF ) if ( CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\" OR CMAKE_CXX_COMPILER_ID STREQUAL \"AppleClang\" ) set ( CLANG ON ) elseif ( CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\" ) set ( GCC ON ) endif () Set the default optimization flags 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # This will set the flags only if the user didn't explicitly choose them with -DCMAKE_CXX_FLAGS if ( NOT CMAKE_CXX_FLAGS ) if ( CMAKE_BUILD_TYPE STREQUAL \"Debug\" ) if ( MSVC ) list ( APPEND CMAKE_CXX_FLAGS \"/O0\" ) else () list ( APPEND CMAKE_CXX_FLAGS \"-O0\" ) endif () else () if ( MSVC ) list ( APPEND CMAKE_CXX_FLAGS \"/O2\" ) else () list ( APPEND CMAKE_CXX_FLAGS \"-O2\" ) endif () endif () message ( \"Setting CXX flags to default for ${CMAKE_BUILD_TYPE} mode (${CMAKE_CXX_FLAGS})\" ) else () message ( \"CXX flags are already set to ${CMAKE_CXX_FLAGS}\" ) endif () Share Snippets","title":"Project Flags"},{"location":"cmake-functions/qt-helpers/","text":"Qt Helpers Try to find and add the QT directories to CMAKE_PREFIX_PATH 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 # This script looks for Qt5 only # - Change this variable to adapt the script set ( QT_VERSION 5 ) # Reasonable paths to look for Qt set ( QT_PATH_HINTS /usr/local/qt/ /usr/local/Cellar/qt/ \"C:\\\\Qt\\\\\" ) # Reasonable paths to look for the Qt CMake scripts set ( QT_CMAKE_PATH_POSTFIX_HINTS lib/cmake/ lib/cmake/Qt ${ QT_VERSION } ) # Look for Qt paths foreach ( QT_PATH_HINT ${ QT_PATH_HINTS } ) if ( EXISTS ${ QT_PATH_HINT } AND IS_DIRECTORY ${ QT_PATH_HINT } ) message ( \"Found Qt hint path ${QT_PATH_HINT}\" ) # Explore children directories file ( GLOB QT_PATH_HINT_CHILDREN RELATIVE ${ QT_PATH_HINT } ${ QT_PATH_HINT } /* ) foreach ( QT_PATH_HINT_CHILD ${ QT_PATH_HINT_CHILDREN } ) set ( FULL_QT_PATH_HINT_CHILD ${ QT_PATH_HINT }${ QT_PATH_HINT_CHILD } ) if ( IS_DIRECTORY ${ FULL_QT_PATH_HINT_CHILD } ) message ( \"Found child directory ${FULL_QT_PATH_HINT_CHILD}\" ) # Check if it matches the pattern of version numbers if ( QT_PATH_HINT_CHILD MATCHES \"[0-9]+\\\\.?[0-9]*\\\\.?[0-9]*\" ) message ( \"${QT_PATH_HINT_CHILD} follows the version pattern\" ) if ( NOT ${ FULL_QT_PATH_HINT_CHILD } IN_LIST CMAKE_PREFIX_PATH ) message ( \"Adding new Qt hint child ${FULL_QT_PATH_HINT_CHILD} to CMAKE_PREFIX_PATH\" ) list ( APPEND CMAKE_PREFIX_PATH ${ FULL_QT_PATH_HINT_CHILD } ) endif () # Explore possible path postfixes for CMake scripts foreach ( QT_CMAKE_PATH_POSTFIX_HINT ${ QT_CMAKE_PATH_POSTFIX_HINTS } ) set ( FULL_QT_CMAKE_PATH ${ FULL_QT_PATH_HINT_CHILD } / ${ QT_CMAKE_PATH_POSTFIX_HINT } ) message ( \"Testing ${FULL_QT_CMAKE_PATH}\" ) if ( EXISTS ${ FULL_QT_CMAKE_PATH } AND IS_DIRECTORY ${ FULL_QT_CMAKE_PATH } ) message ( \"Found ${FULL_QT_CMAKE_PATH}\" ) if ( NOT ${ FULL_QT_CMAKE_PATH } IN_LIST CMAKE_PREFIX_PATH ) message ( \"Adding ${FULL_QT_CMAKE_PATH} to CMAKE_PREFIX_PATH\" ) list ( APPEND CMAKE_PREFIX_PATH ${ FULL_QT_CMAKE_PATH } ) else () message ( \"Already found ${FULL_QT_CMAKE_PATH} in CMAKE_PREFIX_PATH\" ) endif () endif () endforeach () endif () endif () endforeach () endif () endforeach () Share Snippets","title":"Qt Helpers"},{"location":"cmake-functions/qt-helpers/#qt-helpers","text":"Try to find and add the QT directories to CMAKE_PREFIX_PATH 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 # This script looks for Qt5 only # - Change this variable to adapt the script set ( QT_VERSION 5 ) # Reasonable paths to look for Qt set ( QT_PATH_HINTS /usr/local/qt/ /usr/local/Cellar/qt/ \"C:\\\\Qt\\\\\" ) # Reasonable paths to look for the Qt CMake scripts set ( QT_CMAKE_PATH_POSTFIX_HINTS lib/cmake/ lib/cmake/Qt ${ QT_VERSION } ) # Look for Qt paths foreach ( QT_PATH_HINT ${ QT_PATH_HINTS } ) if ( EXISTS ${ QT_PATH_HINT } AND IS_DIRECTORY ${ QT_PATH_HINT } ) message ( \"Found Qt hint path ${QT_PATH_HINT}\" ) # Explore children directories file ( GLOB QT_PATH_HINT_CHILDREN RELATIVE ${ QT_PATH_HINT } ${ QT_PATH_HINT } /* ) foreach ( QT_PATH_HINT_CHILD ${ QT_PATH_HINT_CHILDREN } ) set ( FULL_QT_PATH_HINT_CHILD ${ QT_PATH_HINT }${ QT_PATH_HINT_CHILD } ) if ( IS_DIRECTORY ${ FULL_QT_PATH_HINT_CHILD } ) message ( \"Found child directory ${FULL_QT_PATH_HINT_CHILD}\" ) # Check if it matches the pattern of version numbers if ( QT_PATH_HINT_CHILD MATCHES \"[0-9]+\\\\.?[0-9]*\\\\.?[0-9]*\" ) message ( \"${QT_PATH_HINT_CHILD} follows the version pattern\" ) if ( NOT ${ FULL_QT_PATH_HINT_CHILD } IN_LIST CMAKE_PREFIX_PATH ) message ( \"Adding new Qt hint child ${FULL_QT_PATH_HINT_CHILD} to CMAKE_PREFIX_PATH\" ) list ( APPEND CMAKE_PREFIX_PATH ${ FULL_QT_PATH_HINT_CHILD } ) endif () # Explore possible path postfixes for CMake scripts foreach ( QT_CMAKE_PATH_POSTFIX_HINT ${ QT_CMAKE_PATH_POSTFIX_HINTS } ) set ( FULL_QT_CMAKE_PATH ${ FULL_QT_PATH_HINT_CHILD } / ${ QT_CMAKE_PATH_POSTFIX_HINT } ) message ( \"Testing ${FULL_QT_CMAKE_PATH}\" ) if ( EXISTS ${ FULL_QT_CMAKE_PATH } AND IS_DIRECTORY ${ FULL_QT_CMAKE_PATH } ) message ( \"Found ${FULL_QT_CMAKE_PATH}\" ) if ( NOT ${ FULL_QT_CMAKE_PATH } IN_LIST CMAKE_PREFIX_PATH ) message ( \"Adding ${FULL_QT_CMAKE_PATH} to CMAKE_PREFIX_PATH\" ) list ( APPEND CMAKE_PREFIX_PATH ${ FULL_QT_CMAKE_PATH } ) else () message ( \"Already found ${FULL_QT_CMAKE_PATH} in CMAKE_PREFIX_PATH\" ) endif () endif () endforeach () endif () endif () endforeach () endif () endforeach () Share Snippets","title":"Qt Helpers"},{"location":"cmake-functions/sanitizers/","text":"Sanitizers Add sanitizer flag to all targets 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 include ( CheckCXXCompilerFlag ) if ( CMAKE_CXX_COMPILER_ID MATCHES \"Clang\" OR CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\" OR CMAKE_CXX_COMPILER_ID STREQUAL \"AppleClang\" ) message ( \"Looking for -fsanitize=${flag}\" ) set ( CMAKE_REQUIRED_FLAGS \"-Werror -fsanitize=${flag}\" ) check_cxx_compiler_flag ( -fsanitize= ${ flag } HAVE_FLAG_SANITIZER ) if ( HAVE_FLAG_SANITIZER ) message ( \"Adding -fsanitize=${flag}\" ) set ( CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fsanitize=${flag} -fno-omit-frame-pointer\" ) set ( DCMAKE_C_FLAGS \"${DCMAKE_C_FLAGS} -fsanitize=${flag} -fno-omit-frame-pointer\" ) set ( CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} -fsanitize=${flag}\" ) set ( DCMAKE_MODULE_LINKER_FLAGS \"${DCMAKE_MODULE_LINKER_FLAGS} -fsanitize=${flag}\" ) else () message ( \"-fsanitize=${flag} unavailable\" ) endif () endif () Add address sanitizer to all targets 1 add_sanitizer ( \"address\" ) Add thread sanitizer to all targets 1 add_sanitizer ( \"thread\" ) Add undefined sanitizer to all targets 1 add_sanitizer ( \"undefined\" ) Add memory sanitizer to all targets 1 add_sanitizer ( \"memory\" ) Add leak sanitizer to all targets 1 add_sanitizer ( \"leak\" ) Add all sanitizers to all targets 1 2 3 4 5 6 7 8 # Choose a subset of sanitizers not in conflict add_address_sanitizer () add_leak_sanitizer () add_undefined_sanitizer () # not allowed with address sanitizer # add_thread_sanitizer() # not supported # add_memory_sanitizer() Share Snippets","title":"Sanitizers"},{"location":"cmake-functions/sanitizers/#sanitizers","text":"Add sanitizer flag to all targets 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 include ( CheckCXXCompilerFlag ) if ( CMAKE_CXX_COMPILER_ID MATCHES \"Clang\" OR CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\" OR CMAKE_CXX_COMPILER_ID STREQUAL \"AppleClang\" ) message ( \"Looking for -fsanitize=${flag}\" ) set ( CMAKE_REQUIRED_FLAGS \"-Werror -fsanitize=${flag}\" ) check_cxx_compiler_flag ( -fsanitize= ${ flag } HAVE_FLAG_SANITIZER ) if ( HAVE_FLAG_SANITIZER ) message ( \"Adding -fsanitize=${flag}\" ) set ( CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fsanitize=${flag} -fno-omit-frame-pointer\" ) set ( DCMAKE_C_FLAGS \"${DCMAKE_C_FLAGS} -fsanitize=${flag} -fno-omit-frame-pointer\" ) set ( CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} -fsanitize=${flag}\" ) set ( DCMAKE_MODULE_LINKER_FLAGS \"${DCMAKE_MODULE_LINKER_FLAGS} -fsanitize=${flag}\" ) else () message ( \"-fsanitize=${flag} unavailable\" ) endif () endif () Add address sanitizer to all targets 1 add_sanitizer ( \"address\" ) Add thread sanitizer to all targets 1 add_sanitizer ( \"thread\" ) Add undefined sanitizer to all targets 1 add_sanitizer ( \"undefined\" ) Add memory sanitizer to all targets 1 add_sanitizer ( \"memory\" ) Add leak sanitizer to all targets 1 add_sanitizer ( \"leak\" ) Add all sanitizers to all targets 1 2 3 4 5 6 7 8 # Choose a subset of sanitizers not in conflict add_address_sanitizer () add_leak_sanitizer () add_undefined_sanitizer () # not allowed with address sanitizer # add_thread_sanitizer() # not supported # add_memory_sanitizer() Share Snippets","title":"Sanitizers"},{"location":"cmake-functions/target-options/","text":"Target Options Enable pedantic warnings for a target 1 2 3 4 5 6 # Set warning levels to about the same level for MSVC, GCC, and Clang if ( MSVC ) target_compile_options ( ${ TARGET_NAME } PRIVATE /W4 /WX ) else () target_compile_options ( ${ TARGET_NAME } PRIVATE -Wall -Wextra -pedantic -Werror ) endif () Enable pedantic warnings for a target 1 2 3 4 5 6 # Set warning levels to about the same level for MSVC, GCC, and Clang if ( MSVC ) target_compile_options ( ${ TARGET_NAME } PRIVATE /W4 /WX ) else () target_compile_options ( ${ TARGET_NAME } PRIVATE -Wall -Wextra -pedantic -Werror ) endif () Share Snippets","title":"Target Options"},{"location":"cmake-functions/target-options/#target-options","text":"Enable pedantic warnings for a target 1 2 3 4 5 6 # Set warning levels to about the same level for MSVC, GCC, and Clang if ( MSVC ) target_compile_options ( ${ TARGET_NAME } PRIVATE /W4 /WX ) else () target_compile_options ( ${ TARGET_NAME } PRIVATE -Wall -Wextra -pedantic -Werror ) endif () Enable pedantic warnings for a target 1 2 3 4 5 6 # Set warning levels to about the same level for MSVC, GCC, and Clang if ( MSVC ) target_compile_options ( ${ TARGET_NAME } PRIVATE /W4 /WX ) else () target_compile_options ( ${ TARGET_NAME } PRIVATE -Wall -Wextra -pedantic -Werror ) endif () Share Snippets","title":"Target Options"},{"location":"guis/imgui/","text":"ImGUI Find OpenGL 1 find_package ( OpenGL ) Fetch GLAD 1 2 FetchContent_Declare ( glad GIT_REPOSITORY https://github.com/Dav1dde/glad.git GIT_TAG df8e9e16110b305479a875399cee13daa0ccadd9 ) FetchContent_MakeAvailable ( glad ) Fetch GLFW 1 2 3 4 5 6 set ( GLFW_BUILD_DOCS OFF CACHE BOOL \"\" FORCE ) set ( GLFW_BUILD_EXAMPLES OFF CACHE BOOL \"\" FORCE ) set ( GLFW_BUILD_TESTS OFF CACHE BOOL \"\" FORCE ) set ( GLFW_INSTALL OFF CACHE BOOL \"\" FORCE ) FetchContent_Declare ( glfw GIT_REPOSITORY https://github.com/glfw/glfw.git GIT_TAG 3.3.2 ) FetchContent_MakeAvailable ( glfw ) Fetch ImGUI 1 2 3 4 5 6 7 8 9 10 11 12 13 FetchContent_Declare ( imgui GIT_REPOSITORY https://github.com/ocornut/imgui.git GIT_TAG v1.77 ) FetchContent_GetProperties ( imgui ) if ( NOT imgui_POPULATED ) FetchContent_Populate ( imgui ) set ( IMGUI_INCLUDE_DIR ${ imgui_SOURCE_DIR } / ) file ( GLOB IMGUI_SOURCES ${ imgui_SOURCE_DIR } /*.cpp ) file ( GLOB IMGUI_HEADERS ${ imgui_SOURCE_DIR } /*.h ) add_library ( imgui STATIC ${ IMGUI_SOURCES } ${ IMGUI_SOURCES } ${ imgui_SOURCE_DIR } /examples/imgui_impl_glfw.cpp ${ imgui_SOURCE_DIR } /examples/imgui_impl_opengl3.cpp ) add_definitions ( -DIMGUI_IMPL_OPENGL_LOADER_GLAD ) Link ImGUI 1 2 3 target_include_directories ( imgui PUBLIC ${ IMGUI_INCLUDE_DIR } ${ OPENGL_INCLUDE_DIR } ${ GLFW_INCLUDE_DIR } ${ GLAD_INCLUDE_DIR } ) target_link_libraries ( imgui ${ OPENGL_LIBRARIES } glfw glad ) endif () Share Snippets Headers 1 #include \"imgui.h\" GLFW backend headers 1 2 #include \"examples/imgui_impl_glfw.h\" #include \"examples/imgui_impl_opengl3.h\" Load OpenGL functions 1 2 3 4 5 6 7 8 9 10 11 #if defined(IMGUI_IMPL_OPENGL_LOADER_GL3W) #include <GL/gl3w.h> // Initialize with gl3wInit() #elif defined(IMGUI_IMPL_OPENGL_LOADER_GLEW) #include <GL/glew.h> // Initialize with glewInit() #elif defined(IMGUI_IMPL_OPENGL_LOADER_GLAD) #include <glad/glad.h> // Initialize with gladLoadGL() #elif defined(IMGUI_IMPL_OPENGL_LOADER_GLBINDING2) #define GLFW_INCLUDE_NONE // GLFW including OpenGL headers causes ambiguity or // multiple definition errors. #include <glbinding/Binding.h> // Initialize with glbinding::Binding::initialize() #include <glbinding/gl/gl.h> Setup window 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 glfwSetErrorCallback ( glfw_error_callback ); if ( ! glfwInit ()) return 1 ; // Decide GL+GLSL versions #if __APPLE__ // GL 3.2 + GLSL 150 const char * glsl_version = \"#version 150\" ; glfwWindowHint ( GLFW_CONTEXT_VERSION_MAJOR , 3 ); glfwWindowHint ( GLFW_CONTEXT_VERSION_MINOR , 2 ); glfwWindowHint ( GLFW_OPENGL_PROFILE , GLFW_OPENGL_CORE_PROFILE ); // 3.2+ only glfwWindowHint ( GLFW_OPENGL_FORWARD_COMPAT , GL_TRUE ); // Required on Mac #else // GL 3.0 + GLSL 130 const char * glsl_version = \"#version 130\" ; glfwWindowHint ( GLFW_CONTEXT_VERSION_MAJOR , 3 ); glfwWindowHint ( GLFW_CONTEXT_VERSION_MINOR , 0 ); // glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // 3.2+ // only glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // 3.0+ only #endif // Create window with graphics context GLFWwindow * window = glfwCreateWindow ( 1280 , 720 , \"Dear ImGui GLFW+OpenGL3 example\" , NULL , NULL ); if ( window == NULL ) return 1 ; glfwMakeContextCurrent ( window ); glfwSwapInterval ( 1 ); // Enable vsync Setup Dear ImGui context 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 IMGUI_CHECKVERSION (); ImGui :: CreateContext (); ImGuiIO & io = ImGui :: GetIO (); ( void ) io ; // io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard; // Enable // Keyboard Controls io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad; // // Enable Gamepad Controls // Setup Dear ImGui style ImGui :: StyleColorsDark (); // ImGui::StyleColorsClassic(); // Setup Platform/Renderer bindings ImGui_ImplGlfw_InitForOpenGL ( window , true ); ImGui_ImplOpenGL3_Init ( glsl_version ); Start the Dear ImGui frame for the iteration 1 2 3 ImGui_ImplOpenGL3_NewFrame (); ImGui_ImplGlfw_NewFrame (); ImGui :: NewFrame (); Render demo 1 2 if ( show_demo_window ) ImGui :: ShowDemoWindow ( & show_demo_window ); Rendering 1 2 3 4 5 6 7 8 ImGui :: Render (); int display_w , display_h ; glfwGetFramebufferSize ( window , & display_w , & display_h ); glViewport ( 0 , 0 , display_w , display_h ); glClearColor ( clear_color . x , clear_color . y , clear_color . z , clear_color . w ); glClear ( GL_COLOR_BUFFER_BIT ); ImGui_ImplOpenGL3_RenderDrawData ( ImGui :: GetDrawData ()); Cleanup 1 2 3 ImGui_ImplOpenGL3_Shutdown (); ImGui_ImplGlfw_Shutdown (); ImGui :: DestroyContext (); Share Snippets","title":"ImGUI"},{"location":"guis/imgui/#imgui","text":"Find OpenGL 1 find_package ( OpenGL ) Fetch GLAD 1 2 FetchContent_Declare ( glad GIT_REPOSITORY https://github.com/Dav1dde/glad.git GIT_TAG df8e9e16110b305479a875399cee13daa0ccadd9 ) FetchContent_MakeAvailable ( glad ) Fetch GLFW 1 2 3 4 5 6 set ( GLFW_BUILD_DOCS OFF CACHE BOOL \"\" FORCE ) set ( GLFW_BUILD_EXAMPLES OFF CACHE BOOL \"\" FORCE ) set ( GLFW_BUILD_TESTS OFF CACHE BOOL \"\" FORCE ) set ( GLFW_INSTALL OFF CACHE BOOL \"\" FORCE ) FetchContent_Declare ( glfw GIT_REPOSITORY https://github.com/glfw/glfw.git GIT_TAG 3.3.2 ) FetchContent_MakeAvailable ( glfw ) Fetch ImGUI 1 2 3 4 5 6 7 8 9 10 11 12 13 FetchContent_Declare ( imgui GIT_REPOSITORY https://github.com/ocornut/imgui.git GIT_TAG v1.77 ) FetchContent_GetProperties ( imgui ) if ( NOT imgui_POPULATED ) FetchContent_Populate ( imgui ) set ( IMGUI_INCLUDE_DIR ${ imgui_SOURCE_DIR } / ) file ( GLOB IMGUI_SOURCES ${ imgui_SOURCE_DIR } /*.cpp ) file ( GLOB IMGUI_HEADERS ${ imgui_SOURCE_DIR } /*.h ) add_library ( imgui STATIC ${ IMGUI_SOURCES } ${ IMGUI_SOURCES } ${ imgui_SOURCE_DIR } /examples/imgui_impl_glfw.cpp ${ imgui_SOURCE_DIR } /examples/imgui_impl_opengl3.cpp ) add_definitions ( -DIMGUI_IMPL_OPENGL_LOADER_GLAD ) Link ImGUI 1 2 3 target_include_directories ( imgui PUBLIC ${ IMGUI_INCLUDE_DIR } ${ OPENGL_INCLUDE_DIR } ${ GLFW_INCLUDE_DIR } ${ GLAD_INCLUDE_DIR } ) target_link_libraries ( imgui ${ OPENGL_LIBRARIES } glfw glad ) endif () Share Snippets Headers 1 #include \"imgui.h\" GLFW backend headers 1 2 #include \"examples/imgui_impl_glfw.h\" #include \"examples/imgui_impl_opengl3.h\" Load OpenGL functions 1 2 3 4 5 6 7 8 9 10 11 #if defined(IMGUI_IMPL_OPENGL_LOADER_GL3W) #include <GL/gl3w.h> // Initialize with gl3wInit() #elif defined(IMGUI_IMPL_OPENGL_LOADER_GLEW) #include <GL/glew.h> // Initialize with glewInit() #elif defined(IMGUI_IMPL_OPENGL_LOADER_GLAD) #include <glad/glad.h> // Initialize with gladLoadGL() #elif defined(IMGUI_IMPL_OPENGL_LOADER_GLBINDING2) #define GLFW_INCLUDE_NONE // GLFW including OpenGL headers causes ambiguity or // multiple definition errors. #include <glbinding/Binding.h> // Initialize with glbinding::Binding::initialize() #include <glbinding/gl/gl.h> Setup window 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 glfwSetErrorCallback ( glfw_error_callback ); if ( ! glfwInit ()) return 1 ; // Decide GL+GLSL versions #if __APPLE__ // GL 3.2 + GLSL 150 const char * glsl_version = \"#version 150\" ; glfwWindowHint ( GLFW_CONTEXT_VERSION_MAJOR , 3 ); glfwWindowHint ( GLFW_CONTEXT_VERSION_MINOR , 2 ); glfwWindowHint ( GLFW_OPENGL_PROFILE , GLFW_OPENGL_CORE_PROFILE ); // 3.2+ only glfwWindowHint ( GLFW_OPENGL_FORWARD_COMPAT , GL_TRUE ); // Required on Mac #else // GL 3.0 + GLSL 130 const char * glsl_version = \"#version 130\" ; glfwWindowHint ( GLFW_CONTEXT_VERSION_MAJOR , 3 ); glfwWindowHint ( GLFW_CONTEXT_VERSION_MINOR , 0 ); // glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // 3.2+ // only glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // 3.0+ only #endif // Create window with graphics context GLFWwindow * window = glfwCreateWindow ( 1280 , 720 , \"Dear ImGui GLFW+OpenGL3 example\" , NULL , NULL ); if ( window == NULL ) return 1 ; glfwMakeContextCurrent ( window ); glfwSwapInterval ( 1 ); // Enable vsync Setup Dear ImGui context 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 IMGUI_CHECKVERSION (); ImGui :: CreateContext (); ImGuiIO & io = ImGui :: GetIO (); ( void ) io ; // io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard; // Enable // Keyboard Controls io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad; // // Enable Gamepad Controls // Setup Dear ImGui style ImGui :: StyleColorsDark (); // ImGui::StyleColorsClassic(); // Setup Platform/Renderer bindings ImGui_ImplGlfw_InitForOpenGL ( window , true ); ImGui_ImplOpenGL3_Init ( glsl_version ); Start the Dear ImGui frame for the iteration 1 2 3 ImGui_ImplOpenGL3_NewFrame (); ImGui_ImplGlfw_NewFrame (); ImGui :: NewFrame (); Render demo 1 2 if ( show_demo_window ) ImGui :: ShowDemoWindow ( & show_demo_window ); Rendering 1 2 3 4 5 6 7 8 ImGui :: Render (); int display_w , display_h ; glfwGetFramebufferSize ( window , & display_w , & display_h ); glViewport ( 0 , 0 , display_w , display_h ); glClearColor ( clear_color . x , clear_color . y , clear_color . z , clear_color . w ); glClear ( GL_COLOR_BUFFER_BIT ); ImGui_ImplOpenGL3_RenderDrawData ( ImGui :: GetDrawData ()); Cleanup 1 2 3 ImGui_ImplOpenGL3_Shutdown (); ImGui_ImplGlfw_Shutdown (); ImGui :: DestroyContext (); Share Snippets","title":"ImGUI"},{"location":"guis/opengl-glfw/","text":"SDL Find OpenGL 1 find_package ( OpenGL ) Fetch GLAD 1 2 FetchContent_Declare ( glad GIT_REPOSITORY https://github.com/Dav1dde/glad.git GIT_TAG df8e9e16110b305479a875399cee13daa0ccadd9 ) FetchContent_MakeAvailable ( glad ) Fetch GLFW 1 2 3 4 5 6 set ( GLFW_BUILD_DOCS OFF CACHE BOOL \"\" FORCE ) set ( GLFW_BUILD_EXAMPLES OFF CACHE BOOL \"\" FORCE ) set ( GLFW_BUILD_TESTS OFF CACHE BOOL \"\" FORCE ) set ( GLFW_INSTALL OFF CACHE BOOL \"\" FORCE ) FetchContent_Declare ( glfw GIT_REPOSITORY https://github.com/glfw/glfw.git GIT_TAG 3.3.2 ) FetchContent_MakeAvailable ( glfw ) Link GLFW 1 2 add_executable ( opengl_hello opengl_hello.cpp ) target_link_libraries ( opengl_hello PUBLIC glad glfw ) Share Snippets Headers 1 2 #include <glad/glad.h> #include <GLFW/glfw3.h> Declare callback functions 1 2 void framebuffer_size_callback ( GLFWwindow * window , int width , int height ); void processInput ( GLFWwindow * window ); Initialize GLFW 1 2 3 4 5 6 7 8 glfwInit (); glfwWindowHint ( GLFW_CONTEXT_VERSION_MAJOR , 3 ); glfwWindowHint ( GLFW_CONTEXT_VERSION_MINOR , 3 ); glfwWindowHint ( GLFW_OPENGL_PROFILE , GLFW_OPENGL_CORE_PROFILE ); #ifdef __APPLE__ glfwWindowHint ( GLFW_OPENGL_FORWARD_COMPAT , GL_TRUE ); #endif Create window 1 2 3 4 5 6 7 8 9 10 11 12 const unsigned int SCR_WIDTH = 800 ; const unsigned int SCR_HEIGHT = 600 ; GLFWwindow * window = glfwCreateWindow ( SCR_WIDTH , SCR_HEIGHT , \"LearnOpenGL\" , NULL , NULL ); if ( window == NULL ) { std :: cout << \"Failed to create GLFW window\" << std :: endl ; glfwTerminate (); return -1 ; } glfwMakeContextCurrent ( window ); glfwSetFramebufferSizeCallback ( window , framebuffer_size_callback ); Load OpenGL function pointers 1 2 3 4 if ( ! gladLoadGLLoader (( GLADloadproc ) glfwGetProcAddress )) { std :: cout << \"Failed to initialize GLAD\" << std :: endl ; return -1 ; } Start render loop 1 while ( ! glfwWindowShouldClose ( window )) { Process input 1 processInput ( window ); Render 1 2 glClearColor ( 0.2f , 0.3f , 0.3f , 1.0f ); glClear ( GL_COLOR_BUFFER_BIT ); Swap buffer and poll events 1 2 3 glfwSwapBuffers ( window ); glfwPollEvents (); } Terminate GLFW 1 glfwTerminate (); Function to process input 1 2 3 4 void processInput ( GLFWwindow * window ) { if ( glfwGetKey ( window , GLFW_KEY_ESCAPE ) == GLFW_PRESS ) glfwSetWindowShouldClose ( window , true ); } Function to process window resize 1 2 3 4 5 6 void framebuffer_size_callback ([[ maybe_unused ]] GLFWwindow * window , int width , int height ) { // make sure the viewport matches the new window dimensions; note that width // and height will be significantly larger than specified on retina // displays. glViewport ( 0 , 0 , width , height ); } Share Snippets","title":"GLFW"},{"location":"guis/opengl-glfw/#sdl","text":"Find OpenGL 1 find_package ( OpenGL ) Fetch GLAD 1 2 FetchContent_Declare ( glad GIT_REPOSITORY https://github.com/Dav1dde/glad.git GIT_TAG df8e9e16110b305479a875399cee13daa0ccadd9 ) FetchContent_MakeAvailable ( glad ) Fetch GLFW 1 2 3 4 5 6 set ( GLFW_BUILD_DOCS OFF CACHE BOOL \"\" FORCE ) set ( GLFW_BUILD_EXAMPLES OFF CACHE BOOL \"\" FORCE ) set ( GLFW_BUILD_TESTS OFF CACHE BOOL \"\" FORCE ) set ( GLFW_INSTALL OFF CACHE BOOL \"\" FORCE ) FetchContent_Declare ( glfw GIT_REPOSITORY https://github.com/glfw/glfw.git GIT_TAG 3.3.2 ) FetchContent_MakeAvailable ( glfw ) Link GLFW 1 2 add_executable ( opengl_hello opengl_hello.cpp ) target_link_libraries ( opengl_hello PUBLIC glad glfw ) Share Snippets Headers 1 2 #include <glad/glad.h> #include <GLFW/glfw3.h> Declare callback functions 1 2 void framebuffer_size_callback ( GLFWwindow * window , int width , int height ); void processInput ( GLFWwindow * window ); Initialize GLFW 1 2 3 4 5 6 7 8 glfwInit (); glfwWindowHint ( GLFW_CONTEXT_VERSION_MAJOR , 3 ); glfwWindowHint ( GLFW_CONTEXT_VERSION_MINOR , 3 ); glfwWindowHint ( GLFW_OPENGL_PROFILE , GLFW_OPENGL_CORE_PROFILE ); #ifdef __APPLE__ glfwWindowHint ( GLFW_OPENGL_FORWARD_COMPAT , GL_TRUE ); #endif Create window 1 2 3 4 5 6 7 8 9 10 11 12 const unsigned int SCR_WIDTH = 800 ; const unsigned int SCR_HEIGHT = 600 ; GLFWwindow * window = glfwCreateWindow ( SCR_WIDTH , SCR_HEIGHT , \"LearnOpenGL\" , NULL , NULL ); if ( window == NULL ) { std :: cout << \"Failed to create GLFW window\" << std :: endl ; glfwTerminate (); return -1 ; } glfwMakeContextCurrent ( window ); glfwSetFramebufferSizeCallback ( window , framebuffer_size_callback ); Load OpenGL function pointers 1 2 3 4 if ( ! gladLoadGLLoader (( GLADloadproc ) glfwGetProcAddress )) { std :: cout << \"Failed to initialize GLAD\" << std :: endl ; return -1 ; } Start render loop 1 while ( ! glfwWindowShouldClose ( window )) { Process input 1 processInput ( window ); Render 1 2 glClearColor ( 0.2f , 0.3f , 0.3f , 1.0f ); glClear ( GL_COLOR_BUFFER_BIT ); Swap buffer and poll events 1 2 3 glfwSwapBuffers ( window ); glfwPollEvents (); } Terminate GLFW 1 glfwTerminate (); Function to process input 1 2 3 4 void processInput ( GLFWwindow * window ) { if ( glfwGetKey ( window , GLFW_KEY_ESCAPE ) == GLFW_PRESS ) glfwSetWindowShouldClose ( window , true ); } Function to process window resize 1 2 3 4 5 6 void framebuffer_size_callback ([[ maybe_unused ]] GLFWwindow * window , int width , int height ) { // make sure the viewport matches the new window dimensions; note that width // and height will be significantly larger than specified on retina // displays. glViewport ( 0 , 0 , width , height ); } Share Snippets","title":"SDL"},{"location":"guis/opengl-sdl/","text":"SDL Find SDL 1 find_package ( SDL2 QUIET ) Find GLAD 1 2 3 4 5 if ( SDL2_FOUND ) if ( NOT TARGET glad AND EXPECTED_COMPILER ) FetchContent_Declare ( glad GIT_REPOSITORY https://github.com/Dav1dde/glad.git GIT_TAG df8e9e16110b305479a875399cee13daa0ccadd9 ) FetchContent_MakeAvailable ( glad ) endif () Link SDL 1 2 3 4 5 6 if ( SDL2_FOUND AND EXPECTED_COMPILER ) add_executable ( sdl_hello sdl_hello.cpp ) target_link_libraries ( sdl_hello PUBLIC ${ SDL2_LIBRARIES } glad ) target_include_directories ( sdl_hello PRIVATE ${ SDL2_INCLUDE_DIRS } ) endif () endif () Share Snippets Headers 1 2 3 4 5 6 7 8 #include <glad/glad.h> // SDL #include <SDL.h> #include <SDL_syswm.h> #if defined(__APPLE__) #include \"TargetConditionals.h\" #endif Setup SDL 1 2 3 4 5 6 7 8 9 // (Some versions of SDL before <2.0.10 appears to have performance/stalling // issues on a minority of Windows systems, depending on whether // SDL_INIT_GAMECONTROLLER is enabled or disabled.. updating to latest // version of SDL is recommended!) if ( SDL_Init ( SDL_INIT_VIDEO | SDL_INIT_TIMER | SDL_INIT_GAMECONTROLLER ) != 0 ) { printf ( \"Error: %s \\n \" , SDL_GetError ()); return -1 ; } Decide GL+GLSL versions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #if __APPLE__ // GL 3.2 Core + GLSL 150 // const char *glsl_version = \"#version 150\"; SDL_GL_SetAttribute ( SDL_GL_CONTEXT_FLAGS , SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG ); // Always required on Mac SDL_GL_SetAttribute ( SDL_GL_CONTEXT_PROFILE_MASK , SDL_GL_CONTEXT_PROFILE_CORE ); SDL_GL_SetAttribute ( SDL_GL_CONTEXT_MAJOR_VERSION , 3 ); SDL_GL_SetAttribute ( SDL_GL_CONTEXT_MINOR_VERSION , 2 ); #else // GL 3.0 + GLSL 130 const char * glsl_version = \"#version 130\" ; SDL_GL_SetAttribute ( SDL_GL_CONTEXT_FLAGS , 0 ); SDL_GL_SetAttribute ( SDL_GL_CONTEXT_PROFILE_MASK , SDL_GL_CONTEXT_PROFILE_CORE ); SDL_GL_SetAttribute ( SDL_GL_CONTEXT_MAJOR_VERSION , 3 ); SDL_GL_SetAttribute ( SDL_GL_CONTEXT_MINOR_VERSION , 0 ); #endif Create window with graphics context 1 2 3 4 5 6 7 8 9 10 11 12 SDL_GL_SetAttribute ( SDL_GL_DOUBLEBUFFER , 1 ); SDL_GL_SetAttribute ( SDL_GL_DEPTH_SIZE , 24 ); SDL_GL_SetAttribute ( SDL_GL_STENCIL_SIZE , 8 ); SDL_WindowFlags window_flags = ( SDL_WindowFlags )( SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE | SDL_WINDOW_ALLOW_HIGHDPI ); SDL_Window * window = SDL_CreateWindow ( \"SDL2 Example\" , SDL_WINDOWPOS_CENTERED , SDL_WINDOWPOS_CENTERED , 1280 , 720 , window_flags ); SDL_GLContext gl_context = SDL_GL_CreateContext ( window ); SDL_GL_MakeCurrent ( window , gl_context ); SDL_GL_SetSwapInterval ( 1 ); // Enable vsync Initialize OpenGL loader 1 2 3 4 5 bool err = gladLoadGL () == 0 ; if ( err ) { fprintf ( stderr , \"Failed to initialize OpenGL loader! \\n \" ); return 1 ; } Initialize loop 1 2 bool done = false ; while ( ! done ) { Poll events 1 2 3 4 5 6 7 8 9 10 11 SDL_Event event ; while ( SDL_PollEvent ( & event )) { if ( event . type == SDL_QUIT ) { done = true ; } if ( event . type == SDL_WINDOWEVENT && event . window . event == SDL_WINDOWEVENT_CLOSE && event . window . windowID == SDL_GetWindowID ( window )) { done = true ; } } Update viewport 1 2 3 4 5 glViewport ( 0 , 0 , 600 , 400 ); glClearColor ( 0.45f , 0.55f , 0.60f , 1.00f ); glClear ( GL_COLOR_BUFFER_BIT ); SDL_GL_SwapWindow ( window ); } Close context 1 2 3 SDL_GL_DeleteContext ( gl_context ); SDL_DestroyWindow ( window ); SDL_Quit (); Share Snippets","title":"SDL"},{"location":"guis/opengl-sdl/#sdl","text":"Find SDL 1 find_package ( SDL2 QUIET ) Find GLAD 1 2 3 4 5 if ( SDL2_FOUND ) if ( NOT TARGET glad AND EXPECTED_COMPILER ) FetchContent_Declare ( glad GIT_REPOSITORY https://github.com/Dav1dde/glad.git GIT_TAG df8e9e16110b305479a875399cee13daa0ccadd9 ) FetchContent_MakeAvailable ( glad ) endif () Link SDL 1 2 3 4 5 6 if ( SDL2_FOUND AND EXPECTED_COMPILER ) add_executable ( sdl_hello sdl_hello.cpp ) target_link_libraries ( sdl_hello PUBLIC ${ SDL2_LIBRARIES } glad ) target_include_directories ( sdl_hello PRIVATE ${ SDL2_INCLUDE_DIRS } ) endif () endif () Share Snippets Headers 1 2 3 4 5 6 7 8 #include <glad/glad.h> // SDL #include <SDL.h> #include <SDL_syswm.h> #if defined(__APPLE__) #include \"TargetConditionals.h\" #endif Setup SDL 1 2 3 4 5 6 7 8 9 // (Some versions of SDL before <2.0.10 appears to have performance/stalling // issues on a minority of Windows systems, depending on whether // SDL_INIT_GAMECONTROLLER is enabled or disabled.. updating to latest // version of SDL is recommended!) if ( SDL_Init ( SDL_INIT_VIDEO | SDL_INIT_TIMER | SDL_INIT_GAMECONTROLLER ) != 0 ) { printf ( \"Error: %s \\n \" , SDL_GetError ()); return -1 ; } Decide GL+GLSL versions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #if __APPLE__ // GL 3.2 Core + GLSL 150 // const char *glsl_version = \"#version 150\"; SDL_GL_SetAttribute ( SDL_GL_CONTEXT_FLAGS , SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG ); // Always required on Mac SDL_GL_SetAttribute ( SDL_GL_CONTEXT_PROFILE_MASK , SDL_GL_CONTEXT_PROFILE_CORE ); SDL_GL_SetAttribute ( SDL_GL_CONTEXT_MAJOR_VERSION , 3 ); SDL_GL_SetAttribute ( SDL_GL_CONTEXT_MINOR_VERSION , 2 ); #else // GL 3.0 + GLSL 130 const char * glsl_version = \"#version 130\" ; SDL_GL_SetAttribute ( SDL_GL_CONTEXT_FLAGS , 0 ); SDL_GL_SetAttribute ( SDL_GL_CONTEXT_PROFILE_MASK , SDL_GL_CONTEXT_PROFILE_CORE ); SDL_GL_SetAttribute ( SDL_GL_CONTEXT_MAJOR_VERSION , 3 ); SDL_GL_SetAttribute ( SDL_GL_CONTEXT_MINOR_VERSION , 0 ); #endif Create window with graphics context 1 2 3 4 5 6 7 8 9 10 11 12 SDL_GL_SetAttribute ( SDL_GL_DOUBLEBUFFER , 1 ); SDL_GL_SetAttribute ( SDL_GL_DEPTH_SIZE , 24 ); SDL_GL_SetAttribute ( SDL_GL_STENCIL_SIZE , 8 ); SDL_WindowFlags window_flags = ( SDL_WindowFlags )( SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE | SDL_WINDOW_ALLOW_HIGHDPI ); SDL_Window * window = SDL_CreateWindow ( \"SDL2 Example\" , SDL_WINDOWPOS_CENTERED , SDL_WINDOWPOS_CENTERED , 1280 , 720 , window_flags ); SDL_GLContext gl_context = SDL_GL_CreateContext ( window ); SDL_GL_MakeCurrent ( window , gl_context ); SDL_GL_SetSwapInterval ( 1 ); // Enable vsync Initialize OpenGL loader 1 2 3 4 5 bool err = gladLoadGL () == 0 ; if ( err ) { fprintf ( stderr , \"Failed to initialize OpenGL loader! \\n \" ); return 1 ; } Initialize loop 1 2 bool done = false ; while ( ! done ) { Poll events 1 2 3 4 5 6 7 8 9 10 11 SDL_Event event ; while ( SDL_PollEvent ( & event )) { if ( event . type == SDL_QUIT ) { done = true ; } if ( event . type == SDL_WINDOWEVENT && event . window . event == SDL_WINDOWEVENT_CLOSE && event . window . windowID == SDL_GetWindowID ( window )) { done = true ; } } Update viewport 1 2 3 4 5 glViewport ( 0 , 0 , 600 , 400 ); glClearColor ( 0.45f , 0.55f , 0.60f , 1.00f ); glClear ( GL_COLOR_BUFFER_BIT ); SDL_GL_SwapWindow ( window ); } Close context 1 2 3 SDL_GL_DeleteContext ( gl_context ); SDL_DestroyWindow ( window ); SDL_Quit (); Share Snippets","title":"SDL"},{"location":"guis/qt/","text":"Qt Show message if Qt5Widgets_DIR is not set 1 2 3 4 5 6 7 8 9 10 if ( NOT CMAKE_PREFIX_PATH AND NOT Qt5Widgets_DIR ) message ( \"CMAKE_PREFIX_PATH is not defined, you may need to set it \" \"(-DCMAKE_PREFIX_PATH=\\\" path/to/Qt/lib/cmake\\ \" or -DCMAKE_PREFIX_PATH=/usr/include/{host}/qt{version}/ on Ubuntu)\" ) message ( \"CMAKE_PREFIX_PATH is not defined.\" \"find_package(Qt5) is probably not going to work. \" \" Set the CMAKE_PREFIX_PATH environment variable to the install prefix of Qt 5\" \" - Set it in the command line as -DCMAKE_PREFIX_PATH=\\\" path/to/Qt5/lib/cmake\\ \"\" \" - Or set it in your build script with set(CMAKE_PREFIX_PATH path/to/Qt5/lib/cmake)\" ) endif () Find Qt 1 find_package ( Qt5 COMPONENTS Widgets QUIET ) Enable MOC 1 2 3 set ( CMAKE_AUTOMOC ON ) set ( CMAKE_AUTORCC ON ) set ( CMAKE_AUTOUIC ON ) Link Qt 1 2 add_executable ( qt_helloworld qt_hello.cpp ) target_link_libraries ( qt_helloworld Qt5::Widgets ) Disable MOC 1 2 3 set ( CMAKE_AUTOMOC OFF ) set ( CMAKE_AUTORCC OFF ) set ( CMAKE_AUTOUIC OFF ) Share Snippets Headers 1 2 #include <QApplication> #include <QPushButton> Create Qt Application 1 QApplication app ( argc , argv ); Create window 1 2 QWidget window ; window . setFixedSize ( 100 , 80 ); Create button and attach to window 1 2 auto * buttonInfo = new QPushButton ( \"Info\" , & window ); buttonInfo -> setGeometry ( 10 , 10 , 80 , 30 ); Set button callback 1 2 QApplication :: connect ( buttonInfo , & QPushButton :: clicked , [] { std :: cout << \"Info\" << std :: endl ; }); Create quit button 1 2 auto * buttonQuit = new QPushButton ( \"Quit\" , & window ); buttonQuit -> setGeometry ( 10 , 40 , 80 , 30 ); Set quit button callback 1 2 QApplication :: connect ( buttonQuit , & QPushButton :: clicked , [] { QApplication :: quit (); }); Run application 1 2 window . show (); return app . exec (); Share Snippets","title":"Qt"},{"location":"guis/qt/#qt","text":"Show message if Qt5Widgets_DIR is not set 1 2 3 4 5 6 7 8 9 10 if ( NOT CMAKE_PREFIX_PATH AND NOT Qt5Widgets_DIR ) message ( \"CMAKE_PREFIX_PATH is not defined, you may need to set it \" \"(-DCMAKE_PREFIX_PATH=\\\" path/to/Qt/lib/cmake\\ \" or -DCMAKE_PREFIX_PATH=/usr/include/{host}/qt{version}/ on Ubuntu)\" ) message ( \"CMAKE_PREFIX_PATH is not defined.\" \"find_package(Qt5) is probably not going to work. \" \" Set the CMAKE_PREFIX_PATH environment variable to the install prefix of Qt 5\" \" - Set it in the command line as -DCMAKE_PREFIX_PATH=\\\" path/to/Qt5/lib/cmake\\ \"\" \" - Or set it in your build script with set(CMAKE_PREFIX_PATH path/to/Qt5/lib/cmake)\" ) endif () Find Qt 1 find_package ( Qt5 COMPONENTS Widgets QUIET ) Enable MOC 1 2 3 set ( CMAKE_AUTOMOC ON ) set ( CMAKE_AUTORCC ON ) set ( CMAKE_AUTOUIC ON ) Link Qt 1 2 add_executable ( qt_helloworld qt_hello.cpp ) target_link_libraries ( qt_helloworld Qt5::Widgets ) Disable MOC 1 2 3 set ( CMAKE_AUTOMOC OFF ) set ( CMAKE_AUTORCC OFF ) set ( CMAKE_AUTOUIC OFF ) Share Snippets Headers 1 2 #include <QApplication> #include <QPushButton> Create Qt Application 1 QApplication app ( argc , argv ); Create window 1 2 QWidget window ; window . setFixedSize ( 100 , 80 ); Create button and attach to window 1 2 auto * buttonInfo = new QPushButton ( \"Info\" , & window ); buttonInfo -> setGeometry ( 10 , 10 , 80 , 30 ); Set button callback 1 2 QApplication :: connect ( buttonInfo , & QPushButton :: clicked , [] { std :: cout << \"Info\" << std :: endl ; }); Create quit button 1 2 auto * buttonQuit = new QPushButton ( \"Quit\" , & window ); buttonQuit -> setGeometry ( 10 , 40 , 80 , 30 ); Set quit button callback 1 2 QApplication :: connect ( buttonQuit , & QPushButton :: clicked , [] { QApplication :: quit (); }); Run application 1 2 window . show (); return app . exec (); Share Snippets","title":"Qt"},{"location":"guis/system-tray/","text":"System tray Fetch tray library 1 2 3 4 5 6 FetchContent_Declare ( tray GIT_REPOSITORY https://github.com/wormyrocks/tray.git GIT_TAG 3e4a1447bff413e6907c5e43ac8d65e36866fdfd ) FetchContent_GetProperties ( tray ) Create tray target 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 if ( NOT tray_POPULATED ) FetchContent_Populate ( tray ) add_library ( tray INTERFACE ) target_sources ( tray INTERFACE ${ tray_SOURCE_DIR } /tray.h ) target_include_directories ( tray INTERFACE ${ tray_SOURCE_DIR } ) if ( WIN32 ) target_compile_definitions ( tray INTERFACE TRAY_WINAPI ) elseif ( APPLE ) target_compile_definitions ( tray INTERFACE TRAY_APPKIT ) target_link_libraries ( tray INTERFACE \"-framework Cocoa\" ) # Some warnings the library doesn't deal with target_compile_options ( tray INTERFACE -Wno-unused-parameter ) target_compile_options ( tray INTERFACE -Wno-unused-variable ) target_compile_options ( tray INTERFACE -Wno-writable-strings ) target_compile_options ( tray INTERFACE -Wno-misleading-indentation ) elseif ( UNIX ) target_compile_definitions ( tray INTERFACE TRAY_APPINDICATOR ) target_link_libraries ( tray INTERFACE \"$(shell pkg-config --cflags appindicator3-0.1 --libs appindicator3-0.1)\" ) # Some warnings the library doesn't deal with target_compile_options ( tray INTERFACE -Wno-unused-parameter ) target_compile_options ( tray INTERFACE -Wno-unused-variable ) target_compile_options ( tray INTERFACE -Wno-writable-strings ) target_compile_options ( tray INTERFACE -Wno-misleading-indentation ) endif () endif () Link tray library 1 2 add_executable ( tray_helloworld tray_hello.cpp ) target_link_libraries ( tray_helloworld tray ) Copy tray icons 1 2 3 4 5 if ( WIN32 ) file ( COPY ${ tray_SOURCE_DIR } /icon.ico DESTINATION ${ CMAKE_CURRENT_BINARY_DIR } ) elseif ( APPLE ) file ( COPY ${ tray_SOURCE_DIR } /icon.png DESTINATION ${ CMAKE_CURRENT_BINARY_DIR } ) endif () Share Snippets Headers 1 #include <tray.h> Encapsulate tray and menu options into a class 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 class tray_and_menu { public : tray_and_menu () { // Setup arrays with tray items if ( tray_ . menu != nullptr ) { return ; } tray_ . menu = new tray_menu [ 8 ]; tray_ . menu [ 0 ] = {. text = \"Hello\" , . cb = hello_cb , . submenu = nullptr }; tray_ . menu [ 1 ] = { . text = \"Checked\" , . cb = toggle_cb , . submenu = nullptr }; tray_ . menu [ 2 ] = {. text = \"Disabled\" , . disabled = 1 , . submenu = nullptr }; tray_ . menu [ 3 ] = {. text = \"-\" , . submenu = nullptr }; tray_ . menu [ 4 ] = {. text = \"SubMenu\" , . submenu = new tray_menu [ 3 ]}; tray_ . menu [ 5 ] = {. text = \"-\" , . submenu = nullptr }; tray_ . menu [ 6 ] = {. text = \"Quit\" , . cb = quit_cb , . submenu = nullptr }; tray_ . menu [ 7 ] = {. text = nullptr , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 0 ] = {. text = \"FIRST\" , . checked = 1 , . cb = submenu_cb , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ] = {. text = \"SECOND\" , . submenu = new tray_menu [ 6 ]}; tray_ . menu [ 4 ]. submenu [ 2 ] = {. text = nullptr , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 0 ] = {. text = \"THIRD\" , . submenu = new tray_menu [ 4 ]}; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 1 ] = {. text = \"FOUR\" , . submenu = new tray_menu [ 3 ]}; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 2 ] = {. text = nullptr , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 0 ]. submenu [ 0 ] = { . text = \"7\" , . cb = submenu_cb , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 0 ]. submenu [ 1 ] = {. text = \"-\" , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 0 ]. submenu [ 2 ] = { . text = \"8\" , . cb = submenu_cb , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 0 ]. submenu [ 3 ] = {. text = nullptr , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 1 ]. submenu [ 0 ] = { . text = \"5\" , . cb = submenu_cb , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 1 ]. submenu [ 1 ] = { . text = \"6\" , . cb = submenu_cb , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 1 ]. submenu [ 2 ] = { . text = nullptr , . cb = submenu_cb , . submenu = nullptr }; if ( tray_init ( & tray_ ) < 0 ) { std :: runtime_error ( \"failed to create tray_\" ); } } ~ tray_and_menu () { delete [] tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 1 ]. submenu ; delete [] tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 0 ]. submenu ; delete [] tray_ . menu [ 4 ]. submenu [ 1 ]. submenu ; delete [] tray_ . menu [ 4 ]. submenu ; delete [] tray_ . menu [ 3 ]. submenu ; delete [] tray_ . menu -> submenu ; tray_ . menu -> submenu = nullptr ; } static void run_tray () { while ( tray_loop ( 1 ) == 0 ) { std :: cout << \"Iteration\" << std :: endl ; } } private : static void toggle_cb ( struct tray_menu * item ) { std :: cout << \"toggle cb\" << std :: endl ; item -> checked = ! item -> checked ; tray_update ( & tray_ ); } static void hello_cb ( struct tray_menu * item ) { ( void ) item ; std :: cout << \"hello cb\" << std :: endl ; // NOLINTNEXTLINE(bugprone-branch-clone) if ( strcmp ( tray_ . icon , TRAY_ICON1 ) == 0 ) { tray_ . icon = TRAY_ICON2 ; } else { tray_ . icon = TRAY_ICON1 ; } tray_update ( & tray_ ); } static void quit_cb ( struct tray_menu * item ) { ( void ) item ; std :: cout << \"quit cb\" << std :: endl ; tray_exit (); } static void submenu_cb ( struct tray_menu * item ) { ( void ) item ; std :: cout << \"submenu: clicked on \" << item -> text << std :: endl ; tray_update ( & tray_ ); } private /* members */ : // Tray with pointers to menu static tray tray_ ; }; Instantiate tray 1 tray tray_and_menu :: tray_ {. icon = TRAY_ICON1 , . menu = nullptr }; Run tray 1 2 tray_and_menu t ; tray_and_menu :: run_tray (); Share Snippets","title":"System tray"},{"location":"guis/system-tray/#system-tray","text":"Fetch tray library 1 2 3 4 5 6 FetchContent_Declare ( tray GIT_REPOSITORY https://github.com/wormyrocks/tray.git GIT_TAG 3e4a1447bff413e6907c5e43ac8d65e36866fdfd ) FetchContent_GetProperties ( tray ) Create tray target 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 if ( NOT tray_POPULATED ) FetchContent_Populate ( tray ) add_library ( tray INTERFACE ) target_sources ( tray INTERFACE ${ tray_SOURCE_DIR } /tray.h ) target_include_directories ( tray INTERFACE ${ tray_SOURCE_DIR } ) if ( WIN32 ) target_compile_definitions ( tray INTERFACE TRAY_WINAPI ) elseif ( APPLE ) target_compile_definitions ( tray INTERFACE TRAY_APPKIT ) target_link_libraries ( tray INTERFACE \"-framework Cocoa\" ) # Some warnings the library doesn't deal with target_compile_options ( tray INTERFACE -Wno-unused-parameter ) target_compile_options ( tray INTERFACE -Wno-unused-variable ) target_compile_options ( tray INTERFACE -Wno-writable-strings ) target_compile_options ( tray INTERFACE -Wno-misleading-indentation ) elseif ( UNIX ) target_compile_definitions ( tray INTERFACE TRAY_APPINDICATOR ) target_link_libraries ( tray INTERFACE \"$(shell pkg-config --cflags appindicator3-0.1 --libs appindicator3-0.1)\" ) # Some warnings the library doesn't deal with target_compile_options ( tray INTERFACE -Wno-unused-parameter ) target_compile_options ( tray INTERFACE -Wno-unused-variable ) target_compile_options ( tray INTERFACE -Wno-writable-strings ) target_compile_options ( tray INTERFACE -Wno-misleading-indentation ) endif () endif () Link tray library 1 2 add_executable ( tray_helloworld tray_hello.cpp ) target_link_libraries ( tray_helloworld tray ) Copy tray icons 1 2 3 4 5 if ( WIN32 ) file ( COPY ${ tray_SOURCE_DIR } /icon.ico DESTINATION ${ CMAKE_CURRENT_BINARY_DIR } ) elseif ( APPLE ) file ( COPY ${ tray_SOURCE_DIR } /icon.png DESTINATION ${ CMAKE_CURRENT_BINARY_DIR } ) endif () Share Snippets Headers 1 #include <tray.h> Encapsulate tray and menu options into a class 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 class tray_and_menu { public : tray_and_menu () { // Setup arrays with tray items if ( tray_ . menu != nullptr ) { return ; } tray_ . menu = new tray_menu [ 8 ]; tray_ . menu [ 0 ] = {. text = \"Hello\" , . cb = hello_cb , . submenu = nullptr }; tray_ . menu [ 1 ] = { . text = \"Checked\" , . cb = toggle_cb , . submenu = nullptr }; tray_ . menu [ 2 ] = {. text = \"Disabled\" , . disabled = 1 , . submenu = nullptr }; tray_ . menu [ 3 ] = {. text = \"-\" , . submenu = nullptr }; tray_ . menu [ 4 ] = {. text = \"SubMenu\" , . submenu = new tray_menu [ 3 ]}; tray_ . menu [ 5 ] = {. text = \"-\" , . submenu = nullptr }; tray_ . menu [ 6 ] = {. text = \"Quit\" , . cb = quit_cb , . submenu = nullptr }; tray_ . menu [ 7 ] = {. text = nullptr , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 0 ] = {. text = \"FIRST\" , . checked = 1 , . cb = submenu_cb , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ] = {. text = \"SECOND\" , . submenu = new tray_menu [ 6 ]}; tray_ . menu [ 4 ]. submenu [ 2 ] = {. text = nullptr , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 0 ] = {. text = \"THIRD\" , . submenu = new tray_menu [ 4 ]}; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 1 ] = {. text = \"FOUR\" , . submenu = new tray_menu [ 3 ]}; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 2 ] = {. text = nullptr , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 0 ]. submenu [ 0 ] = { . text = \"7\" , . cb = submenu_cb , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 0 ]. submenu [ 1 ] = {. text = \"-\" , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 0 ]. submenu [ 2 ] = { . text = \"8\" , . cb = submenu_cb , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 0 ]. submenu [ 3 ] = {. text = nullptr , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 1 ]. submenu [ 0 ] = { . text = \"5\" , . cb = submenu_cb , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 1 ]. submenu [ 1 ] = { . text = \"6\" , . cb = submenu_cb , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 1 ]. submenu [ 2 ] = { . text = nullptr , . cb = submenu_cb , . submenu = nullptr }; if ( tray_init ( & tray_ ) < 0 ) { std :: runtime_error ( \"failed to create tray_\" ); } } ~ tray_and_menu () { delete [] tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 1 ]. submenu ; delete [] tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 0 ]. submenu ; delete [] tray_ . menu [ 4 ]. submenu [ 1 ]. submenu ; delete [] tray_ . menu [ 4 ]. submenu ; delete [] tray_ . menu [ 3 ]. submenu ; delete [] tray_ . menu -> submenu ; tray_ . menu -> submenu = nullptr ; } static void run_tray () { while ( tray_loop ( 1 ) == 0 ) { std :: cout << \"Iteration\" << std :: endl ; } } private : static void toggle_cb ( struct tray_menu * item ) { std :: cout << \"toggle cb\" << std :: endl ; item -> checked = ! item -> checked ; tray_update ( & tray_ ); } static void hello_cb ( struct tray_menu * item ) { ( void ) item ; std :: cout << \"hello cb\" << std :: endl ; // NOLINTNEXTLINE(bugprone-branch-clone) if ( strcmp ( tray_ . icon , TRAY_ICON1 ) == 0 ) { tray_ . icon = TRAY_ICON2 ; } else { tray_ . icon = TRAY_ICON1 ; } tray_update ( & tray_ ); } static void quit_cb ( struct tray_menu * item ) { ( void ) item ; std :: cout << \"quit cb\" << std :: endl ; tray_exit (); } static void submenu_cb ( struct tray_menu * item ) { ( void ) item ; std :: cout << \"submenu: clicked on \" << item -> text << std :: endl ; tray_update ( & tray_ ); } private /* members */ : // Tray with pointers to menu static tray tray_ ; }; Instantiate tray 1 tray tray_and_menu :: tray_ {. icon = TRAY_ICON1 , . menu = nullptr }; Run tray 1 2 tray_and_menu t ; tray_and_menu :: run_tray (); Share Snippets","title":"System tray"},{"location":"guis/webview/","text":"Webview Fetch webview 1 2 3 4 5 6 FetchContent_Declare ( webview GIT_REPOSITORY https://github.com/webview/webview.git GIT_TAG 50e4bcc420abdc7be96a54b7c79934a000b76901 ) FetchContent_GetProperties ( webview ) Create webview target 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 if ( NOT webview_POPULATED ) # Library does not have a CMake build script # We have to do it ourselves FetchContent_Populate ( webview ) add_library ( webview INTERFACE ) target_sources ( webview INTERFACE ${ webview_SOURCE_DIR } /webview.h ) target_include_directories ( webview INTERFACE ${ webview_SOURCE_DIR } ) # Set compile options # See: https://github.com/webview/webview/blob/master/script/build.sh if ( WIN32 ) target_compile_definitions ( webview INTERFACE WEBVIEW_EDGE ) # See: https://github.com/webview/webview/blob/master/script/build.bat target_link_libraries ( webview INTERFACE \"-mwindows -L./dll/x64 -lwebview -lWebView2Loader\" ) # target_compile_options(...) ? elseif ( APPLE ) target_compile_definitions ( webview INTERFACE WEBVIEW_COCOA ) target_compile_definitions ( webview INTERFACE \"GUI_SOURCE_DIR=\\\" ${ CMAKE_CURRENT_SOURCE_DIR } \\\"\") target_compile_options(webview INTERFACE -Wno-all -Wno-extra -Wno-pedantic -Wno-delete-non-abstract-non-virtual-dtor ) target_link_libraries ( webview INTERFACE \"-framework WebKit\" ) elseif ( UNIX ) target_compile_definitions ( webview INTERFACE WEBVIEW_GTK ) target_compile_options ( webview INTERFACE -Wall -Wextra -Wpedantic ) target_link_libraries ( webview INTERFACE \"$(pkg-config --cflags --libs gtk+-3.0 webkit2gtk-4.0)\" ) endif () endif () Link webview 1 2 add_executable ( webview_hello webview_hello.cpp ) target_link_libraries ( webview_hello PUBLIC webview ) Share Snippets Headers 1 #include <webview.h> Create a webview 1 2 3 4 webview :: webview w ( true , nullptr ); w . set_title ( \"Example\" ); w . set_size ( 480 , 320 , WEBVIEW_HINT_NONE ); w . set_size ( 180 , 120 , WEBVIEW_HINT_MIN ); Bind javascript function receiving a string 1 2 3 4 w . bind ( \"noop\" , []( std :: string s ) -> std :: string { std :: cout << s << std :: endl ; return s ; }); Bind javascript function receiving two ints 1 2 3 4 5 w . bind ( \"add\" , []( std :: string s ) -> std :: string { auto a = std :: stoi ( webview :: json_parse ( s , \"\" , 0 )); auto b = std :: stoi ( webview :: json_parse ( s , \"\" , 1 )); return std :: to_string ( a + b ); }); Render webview 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 w . navigate ( R \" ( data:text/html, <!doctype html> <html> <body>hello</body> <script> window.onload = function() { document.body.innerText = `hello, ${navigator.userAgent}`; noop('hello').then(function(res) { console.log('noop res', res); }); add(1, 2).then(function(res) { console.log('add res', res); }); }; </script> </html> ) \" ); Run application 1 w . run (); Share Snippets","title":"Webview"},{"location":"guis/webview/#webview","text":"Fetch webview 1 2 3 4 5 6 FetchContent_Declare ( webview GIT_REPOSITORY https://github.com/webview/webview.git GIT_TAG 50e4bcc420abdc7be96a54b7c79934a000b76901 ) FetchContent_GetProperties ( webview ) Create webview target 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 if ( NOT webview_POPULATED ) # Library does not have a CMake build script # We have to do it ourselves FetchContent_Populate ( webview ) add_library ( webview INTERFACE ) target_sources ( webview INTERFACE ${ webview_SOURCE_DIR } /webview.h ) target_include_directories ( webview INTERFACE ${ webview_SOURCE_DIR } ) # Set compile options # See: https://github.com/webview/webview/blob/master/script/build.sh if ( WIN32 ) target_compile_definitions ( webview INTERFACE WEBVIEW_EDGE ) # See: https://github.com/webview/webview/blob/master/script/build.bat target_link_libraries ( webview INTERFACE \"-mwindows -L./dll/x64 -lwebview -lWebView2Loader\" ) # target_compile_options(...) ? elseif ( APPLE ) target_compile_definitions ( webview INTERFACE WEBVIEW_COCOA ) target_compile_definitions ( webview INTERFACE \"GUI_SOURCE_DIR=\\\" ${ CMAKE_CURRENT_SOURCE_DIR } \\\"\") target_compile_options(webview INTERFACE -Wno-all -Wno-extra -Wno-pedantic -Wno-delete-non-abstract-non-virtual-dtor ) target_link_libraries ( webview INTERFACE \"-framework WebKit\" ) elseif ( UNIX ) target_compile_definitions ( webview INTERFACE WEBVIEW_GTK ) target_compile_options ( webview INTERFACE -Wall -Wextra -Wpedantic ) target_link_libraries ( webview INTERFACE \"$(pkg-config --cflags --libs gtk+-3.0 webkit2gtk-4.0)\" ) endif () endif () Link webview 1 2 add_executable ( webview_hello webview_hello.cpp ) target_link_libraries ( webview_hello PUBLIC webview ) Share Snippets Headers 1 #include <webview.h> Create a webview 1 2 3 4 webview :: webview w ( true , nullptr ); w . set_title ( \"Example\" ); w . set_size ( 480 , 320 , WEBVIEW_HINT_NONE ); w . set_size ( 180 , 120 , WEBVIEW_HINT_MIN ); Bind javascript function receiving a string 1 2 3 4 w . bind ( \"noop\" , []( std :: string s ) -> std :: string { std :: cout << s << std :: endl ; return s ; }); Bind javascript function receiving two ints 1 2 3 4 5 w . bind ( \"add\" , []( std :: string s ) -> std :: string { auto a = std :: stoi ( webview :: json_parse ( s , \"\" , 0 )); auto b = std :: stoi ( webview :: json_parse ( s , \"\" , 1 )); return std :: to_string ( a + b ); }); Render webview 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 w . navigate ( R \" ( data:text/html, <!doctype html> <html> <body>hello</body> <script> window.onload = function() { document.body.innerText = `hello, ${navigator.userAgent}`; noop('hello').then(function(res) { console.log('noop res', res); }); add(1, 2).then(function(res) { console.log('add res', res); }); }; </script> </html> ) \" ); Run application 1 w . run (); Share Snippets","title":"Webview"},{"location":"installing-cpp/cling/","text":"Interpreter / Cling If you are using C++ for scientific computing or learning C++, it's often useful to have a C++ interpreter for short experiments. You can install Cling from most package managers for Linux or Mac OS . You can also follow the instructions on their website to download the binaries or build it from source. Although you can use cling directly, it is much more convenient to use the interpreter as a Jupyter notebook kernel. You can follow these instructions to install Jupyter Lab, and these instructions to install the xeus-cling kernel. This creates a beautiful environment for playing with C++ interactively:","title":"Interpreter"},{"location":"installing-cpp/cling/#interpreter-cling","text":"If you are using C++ for scientific computing or learning C++, it's often useful to have a C++ interpreter for short experiments. You can install Cling from most package managers for Linux or Mac OS . You can also follow the instructions on their website to download the binaries or build it from source. Although you can use cling directly, it is much more convenient to use the interpreter as a Jupyter notebook kernel. You can follow these instructions to install Jupyter Lab, and these instructions to install the xeus-cling kernel. This creates a beautiful environment for playing with C++ interactively:","title":"Interpreter / Cling"},{"location":"installing-cpp/cmake/","text":"CMake CMake is the most common build system for C++. Instead of using the compiler directly, CMake controls the compilation process through platform independent configuration files. Install CMake CMake can be downloaded from cmake.org or from a package manager: apt-get Homebrew 1 sudo apt-get -y install cmake 1 brew install cmake Configuration files There should be a file named CMakeLists.txt in the root directory of your project. A starting point is: 1 2 3 4 5 6 7 cmake_minimum_required ( VERSION 3.10 ) # set the project name project ( my_project_name ) # add the executable add_executable ( my_project_name main.cpp ) Building with CMake Create a build directory: 1 mkdir build Navigate to the build directory and run CMake: 1 2 cd build cmake .. This will configure the project and generate a native build system scripts. Then call that build system to actually compile/link the project: 1 cmake --build . The executable file must have been generated. Note how CMake abstracts the differences between compilers and platforms. Configure compiler Set the variable CMAKE_CXX_COMPILER from the command line to let CMake know what compiler to use: 1 cmake -D CMAKE_C_COMPILER = \"/path/to/your/c/compiler/executable\" -D CMAKE_CXX_COMPILER \"/path/to/your/cpp/compiler/executable\" /path/to/directory/containing/CMakeLists.txt If you want this to be your default compiler, you can set the CXX environment variable: 1 export CXX = /path/to/your/cpp/compiler/executable If you want to use this compiler in a single project, always run CMake with these options: 1 -DCMAKE_C_COMPILER = /path/to/your/c/compiler/executable -DCMAKE_CXX_COMPILER = /path/to/your/cpp/compiler/executable Or tell your IDE to pass these options to CMake:","title":"CMake"},{"location":"installing-cpp/cmake/#cmake","text":"CMake is the most common build system for C++. Instead of using the compiler directly, CMake controls the compilation process through platform independent configuration files.","title":"CMake"},{"location":"installing-cpp/cmake/#install-cmake","text":"CMake can be downloaded from cmake.org or from a package manager: apt-get Homebrew 1 sudo apt-get -y install cmake 1 brew install cmake","title":"Install CMake"},{"location":"installing-cpp/cmake/#configuration-files","text":"There should be a file named CMakeLists.txt in the root directory of your project. A starting point is: 1 2 3 4 5 6 7 cmake_minimum_required ( VERSION 3.10 ) # set the project name project ( my_project_name ) # add the executable add_executable ( my_project_name main.cpp )","title":"Configuration files"},{"location":"installing-cpp/cmake/#building-with-cmake","text":"Create a build directory: 1 mkdir build Navigate to the build directory and run CMake: 1 2 cd build cmake .. This will configure the project and generate a native build system scripts. Then call that build system to actually compile/link the project: 1 cmake --build . The executable file must have been generated. Note how CMake abstracts the differences between compilers and platforms.","title":"Building with CMake"},{"location":"installing-cpp/cmake/#configure-compiler","text":"Set the variable CMAKE_CXX_COMPILER from the command line to let CMake know what compiler to use: 1 cmake -D CMAKE_C_COMPILER = \"/path/to/your/c/compiler/executable\" -D CMAKE_CXX_COMPILER \"/path/to/your/cpp/compiler/executable\" /path/to/directory/containing/CMakeLists.txt If you want this to be your default compiler, you can set the CXX environment variable: 1 export CXX = /path/to/your/cpp/compiler/executable If you want to use this compiler in a single project, always run CMake with these options: 1 -DCMAKE_C_COMPILER = /path/to/your/c/compiler/executable -DCMAKE_CXX_COMPILER = /path/to/your/cpp/compiler/executable Or tell your IDE to pass these options to CMake:","title":"Configure compiler"},{"location":"installing-cpp/compiler/","text":"Windows + MSVC Update your Visual Studio Compiler. The most recent version of Visual Studio should include C++20. Linux + GCC Update GCC: 1 2 3 4 5 6 7 8 9 10 # Repository sudo apt install build-essential sudo add-apt-repository ppa:ubuntu-toolchain-r/test sudo apt-get update # Install sudo apt install gcc-11 sudo apt install g++-11 # Install as compiler alternative sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11 11 sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-11 11 Set your default compiler with: 1 update-alternatives --config g++ Mac OS + Clang Download a recent version of Clang: 1 2 3 curl --output clang.tar.xz -L https://github.com/llvm/llvm-project/releases/download/llvmorg-13.0.1/clang+llvm-13.0.1-x86_64-apple-darwin.tar.xz mkdir clang tar -xvJf clang.tar.xz -C clang Copy these files to usr/local/ : 1 2 cd clang/clang+llvm-13.0.1-x86_64-apple-darwin sudo cp -R * /usr/local/","title":"Compiler"},{"location":"installing-cpp/compiler/#windows-msvc","text":"Update your Visual Studio Compiler. The most recent version of Visual Studio should include C++20.","title":"Windows + MSVC"},{"location":"installing-cpp/compiler/#linux-gcc","text":"Update GCC: 1 2 3 4 5 6 7 8 9 10 # Repository sudo apt install build-essential sudo add-apt-repository ppa:ubuntu-toolchain-r/test sudo apt-get update # Install sudo apt install gcc-11 sudo apt install g++-11 # Install as compiler alternative sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11 11 sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-11 11 Set your default compiler with: 1 update-alternatives --config g++","title":"Linux + GCC"},{"location":"installing-cpp/compiler/#mac-os-clang","text":"Download a recent version of Clang: 1 2 3 curl --output clang.tar.xz -L https://github.com/llvm/llvm-project/releases/download/llvmorg-13.0.1/clang+llvm-13.0.1-x86_64-apple-darwin.tar.xz mkdir clang tar -xvJf clang.tar.xz -C clang Copy these files to usr/local/ : 1 2 cd clang/clang+llvm-13.0.1-x86_64-apple-darwin sudo cp -R * /usr/local/","title":"Mac OS + Clang"},{"location":"installing-cpp/ides/","text":"IDEs These are the most common IDEs and text editors most commonly used for C++ programming: IDE or Text Editor Users Notes Visual Studio 28% Windows Vim 17% (Text Editor) Qt Creator 12% Best for Qt Users Visual Studio Code 10% CLion 9% Emacs 7% (Text Editor) Xcode 4% Mac OS Eclipse 4% Others 9% Warning These numbers are constantly changing.","title":"IDEs"},{"location":"installing-cpp/ides/#ides","text":"These are the most common IDEs and text editors most commonly used for C++ programming: IDE or Text Editor Users Notes Visual Studio 28% Windows Vim 17% (Text Editor) Qt Creator 12% Best for Qt Users Visual Studio Code 10% CLion 9% Emacs 7% (Text Editor) Xcode 4% Mac OS Eclipse 4% Others 9% Warning These numbers are constantly changing.","title":"IDEs"},{"location":"installing-cpp/webassembly/","text":"WebAssembly / Emscripten If you are programming for the web, a common option for C++ and WebAssembly is emscripten . You can install emscripten from most package managers for Windows , Linux , or Mac OS . You can also follow the instructions on their website to build from source. Then follow these instructions to compile your first \"Hello World!\" for the web. Your C++ program will become this beautiful webpage:","title":"WebAssembly"},{"location":"installing-cpp/webassembly/#webassembly-emscripten","text":"If you are programming for the web, a common option for C++ and WebAssembly is emscripten . You can install emscripten from most package managers for Windows , Linux , or Mac OS . You can also follow the instructions on their website to build from source. Then follow these instructions to compile your first \"Hello World!\" for the web. Your C++ program will become this beautiful webpage:","title":"WebAssembly / Emscripten"},{"location":"programming-paradigms/basic-paradigms/crtp/","text":"Curiously Recurring Template Pattern Curiously Recurring Template Pattern The Curiously Recurring Template Pattern is an idiom in which a class X derives from a class template Y , taking a template parameter Z , where Y is instantiated with Z=X . CRTP may be used to implement \"compile-time polymorphism\", when a base class exposes an interface, and derived classes implement such interface. Declare shape class with derived type as template parameter 1 2 3 4 template < typename derived > class shape { public : virtual derived clone () { return static_cast < derived > ( * this ); }; }; Inherits from base and base has derived as a template parameter 1 2 3 4 5 6 7 class square : public shape < square > { public : square () = default ; explicit square ( const shape & ){}; // CRTP: Clone can return a square even though it's derived from shape square clone () override { return * this ; } }; Use a template dependant function 1 2 square a ; square b = a . clone (); Print addresses 1 2 3 std :: cout << \"The square has been cloned as a real square\" << '\\n' ; std :: cout << \"&a: \" << & a << '\\n' ; std :: cout << \"&b: \" << & b << '\\n' ; Share Snippets","title":"CRTP"},{"location":"programming-paradigms/basic-paradigms/crtp/#curiously-recurring-template-pattern","text":"Curiously Recurring Template Pattern The Curiously Recurring Template Pattern is an idiom in which a class X derives from a class template Y , taking a template parameter Z , where Y is instantiated with Z=X . CRTP may be used to implement \"compile-time polymorphism\", when a base class exposes an interface, and derived classes implement such interface. Declare shape class with derived type as template parameter 1 2 3 4 template < typename derived > class shape { public : virtual derived clone () { return static_cast < derived > ( * this ); }; }; Inherits from base and base has derived as a template parameter 1 2 3 4 5 6 7 class square : public shape < square > { public : square () = default ; explicit square ( const shape & ){}; // CRTP: Clone can return a square even though it's derived from shape square clone () override { return * this ; } }; Use a template dependant function 1 2 square a ; square b = a . clone (); Print addresses 1 2 3 std :: cout << \"The square has been cloned as a real square\" << '\\n' ; std :: cout << \"&a: \" << & a << '\\n' ; std :: cout << \"&b: \" << & b << '\\n' ; Share Snippets","title":"Curiously Recurring Template Pattern"},{"location":"programming-paradigms/basic-paradigms/polymorphism/","text":"Polymorphism Polymorphism Object Oriented programming (OOP) is a programming paradigm that relies on the concept of classes and objects. It is used to structure a software program into simple, reusable pieces of code blueprints (usually called classes), which are used to create individual instances of objects. One of the key features of class inheritance is that a pointer to a derived class is type-compatible with a pointer to its base class. Polymorphism is the art of taking advantage of this simple but powerful and versatile feature. Declare class 1 2 class shape { public : Default constructor 1 shape () : _side1 ( 0 ), _side2 ( 0 ) {} Constructor from double 1 explicit shape ( double side ) : _side1 ( side ), _side2 ( side ) {} Constructor from two doubles 1 shape ( double side1 , double side2 ) : _side1 ( side1 ), _side2 ( side2 ) {} Default Destructor 1 virtual ~ shape () = default ; Member function 1 virtual double area () { return 0 ; } Equality operators to compare shapes 1 2 3 4 5 bool operator == ( const shape & rhs ) const { return _side1 == rhs . _side1 && _side2 == rhs . _side2 ; } bool operator != ( const shape & rhs ) const { return ! ( rhs == * this ); } Protected members 1 2 3 protected : double _side1 ; double _side2 ; Triangle Inheritance 1 2 3 4 5 6 7 8 9 10 11 class triangle : public shape { public : // Reuse base class constructors using shape :: shape ; // Default destructor ~ triangle () override = default ; // Override area member function double area () override { return this -> _side1 * this -> _side2 / 2 ; } }; Square Inheritance 1 2 3 4 5 6 7 8 9 10 11 class square : public shape { public : // Reuse base class constructors using shape :: shape ; // Default destructor ~ square () override = default ; // Override area member function double area () override { return this -> _side1 * this -> _side2 ; } }; Store a square as an abstract shape 1 std :: unique_ptr < shape > p = std :: make_unique < square > ( 42 ); Store both triangles and squares as abstract shapes 1 2 3 4 5 6 7 8 std :: vector < std :: unique_ptr < shape >> v ( 30 ); for ( size_t i = 0 ; i < v . size (); ++ i ) { if ( i % 2 ) { v [ i ] = std :: make_unique < triangle > ( i + 30 ); } else { v [ i ] = std :: make_unique < square > ( i + 30 ); } } Iterate shape derived objects 1 2 3 4 5 6 7 8 9 10 11 12 for ( std :: unique_ptr < shape > & item : v ) { if ( dynamic_cast < triangle *> ( item . get ())) { std :: cout << \"This shape is a triangle \\n \" ; } else if ( dynamic_cast < square *> ( item . get ())) { std :: cout << \"This shape is a square \\n \" ; } else if ( dynamic_cast < shape *> ( item . get ())) { std :: cout << \"This is an abstract shape \\n \" ; } if ( item && * item == * p ) { std :: cout << \"It has the same area as p: \" << item -> area () << '\\n' ; } } Share Snippets","title":"Polymorphism"},{"location":"programming-paradigms/basic-paradigms/polymorphism/#polymorphism","text":"Polymorphism Object Oriented programming (OOP) is a programming paradigm that relies on the concept of classes and objects. It is used to structure a software program into simple, reusable pieces of code blueprints (usually called classes), which are used to create individual instances of objects. One of the key features of class inheritance is that a pointer to a derived class is type-compatible with a pointer to its base class. Polymorphism is the art of taking advantage of this simple but powerful and versatile feature. Declare class 1 2 class shape { public : Default constructor 1 shape () : _side1 ( 0 ), _side2 ( 0 ) {} Constructor from double 1 explicit shape ( double side ) : _side1 ( side ), _side2 ( side ) {} Constructor from two doubles 1 shape ( double side1 , double side2 ) : _side1 ( side1 ), _side2 ( side2 ) {} Default Destructor 1 virtual ~ shape () = default ; Member function 1 virtual double area () { return 0 ; } Equality operators to compare shapes 1 2 3 4 5 bool operator == ( const shape & rhs ) const { return _side1 == rhs . _side1 && _side2 == rhs . _side2 ; } bool operator != ( const shape & rhs ) const { return ! ( rhs == * this ); } Protected members 1 2 3 protected : double _side1 ; double _side2 ; Triangle Inheritance 1 2 3 4 5 6 7 8 9 10 11 class triangle : public shape { public : // Reuse base class constructors using shape :: shape ; // Default destructor ~ triangle () override = default ; // Override area member function double area () override { return this -> _side1 * this -> _side2 / 2 ; } }; Square Inheritance 1 2 3 4 5 6 7 8 9 10 11 class square : public shape { public : // Reuse base class constructors using shape :: shape ; // Default destructor ~ square () override = default ; // Override area member function double area () override { return this -> _side1 * this -> _side2 ; } }; Store a square as an abstract shape 1 std :: unique_ptr < shape > p = std :: make_unique < square > ( 42 ); Store both triangles and squares as abstract shapes 1 2 3 4 5 6 7 8 std :: vector < std :: unique_ptr < shape >> v ( 30 ); for ( size_t i = 0 ; i < v . size (); ++ i ) { if ( i % 2 ) { v [ i ] = std :: make_unique < triangle > ( i + 30 ); } else { v [ i ] = std :: make_unique < square > ( i + 30 ); } } Iterate shape derived objects 1 2 3 4 5 6 7 8 9 10 11 12 for ( std :: unique_ptr < shape > & item : v ) { if ( dynamic_cast < triangle *> ( item . get ())) { std :: cout << \"This shape is a triangle \\n \" ; } else if ( dynamic_cast < square *> ( item . get ())) { std :: cout << \"This shape is a square \\n \" ; } else if ( dynamic_cast < shape *> ( item . get ())) { std :: cout << \"This is an abstract shape \\n \" ; } if ( item && * item == * p ) { std :: cout << \"It has the same area as p: \" << item -> area () << '\\n' ; } } Share Snippets","title":"Polymorphism"},{"location":"programming-paradigms/basic-paradigms/shared-from-this/","text":"Shared from this Shared from this std::enable_shared_from_this allows an object t that is currently managed by a std::shared_ptr named pt to safely generate additional std::shared_ptr instances pt1 , pt2 , ... that all share ownership of t with pt . Publicly inheriting from std::enable_shared_from_this<T> provides the type T with a member function shared_from_this . If an object t of type T is managed by a std::shared_ptr<T> named pt , then calling T::shared_from_this will return a new std::shared_ptr<T> that shares ownership of t with pt . A shared class that say hello 1 2 3 4 class hello_printer : public std :: enable_shared_from_this < hello_printer > { public : // Main class function void say_hello () { std :: cout << \"Hello, World!\" << '\\n' ; } A factory function to create instances of hello_printer 1 2 3 4 5 6 7 8 static std :: shared_ptr < hello_printer > create () { return std :: shared_ptr < hello_printer > ( new hello_printer ()); } private : // New objects need to be created with the factory hello_printer () = default ; }; Create a hello printer 1 2 3 4 auto y = hello_printer :: create (); y -> say_hello (); std :: cout << \"y.get() = \" << y . get () << '\\n' ; std :: cout << \"&y = \" << & y << '\\n' ; Share the hello printer 1 2 3 4 5 // y2 will also point to the same object as y std :: shared_ptr < hello_printer > y2 = y -> shared_from_this (); y2 -> say_hello (); std :: cout << \"y2.get() = \" << y2 . get () << '\\n' ; std :: cout << \"&y2 = \" << & y2 << '\\n' ; Create an independent hello printer 1 2 3 4 auto z = hello_printer :: create (); z -> say_hello (); std :: cout << \"z.get() = \" << z . get () << '\\n' ; std :: cout << \"&z = \" << & z << '\\n' ; Share Snippets","title":"Shared from this"},{"location":"programming-paradigms/basic-paradigms/shared-from-this/#shared-from-this","text":"Shared from this std::enable_shared_from_this allows an object t that is currently managed by a std::shared_ptr named pt to safely generate additional std::shared_ptr instances pt1 , pt2 , ... that all share ownership of t with pt . Publicly inheriting from std::enable_shared_from_this<T> provides the type T with a member function shared_from_this . If an object t of type T is managed by a std::shared_ptr<T> named pt , then calling T::shared_from_this will return a new std::shared_ptr<T> that shares ownership of t with pt . A shared class that say hello 1 2 3 4 class hello_printer : public std :: enable_shared_from_this < hello_printer > { public : // Main class function void say_hello () { std :: cout << \"Hello, World!\" << '\\n' ; } A factory function to create instances of hello_printer 1 2 3 4 5 6 7 8 static std :: shared_ptr < hello_printer > create () { return std :: shared_ptr < hello_printer > ( new hello_printer ()); } private : // New objects need to be created with the factory hello_printer () = default ; }; Create a hello printer 1 2 3 4 auto y = hello_printer :: create (); y -> say_hello (); std :: cout << \"y.get() = \" << y . get () << '\\n' ; std :: cout << \"&y = \" << & y << '\\n' ; Share the hello printer 1 2 3 4 5 // y2 will also point to the same object as y std :: shared_ptr < hello_printer > y2 = y -> shared_from_this (); y2 -> say_hello (); std :: cout << \"y2.get() = \" << y2 . get () << '\\n' ; std :: cout << \"&y2 = \" << & y2 << '\\n' ; Create an independent hello printer 1 2 3 4 auto z = hello_printer :: create (); z -> say_hello (); std :: cout << \"z.get() = \" << z . get () << '\\n' ; std :: cout << \"&z = \" << & z << '\\n' ; Share Snippets","title":"Shared from this"},{"location":"programming-paradigms/parallelism/async/","text":"Async++ Async++ There have been many proposals to extend the C++ model of futures. Most proposals involve the capability of continuations without polling. One of this proposals is N3428, inspired by the Microsoft PPL library. Async++ is a lightweight library that implements the concept. CMakeLists.txt 1 2 3 4 5 FetchContent_Declare ( asyncplusplus GIT_REPOSITORY https://github.com/Amanieu/asyncplusplus.git GIT_TAG v1.1 ) FetchContent_MakeAvailable ( asyncplusplus ) add_executable ( async_pools async_pools.cpp ) target_link_libraries ( async_pools PUBLIC Async++ ) target_compile_features ( async_pools PUBLIC cxx_std_17 ) Launch tasks 1 2 3 4 5 6 7 auto task1 = async :: spawn ( [] { std :: cout << \"Task 1 executes asynchronously\" << '\\n' ; }); auto task2 = async :: spawn ([]() -> int { std :: cout << \"Task 2 executes in parallel with task 1\" << '\\n' ; return 42 ; }); Task continuation 1 2 3 4 5 auto task3 = task2 . then ([]( int value ) -> int { std :: cout << \"Task 3 executes after task 2, which returned \" << value << '\\n' ; return value * 3 ; }); Task conjunctions 1 2 3 4 5 6 auto task4 = async :: when_all ( task1 , task3 ); auto task5 = task4 . then ([]( std :: tuple < async :: task < void > , async :: task < int >> results ) { std :: cout << \"Task 5 executes after tasks 1 and 3. Task 3 returned \" << std :: get < 1 > ( results ). get () << '\\n' ; }); Get task results 1 2 task5 . get (); std :: cout << \"Task 5 has completed\" << '\\n' ; Parallel invoke 1 2 3 async :: parallel_invoke ( [] { std :: cout << \"This is executed in parallel...\" << '\\n' ; }, [] { std :: cout << \"with this\" << '\\n' ; }); Parallel for 1 2 async :: parallel_for ( async :: irange ( 0 , 5 ), []( int x ) { std :: cout << x ; }); std :: cout << '\\n' ; Parallel reduce 1 2 3 int r = async :: parallel_reduce ({ 1 , 2 , 3 , 4 }, 0 , []( int x , int y ) { return x + y ; }); std :: cout << \"The sum of {1, 2, 3, 4} is \" << r << '\\n' ; Share Snippets","title":"Async++"},{"location":"programming-paradigms/parallelism/async/#async","text":"Async++ There have been many proposals to extend the C++ model of futures. Most proposals involve the capability of continuations without polling. One of this proposals is N3428, inspired by the Microsoft PPL library. Async++ is a lightweight library that implements the concept. CMakeLists.txt 1 2 3 4 5 FetchContent_Declare ( asyncplusplus GIT_REPOSITORY https://github.com/Amanieu/asyncplusplus.git GIT_TAG v1.1 ) FetchContent_MakeAvailable ( asyncplusplus ) add_executable ( async_pools async_pools.cpp ) target_link_libraries ( async_pools PUBLIC Async++ ) target_compile_features ( async_pools PUBLIC cxx_std_17 ) Launch tasks 1 2 3 4 5 6 7 auto task1 = async :: spawn ( [] { std :: cout << \"Task 1 executes asynchronously\" << '\\n' ; }); auto task2 = async :: spawn ([]() -> int { std :: cout << \"Task 2 executes in parallel with task 1\" << '\\n' ; return 42 ; }); Task continuation 1 2 3 4 5 auto task3 = task2 . then ([]( int value ) -> int { std :: cout << \"Task 3 executes after task 2, which returned \" << value << '\\n' ; return value * 3 ; }); Task conjunctions 1 2 3 4 5 6 auto task4 = async :: when_all ( task1 , task3 ); auto task5 = task4 . then ([]( std :: tuple < async :: task < void > , async :: task < int >> results ) { std :: cout << \"Task 5 executes after tasks 1 and 3. Task 3 returned \" << std :: get < 1 > ( results ). get () << '\\n' ; }); Get task results 1 2 task5 . get (); std :: cout << \"Task 5 has completed\" << '\\n' ; Parallel invoke 1 2 3 async :: parallel_invoke ( [] { std :: cout << \"This is executed in parallel...\" << '\\n' ; }, [] { std :: cout << \"with this\" << '\\n' ; }); Parallel for 1 2 async :: parallel_for ( async :: irange ( 0 , 5 ), []( int x ) { std :: cout << x ; }); std :: cout << '\\n' ; Parallel reduce 1 2 3 int r = async :: parallel_reduce ({ 1 , 2 , 3 , 4 }, 0 , []( int x , int y ) { return x + y ; }); std :: cout << \"The sum of {1, 2, 3, 4} is \" << r << '\\n' ; Share Snippets","title":"Async++"},{"location":"programming-paradigms/parallelism/build-script/","text":"Build script 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 # https://stackoverflow.com/questions/66881657/ubuntu-18-gcc-9-failed-to-link-tbb-library-for-execution-policy-in-standard-lib #[policies CMakeLists.txt find_package ( Threads ) find_package ( Execution ) find_library ( TBB_LIBRARY NAMES tbb ) if ( Execution_FOUND AND TBB_LIBRARY ) add_executable ( policies policies.cpp ) target_link_libraries ( policies PUBLIC std::execution Threads::Threads ${ TBB_LIBRARIES } ) endif () #] #[threads CMakeLists.txt find_package ( Threads ) add_executable ( multithreading multithreading.cpp ) target_link_libraries ( multithreading PUBLIC Threads::Threads ) #] #[find_asio Find ASIO find_package ( Asio 1.21.0 QUIET ) if ( NOT Asio_FOUND ) FetchContent_Declare ( asio GIT_REPOSITORY https://github.com/chriskohlhoff/asio.git GIT_TAG asio-1-21-0 ) FetchContent_GetProperties ( asio ) if ( NOT asio_POPULATED ) FetchContent_Populate ( asio ) add_library ( asio INTERFACE ) target_include_directories ( asio INTERFACE ${ asio_SOURCE_DIR } /asio/include ) target_compile_definitions ( asio INTERFACE ASIO_STANDALONE ASIO_NO_DEPRECATED ) target_link_libraries ( asio INTERFACE Threads::Threads ) endif () endif () #] # The executor libraries in ASIO do not have lots of convenience functions # but they are a good reference for the executor proposal #[executors CMakeLists.txt add_executable ( executors executors.cpp ) target_link_libraries ( executors asio ) #] #[timers CMakeLists.txt add_executable ( timers timers.cpp ) target_link_libraries ( timers asio ) #] #[signals CMakeLists.txt add_executable ( signals signals.cpp ) target_link_libraries ( signals asio ) #] # Async++ has good convenience functions/algorithms for parallel computing # But it's about to be completely replaced by the traditional executors in C++23 # Replace this library as soon as we have an alternative based on executors # Async++ # The build script has a few problems # - stdlib++ whenever the platform is APPLE. The user might not be using stdlib++ # - it doesn't seem to be working on more recent MSVC compilers # - it doesn't seem to be working on more recent Clang compilers if ( GCC ) #[asyncplusplus CMakeLists.txt FetchContent_Declare ( asyncplusplus GIT_REPOSITORY https://github.com/Amanieu/asyncplusplus.git GIT_TAG v1.1 ) FetchContent_MakeAvailable ( asyncplusplus ) add_executable ( async_pools async_pools.cpp ) target_link_libraries ( async_pools PUBLIC Async++ ) target_compile_features ( async_pools PUBLIC cxx_std_17 ) #] endif ()","title":"Build script"},{"location":"programming-paradigms/parallelism/build-script/#build-script","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 # https://stackoverflow.com/questions/66881657/ubuntu-18-gcc-9-failed-to-link-tbb-library-for-execution-policy-in-standard-lib #[policies CMakeLists.txt find_package ( Threads ) find_package ( Execution ) find_library ( TBB_LIBRARY NAMES tbb ) if ( Execution_FOUND AND TBB_LIBRARY ) add_executable ( policies policies.cpp ) target_link_libraries ( policies PUBLIC std::execution Threads::Threads ${ TBB_LIBRARIES } ) endif () #] #[threads CMakeLists.txt find_package ( Threads ) add_executable ( multithreading multithreading.cpp ) target_link_libraries ( multithreading PUBLIC Threads::Threads ) #] #[find_asio Find ASIO find_package ( Asio 1.21.0 QUIET ) if ( NOT Asio_FOUND ) FetchContent_Declare ( asio GIT_REPOSITORY https://github.com/chriskohlhoff/asio.git GIT_TAG asio-1-21-0 ) FetchContent_GetProperties ( asio ) if ( NOT asio_POPULATED ) FetchContent_Populate ( asio ) add_library ( asio INTERFACE ) target_include_directories ( asio INTERFACE ${ asio_SOURCE_DIR } /asio/include ) target_compile_definitions ( asio INTERFACE ASIO_STANDALONE ASIO_NO_DEPRECATED ) target_link_libraries ( asio INTERFACE Threads::Threads ) endif () endif () #] # The executor libraries in ASIO do not have lots of convenience functions # but they are a good reference for the executor proposal #[executors CMakeLists.txt add_executable ( executors executors.cpp ) target_link_libraries ( executors asio ) #] #[timers CMakeLists.txt add_executable ( timers timers.cpp ) target_link_libraries ( timers asio ) #] #[signals CMakeLists.txt add_executable ( signals signals.cpp ) target_link_libraries ( signals asio ) #] # Async++ has good convenience functions/algorithms for parallel computing # But it's about to be completely replaced by the traditional executors in C++23 # Replace this library as soon as we have an alternative based on executors # Async++ # The build script has a few problems # - stdlib++ whenever the platform is APPLE. The user might not be using stdlib++ # - it doesn't seem to be working on more recent MSVC compilers # - it doesn't seem to be working on more recent Clang compilers if ( GCC ) #[asyncplusplus CMakeLists.txt FetchContent_Declare ( asyncplusplus GIT_REPOSITORY https://github.com/Amanieu/asyncplusplus.git GIT_TAG v1.1 ) FetchContent_MakeAvailable ( asyncplusplus ) add_executable ( async_pools async_pools.cpp ) target_link_libraries ( async_pools PUBLIC Async++ ) target_compile_features ( async_pools PUBLIC cxx_std_17 ) #] endif ()","title":"Build script"},{"location":"programming-paradigms/parallelism/execution-policies/","text":"Execution Policies Execution Policies Most algorithms have overloads that accept execution policies . The standard library algorithms support several execution policies, and the library provides corresponding execution policy types and objects. Users may select an execution policy statically by invoking a parallel algorithm with an execution policy object of the corresponding type. CMakeLists.txt 1 2 3 4 5 6 7 find_package ( Threads ) find_package ( Execution ) find_library ( TBB_LIBRARY NAMES tbb ) if ( Execution_FOUND AND TBB_LIBRARY ) add_executable ( policies policies.cpp ) target_link_libraries ( policies PUBLIC std::execution Threads::Threads ${ TBB_LIBRARIES } ) endif () Execution may not be parallelized 1 2 3 4 std :: vector < int > x { 5 , 7 , 6 , 4 , 8 , 2 }; std :: sort ( std :: execution :: seq , x . begin (), x . end ()); std :: copy ( x . begin (), x . end (), std :: ostream_iterator < int > { std :: cout , \" \" }); std :: cout << '\\n' ; Execution may be parallelized 1 2 3 4 std :: vector < int > y { 5 , 7 , 6 , 4 , 8 , 2 }; std :: sort ( std :: execution :: par , y . begin (), y . end ()); std :: copy ( y . begin (), y . end (), std :: ostream_iterator < int > { std :: cout , \" \" }); std :: cout << '\\n' ; Execution may be parallelized, vectorized, or migrated across threads 1 2 3 4 std :: vector < int > z { 5 , 7 , 6 , 4 , 8 , 2 }; std :: sort ( std :: execution :: par_unseq , z . begin (), z . end ()); std :: copy ( z . begin (), z . end (), std :: ostream_iterator < int > { std :: cout , \" \" }); std :: cout << '\\n' ; Execution may be vectorized 1 2 3 4 std :: vector < int > w { 5 , 7 , 6 , 4 , 8 , 2 }; std :: sort ( std :: execution :: unseq , w . begin (), w . end ()); std :: copy ( w . begin (), w . end (), std :: ostream_iterator < int > { std :: cout , \" \" }); std :: cout << '\\n' ; Share Snippets","title":"Execution Policies"},{"location":"programming-paradigms/parallelism/execution-policies/#execution-policies","text":"Execution Policies Most algorithms have overloads that accept execution policies . The standard library algorithms support several execution policies, and the library provides corresponding execution policy types and objects. Users may select an execution policy statically by invoking a parallel algorithm with an execution policy object of the corresponding type. CMakeLists.txt 1 2 3 4 5 6 7 find_package ( Threads ) find_package ( Execution ) find_library ( TBB_LIBRARY NAMES tbb ) if ( Execution_FOUND AND TBB_LIBRARY ) add_executable ( policies policies.cpp ) target_link_libraries ( policies PUBLIC std::execution Threads::Threads ${ TBB_LIBRARIES } ) endif () Execution may not be parallelized 1 2 3 4 std :: vector < int > x { 5 , 7 , 6 , 4 , 8 , 2 }; std :: sort ( std :: execution :: seq , x . begin (), x . end ()); std :: copy ( x . begin (), x . end (), std :: ostream_iterator < int > { std :: cout , \" \" }); std :: cout << '\\n' ; Execution may be parallelized 1 2 3 4 std :: vector < int > y { 5 , 7 , 6 , 4 , 8 , 2 }; std :: sort ( std :: execution :: par , y . begin (), y . end ()); std :: copy ( y . begin (), y . end (), std :: ostream_iterator < int > { std :: cout , \" \" }); std :: cout << '\\n' ; Execution may be parallelized, vectorized, or migrated across threads 1 2 3 4 std :: vector < int > z { 5 , 7 , 6 , 4 , 8 , 2 }; std :: sort ( std :: execution :: par_unseq , z . begin (), z . end ()); std :: copy ( z . begin (), z . end (), std :: ostream_iterator < int > { std :: cout , \" \" }); std :: cout << '\\n' ; Execution may be vectorized 1 2 3 4 std :: vector < int > w { 5 , 7 , 6 , 4 , 8 , 2 }; std :: sort ( std :: execution :: unseq , w . begin (), w . end ()); std :: copy ( w . begin (), w . end (), std :: ostream_iterator < int > { std :: cout , \" \" }); std :: cout << '\\n' ; Share Snippets","title":"Execution Policies"},{"location":"programming-paradigms/parallelism/executors/","text":"Executors Executors A standard executor represents a policy as to how, when, and where a piece of code should be executed. The standard library does not include executors for parallel algorihms. Boost.Asio provides a complete implementation of the proposed standard executors. Creating an execution context, such as a thread pool Execution context: place where we can execute functions A thread pool is an execution context. An execution context is: Usually long lived. Non-copyable. May contain additional state, such as timers, and threads Creating an executor from an executor context: Executor: set of rules governing where, when and how to run a function object A thread pool has executors that send tasks to it. Its executor rule is: Run function objects in the pool and nowhere else. An executor is: May be long or short lived. Lightweight and copyable. May be customized on a fine-grained basis, such as exception behavior, and order Some references: https://think-async.com/Asio/ https://think-async.com/Asio/asio-1.18.1/doc/asio/std_executors.html https://github.com/chriskohlhoff/executors https://taskflow.github.io/taskflow/index.html Read the unit tests, such as asio/src/tests/unit/thread_pool.cpp Find ASIO 1 2 3 4 5 6 7 8 9 10 11 12 find_package ( Asio 1.21.0 QUIET ) if ( NOT Asio_FOUND ) FetchContent_Declare ( asio GIT_REPOSITORY https://github.com/chriskohlhoff/asio.git GIT_TAG asio-1-21-0 ) FetchContent_GetProperties ( asio ) if ( NOT asio_POPULATED ) FetchContent_Populate ( asio ) add_library ( asio INTERFACE ) target_include_directories ( asio INTERFACE ${ asio_SOURCE_DIR } /asio/include ) target_compile_definitions ( asio INTERFACE ASIO_STANDALONE ASIO_NO_DEPRECATED ) target_link_libraries ( asio INTERFACE Threads::Threads ) endif () endif () CMakeLists.txt 1 2 add_executable ( executors executors.cpp ) target_link_libraries ( executors asio ) Create a thread pool execution context 1 asio :: thread_pool pool ; Create an executor for the thread pool 1 auto ex = pool . executor (); Access executor context 1 std :: cout << ( & pool == & ex . context ()) << '\\n' ; Dispatch functions 1 2 3 4 5 6 7 8 9 10 11 12 13 // Executing directly in the thread pool // Execution behaviour according to eagerness: // - https://github.com/chriskohlhoff/executors // - Dispatch: Run the function object immediately if possible. // Most eager operation. // Might run before dispatch returns. // If inside pool, run immediately. // If outside pool, add to queue. asio :: dispatch ( ex , [ & ex ] { // This runs before finishing the function asio :: dispatch ( ex , [] { std :: cout << \"dispatch b\" << '\\n' ; }); std :: cout << \"dispatch a\" << '\\n' ; }); Post function 1 2 3 4 5 6 7 8 9 10 // - Post: Submit the function for later execution. // Never immediately in the same thread. // Always adds to pool queue. // Never blocking. asio :: post ( ex , [ & ex ] { // This will all run in parallel asio :: post ( ex , [] { std :: cout << \"post b\" << '\\n' ; }); asio :: post ( ex , [] { std :: cout << \"post c\" << '\\n' ; }); std :: cout << \"post a\" << '\\n' ; }); Defer function 1 2 3 4 5 6 7 8 9 10 11 12 13 // - Defer: Submit the function for later execution. // Least eager. // Implies relationship between calling thread and function. // Used when function is a continuation to the calling function. // The function is added to the queue after the current function // ends. If inside pool, adds to a thread local queue. If outside // pool, add to queue. Thread posting might immediately run it. // Potentially blocking. asio :: defer ( ex , [ & ex ] { // This will all run only when this function is over asio :: defer ( ex , [] { std :: cout << \"defer b\" << '\\n' ; }); std :: cout << \"defer a\" << '\\n' ; }); Returning value from task 1 2 std :: future < int > r1 = asio :: post ( ex , asio :: use_future ([]() { return 2 ; })); std :: cout << \"Result = \" << r1 . get () << '\\n' ; Waiting for task 1 2 3 4 std :: future < void > r2 = asio :: post ( ex , asio :: use_future ([]() { std :: cout << \"Print message\" ; })); r2 . get (); std :: cout << \" -> Message printed\" << '\\n' ; Create an strand executor 1 2 3 4 5 // A strand is an executor and an executor adapter. // Its rule is: Run function objects according to the underlying // executor\u2019s rules, but also run them in FIFO order and not // concurrently. asio :: strand < asio :: thread_pool :: executor_type > st ( ex ); Execute function in strand 1 st . execute ([] { std :: cout << \"FIFO-1a\" << '\\n' ; }); Post function to strand 1 asio :: post ( st , [] { std :: cout << \"FIFO-1b\" << '\\n' ; }); Wait for strand result 1 2 3 4 auto fifo_r = asio :: post ( st , asio :: use_future ([] { std :: cout << \"FIFO-1c\" << '\\n' ; })); fifo_r . wait (); std :: cout << \"FIFO tasks done\" << '\\n' ; Creating a promise 1 2 3 4 5 6 7 8 9 std :: promise < int > p ; std :: future < int > f = p . get_future (); auto fn = [ & p ]() { std :: cout << \"Task 2 executes asynchronously\" << '\\n' ; // \"return\" 2 by setting the promise value p . set_value ( 2 ); }; asio :: post ( fn ); std :: cout << \"f.get(): \" << f . get () << '\\n' ; Creating a promise 1 2 3 4 5 6 7 8 9 std :: promise < int > p ; std :: future < int > f = p . get_future (); auto fn = [ & p ]() { std :: cout << \"Task 2 executes asynchronously\" << '\\n' ; // \"return\" 2 by setting the promise value p . set_value ( 2 ); }; asio :: post ( fn ); std :: cout << \"f.get(): \" << f . get () << '\\n' ; Polling task continuations 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 auto task1 = asio :: post ( asio :: use_future ( [] { std :: cout << \"Task 1 executes asynchronously\" << '\\n' ; })); auto task2 = asio :: post ( asio :: use_future ([]() { std :: cout << \"Task 2 executes in parallel with task 1\" << '\\n' ; return 42 ; })); // something like task3 = task2.then([](int task2_output){...}); auto task3 = asio :: post ( asio :: use_future ([ & ]() { // poll task2 for its results int task2_output = task2 . get (); std :: cout << \"Task 3 executes after task 2, which returned \" << task2_output << '\\n' ; return task2_output * 3 ; })); Polling task conjunctions 1 2 3 4 5 6 // something like task4 = when_all(task1, task3); auto task4 = asio :: post ( asio :: use_future ([ & ]() { task1 . wait (); auto task3_output = task3 . get (); return task3_output ; })); Polling conjunction continuations 1 2 3 4 5 6 7 8 // something like task5 = task4.then([](std::tuple<void, int>)) auto task5 = asio :: post ( asio :: use_future ([ & ]() { auto task4_output = task4 . get (); std :: cout << \"Task 5 executes after tasks 1 and 3. Task 3 returned \" << task4_output << \".\" << '\\n' ; })); task5 . get (); std :: cout << \"Task 5 has completed\" << '\\n' ; Making threads sleep 1 2 3 4 5 6 7 for ( int i = 0 ; i < 20 ; ++ i ) { asio :: post ( ex , [ i ] { std :: cout << \"Thread \" << i << \" going to sleep\" << '\\n' ; std :: this_thread :: sleep_for ( std :: chrono :: seconds ( 1 )); std :: cout << \"Thread \" << i << \" awake\" << '\\n' ; }); } Parallel invoke functions 1 2 3 4 auto parallel_invoke = []( auto ex , auto fn1 , auto fn2 ) { asio :: post ( ex , fn1 ); asio :: post ( ex , fn2 ); }; Call parallel invoke functions 1 2 3 parallel_invoke ( ex , [] { std :: cout << \"parallel_invoke a\" << '\\n' ; }, [] { std :: cout << \"parallel_invoke b\" << '\\n' ; }); Parallel for with 1 task per element 1 2 3 4 5 6 auto parallel_for = []( auto ex , auto begin , auto end , auto fn ) { while ( begin != end ) { asio :: post ( ex , [ begin , & fn ] { fn ( * begin ); }); ++ begin ; } }; Call parallel for with 1 task per element 1 2 3 std :: vector < int > v = { 0 , 1 , 2 , 3 , 4 , 5 }; parallel_for ( ex , v . begin (), v . end (), []( int x ) { std :: cout << x ; }); std :: cout << '\\n' ; Function to make a ready future 1 2 3 4 5 6 template < class T > auto make_ready_future ( T && value ) { std :: promise < std :: decay_t < T >> result_promise ; std :: future < std :: decay_t < T >> result_future = result_promise . get_future (); result_promise . set_value ( value ); return result_future ; } Parallel reduce function 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 template < class FN , class Iterator > std :: future < typename Iterator :: value_type > parallel_reduce ( auto ex , Iterator begin , Iterator end , FN fn ) { auto second = std :: next ( begin ); const bool is_single_element = second == end ; const bool is_single_pair = ! is_single_element && ( std :: next ( second ) == end ); if ( is_single_element ) { return make_ready_future ( * begin ); } else if ( is_single_pair ) { return asio :: post ( ex , asio :: use_future ([ begin , second , & fn ] { return fn ( * begin , * second ); })); } else { // we would probably add a heuristic here for small ranges size_t n = std :: distance ( begin , end ); auto half = std :: next ( begin , n / 2 ); auto lhs = parallel_reduce ( ex , begin , half , fn ); auto rhs = parallel_reduce ( ex , half , end , fn ); return make_ready_future ( lhs . get () + rhs . get ()); } } Share Snippets","title":"Executors"},{"location":"programming-paradigms/parallelism/executors/#executors","text":"Executors A standard executor represents a policy as to how, when, and where a piece of code should be executed. The standard library does not include executors for parallel algorihms. Boost.Asio provides a complete implementation of the proposed standard executors. Creating an execution context, such as a thread pool Execution context: place where we can execute functions A thread pool is an execution context. An execution context is: Usually long lived. Non-copyable. May contain additional state, such as timers, and threads Creating an executor from an executor context: Executor: set of rules governing where, when and how to run a function object A thread pool has executors that send tasks to it. Its executor rule is: Run function objects in the pool and nowhere else. An executor is: May be long or short lived. Lightweight and copyable. May be customized on a fine-grained basis, such as exception behavior, and order Some references: https://think-async.com/Asio/ https://think-async.com/Asio/asio-1.18.1/doc/asio/std_executors.html https://github.com/chriskohlhoff/executors https://taskflow.github.io/taskflow/index.html Read the unit tests, such as asio/src/tests/unit/thread_pool.cpp Find ASIO 1 2 3 4 5 6 7 8 9 10 11 12 find_package ( Asio 1.21.0 QUIET ) if ( NOT Asio_FOUND ) FetchContent_Declare ( asio GIT_REPOSITORY https://github.com/chriskohlhoff/asio.git GIT_TAG asio-1-21-0 ) FetchContent_GetProperties ( asio ) if ( NOT asio_POPULATED ) FetchContent_Populate ( asio ) add_library ( asio INTERFACE ) target_include_directories ( asio INTERFACE ${ asio_SOURCE_DIR } /asio/include ) target_compile_definitions ( asio INTERFACE ASIO_STANDALONE ASIO_NO_DEPRECATED ) target_link_libraries ( asio INTERFACE Threads::Threads ) endif () endif () CMakeLists.txt 1 2 add_executable ( executors executors.cpp ) target_link_libraries ( executors asio ) Create a thread pool execution context 1 asio :: thread_pool pool ; Create an executor for the thread pool 1 auto ex = pool . executor (); Access executor context 1 std :: cout << ( & pool == & ex . context ()) << '\\n' ; Dispatch functions 1 2 3 4 5 6 7 8 9 10 11 12 13 // Executing directly in the thread pool // Execution behaviour according to eagerness: // - https://github.com/chriskohlhoff/executors // - Dispatch: Run the function object immediately if possible. // Most eager operation. // Might run before dispatch returns. // If inside pool, run immediately. // If outside pool, add to queue. asio :: dispatch ( ex , [ & ex ] { // This runs before finishing the function asio :: dispatch ( ex , [] { std :: cout << \"dispatch b\" << '\\n' ; }); std :: cout << \"dispatch a\" << '\\n' ; }); Post function 1 2 3 4 5 6 7 8 9 10 // - Post: Submit the function for later execution. // Never immediately in the same thread. // Always adds to pool queue. // Never blocking. asio :: post ( ex , [ & ex ] { // This will all run in parallel asio :: post ( ex , [] { std :: cout << \"post b\" << '\\n' ; }); asio :: post ( ex , [] { std :: cout << \"post c\" << '\\n' ; }); std :: cout << \"post a\" << '\\n' ; }); Defer function 1 2 3 4 5 6 7 8 9 10 11 12 13 // - Defer: Submit the function for later execution. // Least eager. // Implies relationship between calling thread and function. // Used when function is a continuation to the calling function. // The function is added to the queue after the current function // ends. If inside pool, adds to a thread local queue. If outside // pool, add to queue. Thread posting might immediately run it. // Potentially blocking. asio :: defer ( ex , [ & ex ] { // This will all run only when this function is over asio :: defer ( ex , [] { std :: cout << \"defer b\" << '\\n' ; }); std :: cout << \"defer a\" << '\\n' ; }); Returning value from task 1 2 std :: future < int > r1 = asio :: post ( ex , asio :: use_future ([]() { return 2 ; })); std :: cout << \"Result = \" << r1 . get () << '\\n' ; Waiting for task 1 2 3 4 std :: future < void > r2 = asio :: post ( ex , asio :: use_future ([]() { std :: cout << \"Print message\" ; })); r2 . get (); std :: cout << \" -> Message printed\" << '\\n' ; Create an strand executor 1 2 3 4 5 // A strand is an executor and an executor adapter. // Its rule is: Run function objects according to the underlying // executor\u2019s rules, but also run them in FIFO order and not // concurrently. asio :: strand < asio :: thread_pool :: executor_type > st ( ex ); Execute function in strand 1 st . execute ([] { std :: cout << \"FIFO-1a\" << '\\n' ; }); Post function to strand 1 asio :: post ( st , [] { std :: cout << \"FIFO-1b\" << '\\n' ; }); Wait for strand result 1 2 3 4 auto fifo_r = asio :: post ( st , asio :: use_future ([] { std :: cout << \"FIFO-1c\" << '\\n' ; })); fifo_r . wait (); std :: cout << \"FIFO tasks done\" << '\\n' ; Creating a promise 1 2 3 4 5 6 7 8 9 std :: promise < int > p ; std :: future < int > f = p . get_future (); auto fn = [ & p ]() { std :: cout << \"Task 2 executes asynchronously\" << '\\n' ; // \"return\" 2 by setting the promise value p . set_value ( 2 ); }; asio :: post ( fn ); std :: cout << \"f.get(): \" << f . get () << '\\n' ; Creating a promise 1 2 3 4 5 6 7 8 9 std :: promise < int > p ; std :: future < int > f = p . get_future (); auto fn = [ & p ]() { std :: cout << \"Task 2 executes asynchronously\" << '\\n' ; // \"return\" 2 by setting the promise value p . set_value ( 2 ); }; asio :: post ( fn ); std :: cout << \"f.get(): \" << f . get () << '\\n' ; Polling task continuations 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 auto task1 = asio :: post ( asio :: use_future ( [] { std :: cout << \"Task 1 executes asynchronously\" << '\\n' ; })); auto task2 = asio :: post ( asio :: use_future ([]() { std :: cout << \"Task 2 executes in parallel with task 1\" << '\\n' ; return 42 ; })); // something like task3 = task2.then([](int task2_output){...}); auto task3 = asio :: post ( asio :: use_future ([ & ]() { // poll task2 for its results int task2_output = task2 . get (); std :: cout << \"Task 3 executes after task 2, which returned \" << task2_output << '\\n' ; return task2_output * 3 ; })); Polling task conjunctions 1 2 3 4 5 6 // something like task4 = when_all(task1, task3); auto task4 = asio :: post ( asio :: use_future ([ & ]() { task1 . wait (); auto task3_output = task3 . get (); return task3_output ; })); Polling conjunction continuations 1 2 3 4 5 6 7 8 // something like task5 = task4.then([](std::tuple<void, int>)) auto task5 = asio :: post ( asio :: use_future ([ & ]() { auto task4_output = task4 . get (); std :: cout << \"Task 5 executes after tasks 1 and 3. Task 3 returned \" << task4_output << \".\" << '\\n' ; })); task5 . get (); std :: cout << \"Task 5 has completed\" << '\\n' ; Making threads sleep 1 2 3 4 5 6 7 for ( int i = 0 ; i < 20 ; ++ i ) { asio :: post ( ex , [ i ] { std :: cout << \"Thread \" << i << \" going to sleep\" << '\\n' ; std :: this_thread :: sleep_for ( std :: chrono :: seconds ( 1 )); std :: cout << \"Thread \" << i << \" awake\" << '\\n' ; }); } Parallel invoke functions 1 2 3 4 auto parallel_invoke = []( auto ex , auto fn1 , auto fn2 ) { asio :: post ( ex , fn1 ); asio :: post ( ex , fn2 ); }; Call parallel invoke functions 1 2 3 parallel_invoke ( ex , [] { std :: cout << \"parallel_invoke a\" << '\\n' ; }, [] { std :: cout << \"parallel_invoke b\" << '\\n' ; }); Parallel for with 1 task per element 1 2 3 4 5 6 auto parallel_for = []( auto ex , auto begin , auto end , auto fn ) { while ( begin != end ) { asio :: post ( ex , [ begin , & fn ] { fn ( * begin ); }); ++ begin ; } }; Call parallel for with 1 task per element 1 2 3 std :: vector < int > v = { 0 , 1 , 2 , 3 , 4 , 5 }; parallel_for ( ex , v . begin (), v . end (), []( int x ) { std :: cout << x ; }); std :: cout << '\\n' ; Function to make a ready future 1 2 3 4 5 6 template < class T > auto make_ready_future ( T && value ) { std :: promise < std :: decay_t < T >> result_promise ; std :: future < std :: decay_t < T >> result_future = result_promise . get_future (); result_promise . set_value ( value ); return result_future ; } Parallel reduce function 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 template < class FN , class Iterator > std :: future < typename Iterator :: value_type > parallel_reduce ( auto ex , Iterator begin , Iterator end , FN fn ) { auto second = std :: next ( begin ); const bool is_single_element = second == end ; const bool is_single_pair = ! is_single_element && ( std :: next ( second ) == end ); if ( is_single_element ) { return make_ready_future ( * begin ); } else if ( is_single_pair ) { return asio :: post ( ex , asio :: use_future ([ begin , second , & fn ] { return fn ( * begin , * second ); })); } else { // we would probably add a heuristic here for small ranges size_t n = std :: distance ( begin , end ); auto half = std :: next ( begin , n / 2 ); auto lhs = parallel_reduce ( ex , begin , half , fn ); auto rhs = parallel_reduce ( ex , half , end , fn ); return make_ready_future ( lhs . get () + rhs . get ()); } } Share Snippets","title":"Executors"},{"location":"programming-paradigms/parallelism/signals/","text":"Signals Signals Signals might be important to properly stop asynchronous operations, such as servers. Boost.Asio supports signal handling using a class called signal_set . Programs may add one or more signals to the set, and then perform an async_wait() operation. The specified handler will be called when one of the signals occurs. The same signal number may be registered with multiple signal_set objects, however the signal number must be used only with Boost.Asio . Find ASIO 1 2 3 4 5 6 7 8 9 10 11 12 find_package ( Asio 1.21.0 QUIET ) if ( NOT Asio_FOUND ) FetchContent_Declare ( asio GIT_REPOSITORY https://github.com/chriskohlhoff/asio.git GIT_TAG asio-1-21-0 ) FetchContent_GetProperties ( asio ) if ( NOT asio_POPULATED ) FetchContent_Populate ( asio ) add_library ( asio INTERFACE ) target_include_directories ( asio INTERFACE ${ asio_SOURCE_DIR } /asio/include ) target_compile_definitions ( asio INTERFACE ASIO_STANDALONE ASIO_NO_DEPRECATED ) target_link_libraries ( asio INTERFACE Threads::Threads ) endif () endif () CMakeLists.txt 1 2 add_executable ( signals signals.cpp ) target_link_libraries ( signals asio ) Create io_context executor 1 asio :: io_context io_context ; Create signal_set responding to SIGINT and SIGTERM 1 asio :: signal_set signals ( io_context , SIGINT , SIGTERM ); Set the signal set callback 1 2 3 4 5 6 7 8 9 10 11 12 13 // The signals will set stop_timer to true std :: atomic < bool > request_stop_timer = false ; signals . async_wait ([ & ]( const asio :: error_code & ec , int signal_number ) { if ( ! ec ) { std :: cout << \"Signal number \" << signal_number << std :: endl ; std :: cout << \"Gracefully stopping the timer and exiting\" << std :: endl ; request_stop_timer . store ( true ); } else { std :: cout << \"Error \" << ec . value () << \" - \" << ec . message () << \" - Signal number - \" << signal_number << std :: endl ; } }); Create a timer that keeps counting until we have a signal 1 asio :: steady_timer t ( io_context , asio :: chrono :: seconds ( 1 )); Set timer callback 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int count = 0 ; std :: function < void ( asio :: error_code ) > timer_callback ; timer_callback = [ & ]( asio :: error_code ec ) { if ( ! ec ) { if ( count < 30 && ! request_stop_timer . load ()) { // Increase counter std :: cout << count << std :: endl ; ++ count ; // Set the timer again t . expires_at ( t . expiry () + std :: chrono :: seconds ( 1 )); t . async_wait ( timer_callback ); } else { std :: cout << \"Reached \" << count << std :: endl ; } } else { std :: cout << \"Timer Error\" << std :: endl ; } }; Push timer waiting task to io_context 1 t . async_wait ( timer_callback ); Execute tasks from io_context 1 2 3 4 asio :: thread_pool pool ; for ( size_t i = 0 ; i < std :: thread :: hardware_concurrency (); ++ i ) { asio :: post ( pool , [ & io_context ] { io_context . run (); }); } Share Snippets","title":"Signals"},{"location":"programming-paradigms/parallelism/signals/#signals","text":"Signals Signals might be important to properly stop asynchronous operations, such as servers. Boost.Asio supports signal handling using a class called signal_set . Programs may add one or more signals to the set, and then perform an async_wait() operation. The specified handler will be called when one of the signals occurs. The same signal number may be registered with multiple signal_set objects, however the signal number must be used only with Boost.Asio . Find ASIO 1 2 3 4 5 6 7 8 9 10 11 12 find_package ( Asio 1.21.0 QUIET ) if ( NOT Asio_FOUND ) FetchContent_Declare ( asio GIT_REPOSITORY https://github.com/chriskohlhoff/asio.git GIT_TAG asio-1-21-0 ) FetchContent_GetProperties ( asio ) if ( NOT asio_POPULATED ) FetchContent_Populate ( asio ) add_library ( asio INTERFACE ) target_include_directories ( asio INTERFACE ${ asio_SOURCE_DIR } /asio/include ) target_compile_definitions ( asio INTERFACE ASIO_STANDALONE ASIO_NO_DEPRECATED ) target_link_libraries ( asio INTERFACE Threads::Threads ) endif () endif () CMakeLists.txt 1 2 add_executable ( signals signals.cpp ) target_link_libraries ( signals asio ) Create io_context executor 1 asio :: io_context io_context ; Create signal_set responding to SIGINT and SIGTERM 1 asio :: signal_set signals ( io_context , SIGINT , SIGTERM ); Set the signal set callback 1 2 3 4 5 6 7 8 9 10 11 12 13 // The signals will set stop_timer to true std :: atomic < bool > request_stop_timer = false ; signals . async_wait ([ & ]( const asio :: error_code & ec , int signal_number ) { if ( ! ec ) { std :: cout << \"Signal number \" << signal_number << std :: endl ; std :: cout << \"Gracefully stopping the timer and exiting\" << std :: endl ; request_stop_timer . store ( true ); } else { std :: cout << \"Error \" << ec . value () << \" - \" << ec . message () << \" - Signal number - \" << signal_number << std :: endl ; } }); Create a timer that keeps counting until we have a signal 1 asio :: steady_timer t ( io_context , asio :: chrono :: seconds ( 1 )); Set timer callback 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int count = 0 ; std :: function < void ( asio :: error_code ) > timer_callback ; timer_callback = [ & ]( asio :: error_code ec ) { if ( ! ec ) { if ( count < 30 && ! request_stop_timer . load ()) { // Increase counter std :: cout << count << std :: endl ; ++ count ; // Set the timer again t . expires_at ( t . expiry () + std :: chrono :: seconds ( 1 )); t . async_wait ( timer_callback ); } else { std :: cout << \"Reached \" << count << std :: endl ; } } else { std :: cout << \"Timer Error\" << std :: endl ; } }; Push timer waiting task to io_context 1 t . async_wait ( timer_callback ); Execute tasks from io_context 1 2 3 4 asio :: thread_pool pool ; for ( size_t i = 0 ; i < std :: thread :: hardware_concurrency (); ++ i ) { asio :: post ( pool , [ & io_context ] { io_context . run (); }); } Share Snippets","title":"Signals"},{"location":"programming-paradigms/parallelism/threads/","text":"Threads Threads The C++ thread support library includes built-in support for threads, mutual exclusion, condition variables, and futures. CMakeLists.txt 1 2 3 find_package ( Threads ) add_executable ( multithreading multithreading.cpp ) target_link_libraries ( multithreading PUBLIC Threads::Threads ) Launch thread 1 std :: thread t1 ([]() { std :: cout << \"function 1 \\n \" ; }); Launch thread with function parameter 1 2 std :: thread t2 ( []( int x ) { std :: cout << \"function 2: number \" << x << '\\n' ; }, 10 ); Launch lambda function 1 2 auto fn = []( int x ) { std :: cout << \"function 3: number \" << x << '\\n' ; }; std :: thread t3 ( fn , 2 ); Wait for threads 1 2 3 t1 . join (); t2 . join (); t3 . join (); Thread vector 1 2 3 4 5 6 // - A vector can store reusable threads // - The cost of creating threads might be higher than their work std :: vector < std :: thread > workers ; for ( int i = 0 ; i < 5 ; i ++ ) { workers . emplace_back ([ i ]() { std :: cout << \"Thread function \" << i ; }); } Wait for thread vector 1 2 std :: for_each ( workers . begin (), workers . end (), []( std :: thread & t ) { t . join (); }); Future value 1 2 3 4 5 6 7 8 // - Unfortunately, async does not necessarily go to a thread pool // - It's best to use a library if you need async(...) a lot std :: future < int > f2 = async ( std :: launch :: async , [] { return 8 ; }); while ( f2 . wait_for ( std :: chrono :: milliseconds ( 100 )) != std :: future_status :: ready ) { // do some other work std :: this_thread :: sleep_for ( std :: chrono :: milliseconds ( 1 )); } Wait until future is ready 1 f2 . wait (); Wait and get value from the future 1 std :: cout << f2 . get () << '\\n' ; Call parallel algorithm 1 2 3 // - Same overhead applies here std :: vector < int > v ( 10000 , 1 ); std :: cout << \"The sum is \" << parallel_sum ( v . begin (), v . end ()) << '\\n' ; Parallel algorithm with one thread per subproblem 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template < typename Iter > int parallel_sum ( Iter beg , Iter end ) { typename Iter :: difference_type len = end - beg ; // Solve small problems in one thread if ( len < 1000 ) { return std :: accumulate ( beg , end , 0 ); } // Split large problems into two threads Iter mid = beg + len / 2 ; std :: future < int > handle = std :: async ( std :: launch :: async , parallel_sum < Iter > , mid , end ); int sum = parallel_sum ( beg , mid ); return sum + handle . get (); } Share Snippets","title":"Threads"},{"location":"programming-paradigms/parallelism/threads/#threads","text":"Threads The C++ thread support library includes built-in support for threads, mutual exclusion, condition variables, and futures. CMakeLists.txt 1 2 3 find_package ( Threads ) add_executable ( multithreading multithreading.cpp ) target_link_libraries ( multithreading PUBLIC Threads::Threads ) Launch thread 1 std :: thread t1 ([]() { std :: cout << \"function 1 \\n \" ; }); Launch thread with function parameter 1 2 std :: thread t2 ( []( int x ) { std :: cout << \"function 2: number \" << x << '\\n' ; }, 10 ); Launch lambda function 1 2 auto fn = []( int x ) { std :: cout << \"function 3: number \" << x << '\\n' ; }; std :: thread t3 ( fn , 2 ); Wait for threads 1 2 3 t1 . join (); t2 . join (); t3 . join (); Thread vector 1 2 3 4 5 6 // - A vector can store reusable threads // - The cost of creating threads might be higher than their work std :: vector < std :: thread > workers ; for ( int i = 0 ; i < 5 ; i ++ ) { workers . emplace_back ([ i ]() { std :: cout << \"Thread function \" << i ; }); } Wait for thread vector 1 2 std :: for_each ( workers . begin (), workers . end (), []( std :: thread & t ) { t . join (); }); Future value 1 2 3 4 5 6 7 8 // - Unfortunately, async does not necessarily go to a thread pool // - It's best to use a library if you need async(...) a lot std :: future < int > f2 = async ( std :: launch :: async , [] { return 8 ; }); while ( f2 . wait_for ( std :: chrono :: milliseconds ( 100 )) != std :: future_status :: ready ) { // do some other work std :: this_thread :: sleep_for ( std :: chrono :: milliseconds ( 1 )); } Wait until future is ready 1 f2 . wait (); Wait and get value from the future 1 std :: cout << f2 . get () << '\\n' ; Call parallel algorithm 1 2 3 // - Same overhead applies here std :: vector < int > v ( 10000 , 1 ); std :: cout << \"The sum is \" << parallel_sum ( v . begin (), v . end ()) << '\\n' ; Parallel algorithm with one thread per subproblem 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template < typename Iter > int parallel_sum ( Iter beg , Iter end ) { typename Iter :: difference_type len = end - beg ; // Solve small problems in one thread if ( len < 1000 ) { return std :: accumulate ( beg , end , 0 ); } // Split large problems into two threads Iter mid = beg + len / 2 ; std :: future < int > handle = std :: async ( std :: launch :: async , parallel_sum < Iter > , mid , end ); int sum = parallel_sum ( beg , mid ); return sum + handle . get (); } Share Snippets","title":"Threads"},{"location":"programming-paradigms/parallelism/timers/","text":"Timers Timers Timers are useful to applications that need to perform some operations once every x time units, including timeouts for servers Find ASIO 1 2 3 4 5 6 7 8 9 10 11 12 find_package ( Asio 1.21.0 QUIET ) if ( NOT Asio_FOUND ) FetchContent_Declare ( asio GIT_REPOSITORY https://github.com/chriskohlhoff/asio.git GIT_TAG asio-1-21-0 ) FetchContent_GetProperties ( asio ) if ( NOT asio_POPULATED ) FetchContent_Populate ( asio ) add_library ( asio INTERFACE ) target_include_directories ( asio INTERFACE ${ asio_SOURCE_DIR } /asio/include ) target_compile_definitions ( asio INTERFACE ASIO_STANDALONE ASIO_NO_DEPRECATED ) target_link_libraries ( asio INTERFACE Threads::Threads ) endif () endif () CMakeLists.txt 1 2 add_executable ( timers timers.cpp ) target_link_libraries ( timers asio ) Create io_context executor 1 asio :: io_context io_context ; Setting a synchronous timer 1 2 3 asio :: steady_timer t ( io_context , std :: chrono :: seconds ( 3 )); t . wait (); std :: cout << \"Sync Timer expired\" << '\\n' ; Create a steady timer 1 asio :: steady_timer t1 ( io_context , std :: chrono :: seconds ( 3 )); Setting steady timer asynchronous callback 1 2 3 4 5 6 7 t1 . async_wait ([]( std :: error_code ec ) { if ( ! ec ) { std :: cout << \"Timer 1 expired\" << '\\n' ; } else { std :: cout << \"Timer 1 error\" << '\\n' ; } }); Creating a system timer 1 asio :: system_timer t2 ( io_context , std :: chrono :: seconds ( 3 )); Setting asynchronous steady timer callback 1 2 3 4 5 6 7 t2 . async_wait ([]( std :: error_code ec ) { if ( ! ec ) { std :: cout << \"Timer 2 expired\" << '\\n' ; } else { std :: cout << \"Timer 2 error\" << '\\n' ; } }); Creating a high-resolution timer 1 asio :: high_resolution_timer t3 ( io_context , std :: chrono :: seconds ( 3 )); Setting asynchronous high-resolution timer callback 1 2 3 4 5 6 7 t3 . async_wait ([]( std :: error_code ec ) { if ( ! ec ) { std :: cout << \"Timer 3 expired\" << '\\n' ; } else { std :: cout << \"Timer 3 error\" << '\\n' ; } }); Dequeue tasks from io_context executor 1 2 3 4 asio :: thread_pool pool ; for ( size_t i = 0 ; i < std :: thread :: hardware_concurrency (); ++ i ) { asio :: post ( pool , [ & io_context ] { io_context . run (); }); } Share Snippets","title":"Timers"},{"location":"programming-paradigms/parallelism/timers/#timers","text":"Timers Timers are useful to applications that need to perform some operations once every x time units, including timeouts for servers Find ASIO 1 2 3 4 5 6 7 8 9 10 11 12 find_package ( Asio 1.21.0 QUIET ) if ( NOT Asio_FOUND ) FetchContent_Declare ( asio GIT_REPOSITORY https://github.com/chriskohlhoff/asio.git GIT_TAG asio-1-21-0 ) FetchContent_GetProperties ( asio ) if ( NOT asio_POPULATED ) FetchContent_Populate ( asio ) add_library ( asio INTERFACE ) target_include_directories ( asio INTERFACE ${ asio_SOURCE_DIR } /asio/include ) target_compile_definitions ( asio INTERFACE ASIO_STANDALONE ASIO_NO_DEPRECATED ) target_link_libraries ( asio INTERFACE Threads::Threads ) endif () endif () CMakeLists.txt 1 2 add_executable ( timers timers.cpp ) target_link_libraries ( timers asio ) Create io_context executor 1 asio :: io_context io_context ; Setting a synchronous timer 1 2 3 asio :: steady_timer t ( io_context , std :: chrono :: seconds ( 3 )); t . wait (); std :: cout << \"Sync Timer expired\" << '\\n' ; Create a steady timer 1 asio :: steady_timer t1 ( io_context , std :: chrono :: seconds ( 3 )); Setting steady timer asynchronous callback 1 2 3 4 5 6 7 t1 . async_wait ([]( std :: error_code ec ) { if ( ! ec ) { std :: cout << \"Timer 1 expired\" << '\\n' ; } else { std :: cout << \"Timer 1 error\" << '\\n' ; } }); Creating a system timer 1 asio :: system_timer t2 ( io_context , std :: chrono :: seconds ( 3 )); Setting asynchronous steady timer callback 1 2 3 4 5 6 7 t2 . async_wait ([]( std :: error_code ec ) { if ( ! ec ) { std :: cout << \"Timer 2 expired\" << '\\n' ; } else { std :: cout << \"Timer 2 error\" << '\\n' ; } }); Creating a high-resolution timer 1 asio :: high_resolution_timer t3 ( io_context , std :: chrono :: seconds ( 3 )); Setting asynchronous high-resolution timer callback 1 2 3 4 5 6 7 t3 . async_wait ([]( std :: error_code ec ) { if ( ! ec ) { std :: cout << \"Timer 3 expired\" << '\\n' ; } else { std :: cout << \"Timer 3 error\" << '\\n' ; } }); Dequeue tasks from io_context executor 1 2 3 4 asio :: thread_pool pool ; for ( size_t i = 0 ; i < std :: thread :: hardware_concurrency (); ++ i ) { asio :: post ( pool , [ & io_context ] { io_context . run (); }); } Share Snippets","title":"Timers"},{"location":"testing/boostut/","text":"boost.ut Fetch boost.ut 1 2 FetchContent_Declare ( boost.ut GIT_REPOSITORY https://github.com/boost-ext/ut GIT_TAG v1.1.8 ) FetchContent_MakeAvailable ( boost.ut ) Link boost.ut 1 2 add_executable ( unit_tests unit_tests_ut.cpp ) target_link_libraries ( unit_tests PRIVATE boost.ut ) Headers 1 #include <boost/ut.hpp> Requirements 1 2 3 4 5 6 7 8 9 expect ( true ); expect ( 1 == 2 ); expect ( 1 _i == 2 ); // UDL syntax expect ( 1 == 2 _i ); // UDL syntax expect ( that % 1 == 2 ); // Matcher syntax expect ( eq ( 1 , 2 )); // eq/neq/gt/ge/lt/le expect (( 1 == 1 _i ) >> fatal ); // fatal assertion expect ( 1 _i == 2 ); // not executed expect ( 42l == 42 _l and 1 == 2 _i ) << \"additional info \\n \" ; Test groups 1 2 3 4 \"hello world\" _test = [] { int i = 42 ; expect ( 42 _i == i ); }; Test groups 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \"[vector]\" _test = [] { std :: vector < int > v ( 5 ); expect (( 5 _ul == std :: size ( v )) >> fatal ); should ( \"resize bigger\" ) = [ v ] { // or \"resize bigger\"_test mut ( v ). resize ( 10 ); expect ( 10 _ul == std :: size ( v )); }; expect (( 5 _ul == std :: size ( v )) >> fatal ); should ( \"resize smaller\" ) = [ = ]() mutable { // or \"resize smaller\"_test v . resize ( 0 ); expect ( 0 _ul == std :: size ( v )); }; }; Behaviour Driven development 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 using namespace boost :: ut :: bdd ; \"vector\" _test = [] { given ( \"I have a vector\" ) = [] { std :: vector < int > v ( 5 ); expect (( 5 _ul == std :: size ( v )) >> fatal ); when ( \"I resize bigger\" ) = [ = ] { mut ( v ). resize ( 10 ); then ( \"The size should increase\" ) = [ = ] { expect ( 10 _ul == std :: size ( v )); }; }; }; }; BBD: feature / scenario 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 feature ( \"vector\" ) = [] { scenario ( \"size\" ) = [] { given ( \"I have a vector\" ) = [] { std :: vector < int > v ( 5 ); expect (( 5 _ul == std :: size ( v )) >> fatal ); when ( \"I resize bigger\" ) = [ = ] { mut ( v ). resize ( 10 ); then ( \"The size should increase\" ) = [ = ] { expect ( 10 _ul == std :: size ( v )); }; }; }; }; }; Test parameters 1 2 3 4 5 for ( auto i : std :: vector { 1 , 2 , 3 }) { test ( \"parameterized \" + std :: to_string ( i )) = [ i ] { // 3 tests expect ( that % i > 0 ); // 3 asserts }; } Test parameters 1 2 3 \"args\" _test = []( const auto & arg ) { expect ( arg > 0 _i ) << \"all values greater than 0\" ; } | std :: vector { 1 , 2 , 3 }; Nested tests 1 2 3 4 5 6 7 8 \"vector\" _test = [] { std :: vector < int > v ( 5 ); expect (( 5 _ul == std :: size ( v )) >> fatal ); \"samesize\" _test = [ & ] { std :: vector < int > v2 ( 5 ); expect ( eq ( v . size (), v2 . size ())); }; }; Logging 1 2 3 4 5 \"logging\" _test = [] { log << \"pre\" ; expect ( 42 _i == 43 ) << \"message on failure\" ; log << \"post\" ; }; Share Snippets","title":"boost.ut"},{"location":"testing/boostut/#boostut","text":"Fetch boost.ut 1 2 FetchContent_Declare ( boost.ut GIT_REPOSITORY https://github.com/boost-ext/ut GIT_TAG v1.1.8 ) FetchContent_MakeAvailable ( boost.ut ) Link boost.ut 1 2 add_executable ( unit_tests unit_tests_ut.cpp ) target_link_libraries ( unit_tests PRIVATE boost.ut ) Headers 1 #include <boost/ut.hpp> Requirements 1 2 3 4 5 6 7 8 9 expect ( true ); expect ( 1 == 2 ); expect ( 1 _i == 2 ); // UDL syntax expect ( 1 == 2 _i ); // UDL syntax expect ( that % 1 == 2 ); // Matcher syntax expect ( eq ( 1 , 2 )); // eq/neq/gt/ge/lt/le expect (( 1 == 1 _i ) >> fatal ); // fatal assertion expect ( 1 _i == 2 ); // not executed expect ( 42l == 42 _l and 1 == 2 _i ) << \"additional info \\n \" ; Test groups 1 2 3 4 \"hello world\" _test = [] { int i = 42 ; expect ( 42 _i == i ); }; Test groups 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \"[vector]\" _test = [] { std :: vector < int > v ( 5 ); expect (( 5 _ul == std :: size ( v )) >> fatal ); should ( \"resize bigger\" ) = [ v ] { // or \"resize bigger\"_test mut ( v ). resize ( 10 ); expect ( 10 _ul == std :: size ( v )); }; expect (( 5 _ul == std :: size ( v )) >> fatal ); should ( \"resize smaller\" ) = [ = ]() mutable { // or \"resize smaller\"_test v . resize ( 0 ); expect ( 0 _ul == std :: size ( v )); }; }; Behaviour Driven development 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 using namespace boost :: ut :: bdd ; \"vector\" _test = [] { given ( \"I have a vector\" ) = [] { std :: vector < int > v ( 5 ); expect (( 5 _ul == std :: size ( v )) >> fatal ); when ( \"I resize bigger\" ) = [ = ] { mut ( v ). resize ( 10 ); then ( \"The size should increase\" ) = [ = ] { expect ( 10 _ul == std :: size ( v )); }; }; }; }; BBD: feature / scenario 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 feature ( \"vector\" ) = [] { scenario ( \"size\" ) = [] { given ( \"I have a vector\" ) = [] { std :: vector < int > v ( 5 ); expect (( 5 _ul == std :: size ( v )) >> fatal ); when ( \"I resize bigger\" ) = [ = ] { mut ( v ). resize ( 10 ); then ( \"The size should increase\" ) = [ = ] { expect ( 10 _ul == std :: size ( v )); }; }; }; }; }; Test parameters 1 2 3 4 5 for ( auto i : std :: vector { 1 , 2 , 3 }) { test ( \"parameterized \" + std :: to_string ( i )) = [ i ] { // 3 tests expect ( that % i > 0 ); // 3 asserts }; } Test parameters 1 2 3 \"args\" _test = []( const auto & arg ) { expect ( arg > 0 _i ) << \"all values greater than 0\" ; } | std :: vector { 1 , 2 , 3 }; Nested tests 1 2 3 4 5 6 7 8 \"vector\" _test = [] { std :: vector < int > v ( 5 ); expect (( 5 _ul == std :: size ( v )) >> fatal ); \"samesize\" _test = [ & ] { std :: vector < int > v2 ( 5 ); expect ( eq ( v . size (), v2 . size ())); }; }; Logging 1 2 3 4 5 \"logging\" _test = [] { log << \"pre\" ; expect ( 42 _i == 43 ) << \"message on failure\" ; log << \"post\" ; }; Share Snippets","title":"boost.ut"},{"location":"testing/catch2/","text":"Catch2 Snippet fetch_catch2 not found in snippets/tests/CMakeLists.txt Link Catch2 1 2 add_executable ( unit_tests_catch unit_tests_catch.cpp ) target_link_libraries ( unit_tests_catch PRIVATE Catch2::Catch2 ) Headers 1 2 #define CATCH_CONFIG_MAIN #include <catch2/catch.hpp> Create test case 1 2 3 TEST_CASE ( \"Factorial of 0 is 1 (fail)\" , \"[single-file]\" ) { REQUIRE ( Factorial ( 0 ) == 1 ); } Create test case 1 2 3 4 5 6 TEST_CASE ( \"Factorials of 1 and higher are computed (pass)\" , \"[single-file]\" ) { REQUIRE ( Factorial ( 1 ) == 1 ); REQUIRE ( Factorial ( 2 ) == 2 ); REQUIRE ( Factorial ( 3 ) == 6 ); REQUIRE ( Factorial ( 10 ) == 3628800 ); } Share Snippets","title":"Catch2"},{"location":"testing/catch2/#catch2","text":"Snippet fetch_catch2 not found in snippets/tests/CMakeLists.txt Link Catch2 1 2 add_executable ( unit_tests_catch unit_tests_catch.cpp ) target_link_libraries ( unit_tests_catch PRIVATE Catch2::Catch2 ) Headers 1 2 #define CATCH_CONFIG_MAIN #include <catch2/catch.hpp> Create test case 1 2 3 TEST_CASE ( \"Factorial of 0 is 1 (fail)\" , \"[single-file]\" ) { REQUIRE ( Factorial ( 0 ) == 1 ); } Create test case 1 2 3 4 5 6 TEST_CASE ( \"Factorials of 1 and higher are computed (pass)\" , \"[single-file]\" ) { REQUIRE ( Factorial ( 1 ) == 1 ); REQUIRE ( Factorial ( 2 ) == 2 ); REQUIRE ( Factorial ( 3 ) == 6 ); REQUIRE ( Factorial ( 10 ) == 3628800 ); } Share Snippets","title":"Catch2"},{"location":"testing/plots/","text":"Plots Find Matplot++ 1 find_package ( Matplot++ QUIET ) Link Matplot++ 1 2 3 4 if ( Matplot++_FOUND ) add_executable ( plots plots.cpp ) target_link_libraries ( plots PRIVATE Matplot++::matplot ) endif () Headers 1 #include <matplot/matplot.h> Line plot 1 2 matplot :: plot ( std :: vector { 1 , 2 , 3 , 4 , 5 , 6 }); matplot :: show (); Share Snippets","title":"Plots"},{"location":"testing/plots/#plots","text":"Find Matplot++ 1 find_package ( Matplot++ QUIET ) Link Matplot++ 1 2 3 4 if ( Matplot++_FOUND ) add_executable ( plots plots.cpp ) target_link_libraries ( plots PRIVATE Matplot++::matplot ) endif () Headers 1 #include <matplot/matplot.h> Line plot 1 2 matplot :: plot ( std :: vector { 1 , 2 , 3 , 4 , 5 , 6 }); matplot :: show (); Share Snippets","title":"Plots"},{"location":"testing/source-location/","text":"Source Location Headers 1 #include <source_location> Function that requires source location 1 2 3 4 5 6 void print_msg_with_line ( std :: string_view message , const std :: source_location & location = std :: source_location :: current ()) { std :: cout << \"info: \" << location . file_name () << ':' << location . line () << ' ' << message << '\\n' ; } Call function with source location 1 print_msg_with_line ( \"Hello world!\" ); Share Snippets","title":"Source Location"},{"location":"testing/source-location/#source-location","text":"Headers 1 #include <source_location> Function that requires source location 1 2 3 4 5 6 void print_msg_with_line ( std :: string_view message , const std :: source_location & location = std :: source_location :: current ()) { std :: cout << \"info: \" << location . file_name () << ':' << location . line () << ' ' << message << '\\n' ; } Call function with source location 1 print_msg_with_line ( \"Hello world!\" ); Share Snippets","title":"Source Location"},{"location":"utilities/networking/async-network/","text":"Async Network Find ASIO 1 2 3 4 5 6 7 8 9 10 11 12 find_package ( Asio 1.21.0 QUIET ) if ( NOT Asio_FOUND ) FetchContent_Declare ( asio GIT_REPOSITORY https://github.com/chriskohlhoff/asio.git GIT_TAG asio-1-21-0 ) FetchContent_GetProperties ( asio ) if ( NOT asio_POPULATED ) FetchContent_Populate ( asio ) add_library ( asio INTERFACE ) target_include_directories ( asio INTERFACE ${ asio_SOURCE_DIR } /asio/include ) target_compile_definitions ( asio INTERFACE ASIO_STANDALONE ASIO_NO_DEPRECATED ) target_link_libraries ( asio INTERFACE Threads::Threads ) endif () endif () CMakeLists.txt 1 2 add_executable ( network network.cpp ) target_link_libraries ( network asio ) Declare class to represent client session 1 2 3 4 5 6 7 8 9 10 11 12 class session : public std :: enable_shared_from_this < session > { public : explicit session ( asio :: ip :: tcp :: socket socket ) : socket_ ( std :: move ( socket )) { // Create a session to a client // The session just wraps a socket to communicate with the client } void start () { // Start the session by reading from the client schedule_read (); } Read whatever the client sent us 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 private : void schedule_read () { // Create another pointer to this session // - These pointers are useful to make sure there is always // some shared pointer pointing to this session object auto self ( shared_from_this ()); // Read some data from the client // - We read little by little to make sure everything is OK // - This is better than reading all at once // - We read max_length bytes at a time socket_ . async_read_some ( asio :: buffer ( data_ , max_length ), [ this , self ]( std :: error_code ec , std :: size_t length ) { // If there was no error reading the message, // write a response to the client if ( ! ec ) { std :: cout << \"Client sent: \" << std :: endl ; std :: cout << data_ << std :: endl << std :: endl ; schedule_write ( length ); } }); } Write a response to the client 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void schedule_write ( std :: size_t length ) { // Create another shared pointer to this to make sure it does die auto self ( shared_from_this ()); // Write a response asynchronously // - In this example, we write the same data back to the client asio :: async_write ( socket_ , asio :: buffer ( data_ , length ), [ this , self ]( std :: error_code ec , std :: size_t /*length*/ ) { // If there is no error if ( ! ec ) { std :: cout << \"Server replied with: \" << std :: endl ; std :: cout << data_ << std :: endl << std :: endl ; // Starting reading from the client again schedule_read (); } }); } Session data 1 2 3 4 5 6 7 8 9 // Socket representing connection to client asio :: ip :: tcp :: socket socket_ ; // Max length of the messages static constexpr size_t max_length = 1024 ; // Array to keep messages char data_ [ max_length ]{}; }; Define class to manage the acceptor and the clients 1 2 3 4 5 6 7 8 9 10 class server { public : // Construct server on a port // - The server just wraps the acceptor and starts a session whenever // the client connects server ( asio :: io_context & io_context , short port ) : acceptor_ ( io_context , asio :: ip :: tcp :: endpoint ( asio :: ip :: tcp :: v4 (), port )) { schedule_accept (); } Listen for connection 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 private : void schedule_accept () { std :: cout << \"Listening on http://localhost:\" << acceptor_ . local_endpoint (). port () << std :: endl ; // Wait for connection // - Wait for a connection // - Open http://localhost:8080 in your browser acceptor_ . async_accept ( [ this ]( std :: error_code ec , asio :: ip :: tcp :: socket socket ) { // If there is no error, create a socket and reply // - The session object wraps the a socket to create response // - The session will manage a single connection to a user if ( ! ec ) { // Start the session std :: make_shared < session > ( std :: move ( socket )) -> start (); } // Accept another connection // - The session will work asynchronously // - While the session will start to read the message, // the server already starts listening no another connection. schedule_accept (); }); } Server members 1 2 3 4 private /* members */ : // The only member we need is an acceptor for the server asio :: ip :: tcp :: acceptor acceptor_ ; }; Create io_context for server 1 2 3 4 int main () { try { // Create io_context as usual asio :: io_context io_context ; Create server 1 2 3 4 // We put all the logic inside a server object // - Nothing forbids us from organizing the server // in any other way. server s ( io_context , 8080 ); Dequeue tasks from io_context 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Run the io_context // - The server async functions will queue tasks in the io_context // - This function runs the io_context while there's work to do // - There is always going to be work to do because the server // is always listening asio :: thread_pool pool ; for ( unsigned i = 0 ; i < std :: thread :: hardware_concurrency (); ++ i ) { asio :: post ( pool , [ & io_context ] { // We run the io_context from the threads // - This allows us the io_context to send work to whatever // thread seems best io_context . run (); }); } Catch server exceptions 1 2 3 4 } catch ( std :: exception & e ) { // Report any exceptions std :: cerr << \"Exception: \" << e . what () << \" \\n \" ; } Share Snippets","title":"Async Network"},{"location":"utilities/networking/async-network/#async-network","text":"Find ASIO 1 2 3 4 5 6 7 8 9 10 11 12 find_package ( Asio 1.21.0 QUIET ) if ( NOT Asio_FOUND ) FetchContent_Declare ( asio GIT_REPOSITORY https://github.com/chriskohlhoff/asio.git GIT_TAG asio-1-21-0 ) FetchContent_GetProperties ( asio ) if ( NOT asio_POPULATED ) FetchContent_Populate ( asio ) add_library ( asio INTERFACE ) target_include_directories ( asio INTERFACE ${ asio_SOURCE_DIR } /asio/include ) target_compile_definitions ( asio INTERFACE ASIO_STANDALONE ASIO_NO_DEPRECATED ) target_link_libraries ( asio INTERFACE Threads::Threads ) endif () endif () CMakeLists.txt 1 2 add_executable ( network network.cpp ) target_link_libraries ( network asio ) Declare class to represent client session 1 2 3 4 5 6 7 8 9 10 11 12 class session : public std :: enable_shared_from_this < session > { public : explicit session ( asio :: ip :: tcp :: socket socket ) : socket_ ( std :: move ( socket )) { // Create a session to a client // The session just wraps a socket to communicate with the client } void start () { // Start the session by reading from the client schedule_read (); } Read whatever the client sent us 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 private : void schedule_read () { // Create another pointer to this session // - These pointers are useful to make sure there is always // some shared pointer pointing to this session object auto self ( shared_from_this ()); // Read some data from the client // - We read little by little to make sure everything is OK // - This is better than reading all at once // - We read max_length bytes at a time socket_ . async_read_some ( asio :: buffer ( data_ , max_length ), [ this , self ]( std :: error_code ec , std :: size_t length ) { // If there was no error reading the message, // write a response to the client if ( ! ec ) { std :: cout << \"Client sent: \" << std :: endl ; std :: cout << data_ << std :: endl << std :: endl ; schedule_write ( length ); } }); } Write a response to the client 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void schedule_write ( std :: size_t length ) { // Create another shared pointer to this to make sure it does die auto self ( shared_from_this ()); // Write a response asynchronously // - In this example, we write the same data back to the client asio :: async_write ( socket_ , asio :: buffer ( data_ , length ), [ this , self ]( std :: error_code ec , std :: size_t /*length*/ ) { // If there is no error if ( ! ec ) { std :: cout << \"Server replied with: \" << std :: endl ; std :: cout << data_ << std :: endl << std :: endl ; // Starting reading from the client again schedule_read (); } }); } Session data 1 2 3 4 5 6 7 8 9 // Socket representing connection to client asio :: ip :: tcp :: socket socket_ ; // Max length of the messages static constexpr size_t max_length = 1024 ; // Array to keep messages char data_ [ max_length ]{}; }; Define class to manage the acceptor and the clients 1 2 3 4 5 6 7 8 9 10 class server { public : // Construct server on a port // - The server just wraps the acceptor and starts a session whenever // the client connects server ( asio :: io_context & io_context , short port ) : acceptor_ ( io_context , asio :: ip :: tcp :: endpoint ( asio :: ip :: tcp :: v4 (), port )) { schedule_accept (); } Listen for connection 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 private : void schedule_accept () { std :: cout << \"Listening on http://localhost:\" << acceptor_ . local_endpoint (). port () << std :: endl ; // Wait for connection // - Wait for a connection // - Open http://localhost:8080 in your browser acceptor_ . async_accept ( [ this ]( std :: error_code ec , asio :: ip :: tcp :: socket socket ) { // If there is no error, create a socket and reply // - The session object wraps the a socket to create response // - The session will manage a single connection to a user if ( ! ec ) { // Start the session std :: make_shared < session > ( std :: move ( socket )) -> start (); } // Accept another connection // - The session will work asynchronously // - While the session will start to read the message, // the server already starts listening no another connection. schedule_accept (); }); } Server members 1 2 3 4 private /* members */ : // The only member we need is an acceptor for the server asio :: ip :: tcp :: acceptor acceptor_ ; }; Create io_context for server 1 2 3 4 int main () { try { // Create io_context as usual asio :: io_context io_context ; Create server 1 2 3 4 // We put all the logic inside a server object // - Nothing forbids us from organizing the server // in any other way. server s ( io_context , 8080 ); Dequeue tasks from io_context 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Run the io_context // - The server async functions will queue tasks in the io_context // - This function runs the io_context while there's work to do // - There is always going to be work to do because the server // is always listening asio :: thread_pool pool ; for ( unsigned i = 0 ; i < std :: thread :: hardware_concurrency (); ++ i ) { asio :: post ( pool , [ & io_context ] { // We run the io_context from the threads // - This allows us the io_context to send work to whatever // thread seems best io_context . run (); }); } Catch server exceptions 1 2 3 4 } catch ( std :: exception & e ) { // Report any exceptions std :: cerr << \"Exception: \" << e . what () << \" \\n \" ; } Share Snippets","title":"Async Network"},{"location":"utilities/networking/http-server/","text":"Http server Find ASIO 1 2 3 4 5 6 7 8 9 10 11 12 find_package ( Asio 1.21.0 QUIET ) if ( NOT Asio_FOUND ) FetchContent_Declare ( asio GIT_REPOSITORY https://github.com/chriskohlhoff/asio.git GIT_TAG asio-1-21-0 ) FetchContent_GetProperties ( asio ) if ( NOT asio_POPULATED ) FetchContent_Populate ( asio ) add_library ( asio INTERFACE ) target_include_directories ( asio INTERFACE ${ asio_SOURCE_DIR } /asio/include ) target_compile_definitions ( asio INTERFACE ASIO_STANDALONE ASIO_NO_DEPRECATED ) target_link_libraries ( asio INTERFACE Threads::Threads ) endif () endif () http_server 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 add_executable ( http_server connection.cpp connection.hpp connection_manager.cpp connection_manager.hpp header.hpp main.cpp mime_types.cpp mime_types.hpp reply.cpp reply.hpp request.hpp request_handler.cpp request_handler.hpp request_parser.cpp request_parser.hpp server.cpp server.hpp ) target_link_libraries ( http_server asio ) Check command line arguments. 1 2 3 4 5 6 7 8 9 int main ( int argc , char * argv []) { try { if ( argc != 4 ) { std :: cout << \"Usage: http_server <address> <port> <doc_root> \\n \" ; std :: cout << \" For IPv4, try: \" ; std :: cout << \" receiver 0.0.0.0 80 . \\n \" ; std :: cout << \" For IPv6, try: \" ; std :: cout << \" receiver 0::0 80 . \\n \" ; } Initialise the server 1 2 3 4 5 6 std :: string address = argc > 1 ? argv [ 1 ] : \"0.0.0.0\" ; std :: string port = argc > 2 ? argv [ 2 ] : \"80\" ; std :: string doc_root = argc > 3 ? argv [ 3 ] : \".\" ; std :: cout << \"Server address: http://\" << address << \":\" << port << '\\n' ; http :: server :: server s ( address , port , doc_root ); Run the server until stopped. 1 s . run (); Catch server exceptions 1 2 3 } catch ( std :: exception & e ) { std :: cerr << \"exception: \" << e . what () << \" \\n \" ; } Share Snippets Define top-level class for the HTTP server. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class server { public : server ( const server & ) = delete ; server & operator = ( const server & ) = delete ; // Construct the server to listen on the specified TCP address and // port, and serve up files from the given directory. explicit server ( const std :: string & address , const std :: string & port , const std :: string & doc_root ); // Run the server's io_context loop. void run (); private : // Perform an asynchronous accept operation. void schedule_accept (); // Wait for a request to stop the server. void schedule_await_stop (); // The io_context used to perform asynchronous operations. asio :: io_context io_context_ ; // Executor for the io context asio :: thread_pool pool_ ; // The signal_set is used to register for process termination // notifications. asio :: signal_set signals_ ; // Acceptor used to listen for incoming connections. asio :: ip :: tcp :: acceptor acceptor_ ; // The connection manager which owns all live connections. connection_manager connection_manager_ ; // The handler for all incoming requests. request_handler request_handler_ ; // Helper class to setup signals void setup_signals (); // Helper class to setup acceptor void setup_acceptor ( const std :: string & address , const std :: string & port ); }; Share Snippets Server constructor 1 2 3 4 5 6 7 server :: server ( const std :: string & address , const std :: string & port , const std :: string & doc_root ) : io_context_ ( 1 ), signals_ ( io_context_ ), acceptor_ ( io_context_ ), connection_manager_ (), request_handler_ ( doc_root ) { setup_signals (); setup_acceptor ( address , port ); } Setup server acceptor 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void server::setup_acceptor ( const std :: string & address , const std :: string & port ) { // Open the acceptor with the option to // reuse the address (i.e. SO_REUSEADDR). asio :: ip :: tcp :: resolver resolver ( io_context_ ); asio :: ip :: tcp :: endpoint endpoint = * resolver . resolve ( address , port ). begin (); acceptor_ . open ( endpoint . protocol ()); acceptor_ . set_option ( asio :: socket_base :: reuse_address ( true )); acceptor_ . bind ( endpoint ); acceptor_ . listen (); schedule_accept (); } Server setup_signals 1 2 3 4 5 6 7 8 9 10 11 12 void server::setup_signals () { // Register to handle the signals that indicate when the server // should exit. It is safe to register for the same signal multiple // times in a program, provided all registration for the specified // signal is made through Asio. signals_ . add ( SIGINT ); signals_ . add ( SIGTERM ); #if defined(SIGQUIT) signals_ . add ( SIGQUIT ); #endif // defined(SIGQUIT) schedule_await_stop (); } Server run 1 2 3 4 5 6 7 8 9 10 void server::run () { // The io_context::run() call will block until all asynchronous // operations have finished. While the server is running, there is // always at least one asynchronous operation outstanding: the // asynchronous accept call waiting for new incoming connections. for ( size_t i = 0 ; i < std :: thread :: hardware_concurrency (); ++ i ) { asio :: post ( pool_ , [ this ] { io_context_ . run (); }); } pool_ . join (); } Server schedule_accept 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void server::schedule_accept () { acceptor_ . async_accept ([ this ]( std :: error_code ec , asio :: ip :: tcp :: socket socket ) { // Check whether the server was stopped by a signal before // this completion handler had a chance to run. if ( ! acceptor_ . is_open ()) { return ; } if ( ! ec ) { connection_manager_ . start ( std :: make_shared < connection > ( std :: move ( socket ), connection_manager_ , request_handler_ )); } schedule_accept (); }); } Server schedule_await_stop 1 2 3 4 5 6 7 8 9 void server::schedule_await_stop () { signals_ . async_wait ([ this ]( std :: error_code /*ec*/ , int /*signo*/ ) { // The server is stopped by cancelling all outstanding // asynchronous operations. Once all operations have finished // the io_context::run() call will exit. acceptor_ . close (); connection_manager_ . stop_all (); }); } Share Snippets Declare connection manager 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // Manages open connections so that they may be cleanly stopped when // the server needs to shut down. class connection_manager { public : connection_manager ( const connection_manager & ) = delete ; connection_manager & operator = ( const connection_manager & ) = delete ; // Construct a connection manager. connection_manager (); // Add the specified connection to the manager and start it. void start ( connection_ptr c ); // Stop the specified connection. void stop ( connection_ptr c ); // Stop all connections. void stop_all (); private : // The managed connections. std :: set < connection_ptr > connections_ ; }; Share Snippets Default construct 1 connection_manager :: connection_manager () = default ; Start a connection 1 2 3 4 void connection_manager::start ( connection_ptr c ) { connections_ . insert ( c ); c -> start (); } Stop a connection 1 2 3 4 void connection_manager::stop ( connection_ptr c ) { connections_ . erase ( c ); c -> stop (); } Stop all connections 1 2 3 4 5 6 void connection_manager::stop_all () { for ( auto c : connections_ ) { c -> stop (); } connections_ . clear (); } Share Snippets Define class for a single connection from a client. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class connection : public std :: enable_shared_from_this < connection > { public : connection ( const connection & ) = delete ; connection & operator = ( const connection & ) = delete ; // Construct a connection with the given socket. explicit connection ( asio :: ip :: tcp :: socket socket , connection_manager & manager , request_handler & handler ); // Start the first asynchronous operation for the connection. void start (); // Stop all asynchronous operations associated with the connection. void stop (); private : // Perform an asynchronous read operation. void schedule_read (); // Perform an asynchronous write operation. void schedule_write (); // Socket for the connection. asio :: ip :: tcp :: socket socket_ ; // The manager for this connection. connection_manager & connection_manager_ ; // The handler used to process the incoming request. request_handler & request_handler_ ; // Buffer for incoming data. std :: array < char , 8192 > buffer_ ; // The incoming request. request request_ ; // The parser for the incoming request. request_parser request_parser_ ; // The reply to be sent back to the client. reply reply_ ; }; Share Snippets Construct a connection 1 2 3 4 5 connection :: connection ( asio :: ip :: tcp :: socket socket , connection_manager & manager , request_handler & handler ) : socket_ ( std :: move ( socket )), connection_manager_ ( manager ), request_handler_ ( handler ) {} Start connection by reading 1 void connection::start () { schedule_read (); } Stop connection by closing socket 1 void connection::stop () { socket_ . close (); } Schedule read operation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 void connection::schedule_read () { auto self ( shared_from_this ()); socket_ . async_read_some ( asio :: buffer ( buffer_ ), [ this , self ]( std :: error_code ec , std :: size_t bytes_transferred ) { if ( ! ec ) { // Parse as an HTTP request request_parser :: result_type result ; std :: tie ( result , std :: ignore ) = request_parser_ . parse ( request_ , buffer_ . data (), buffer_ . data () + bytes_transferred ); // Generate reply with the request handler and write it if ( result == request_parser :: good ) { request_handler_ . handle_request ( request_ , reply_ ); schedule_write (); } else if ( result == request_parser :: bad ) { reply_ = reply :: stock_reply ( reply :: bad_request ); schedule_write (); } else { schedule_read (); } } else if ( ec != asio :: error :: operation_aborted ) { connection_manager_ . stop ( shared_from_this ()); } }); } schedule_write operation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void connection::schedule_write () { auto self ( shared_from_this ()); asio :: async_write ( socket_ , reply_ . to_buffers (), [ this , self ]( std :: error_code ec , std :: size_t ) { if ( ! ec ) { // Initiate graceful connection closure. asio :: error_code ignored_ec ; socket_ . shutdown ( asio :: ip :: tcp :: socket :: shutdown_both , ignored_ec ); } if ( ec != asio :: error :: operation_aborted ) { connection_manager_ . stop ( shared_from_this ()); } }); } Share Snippets A reply to be sent to a client. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 struct reply { // The status of the reply. enum status_type { ok = 200 , created = 201 , accepted = 202 , no_content = 204 , multiple_choices = 300 , moved_permanently = 301 , moved_temporarily = 302 , not_modified = 304 , bad_request = 400 , unauthorized = 401 , forbidden = 403 , not_found = 404 , internal_server_error = 500 , not_implemented = 501 , bad_gateway = 502 , service_unavailable = 503 } status ; // The headers to be included in the reply. std :: vector < header > headers ; // The content to be sent in the reply. std :: string content ; // Convert the reply into a vector of buffers. The buffers do not // own the underlying memory blocks, therefore the reply object // must remain valid and not be changed until the write operation // has completed. std :: vector < asio :: const_buffer > to_buffers (); // Get a stock reply. static reply stock_reply ( status_type status ); }; Share Snippets Status Strings 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 namespace status_strings { const std :: string ok = \"HTTP/1.0 200 OK \\r\\n \" ; const std :: string created = \"HTTP/1.0 201 Created \\r\\n \" ; const std :: string accepted = \"HTTP/1.0 202 Accepted \\r\\n \" ; const std :: string no_content = \"HTTP/1.0 204 No Content \\r\\n \" ; const std :: string multiple_choices = \"HTTP/1.0 300 Multiple Choices \\r\\n \" ; const std :: string moved_permanently = \"HTTP/1.0 301 Moved Permanently \\r\\n \" ; const std :: string moved_temporarily = \"HTTP/1.0 302 Moved Temporarily \\r\\n \" ; const std :: string not_modified = \"HTTP/1.0 304 Not Modified \\r\\n \" ; const std :: string bad_request = \"HTTP/1.0 400 Bad Request \\r\\n \" ; const std :: string unauthorized = \"HTTP/1.0 401 Unauthorized \\r\\n \" ; const std :: string forbidden = \"HTTP/1.0 403 Forbidden \\r\\n \" ; const std :: string not_found = \"HTTP/1.0 404 Not Found \\r\\n \" ; const std :: string internal_server_error = \"HTTP/1.0 500 Internal Server Error \\r\\n \" ; const std :: string not_implemented = \"HTTP/1.0 501 Not Implemented \\r\\n \" ; const std :: string bad_gateway = \"HTTP/1.0 502 Bad Gateway \\r\\n \" ; const std :: string service_unavailable = \"HTTP/1.0 503 Service Unavailable \\r\\n \" ; Store status string in buffer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 asio :: const_buffer to_buffer ( reply :: status_type status ) { switch ( status ) { case reply :: ok : return asio :: buffer ( ok ); case reply :: created : return asio :: buffer ( created ); case reply :: accepted : return asio :: buffer ( accepted ); case reply :: no_content : return asio :: buffer ( no_content ); case reply :: multiple_choices : return asio :: buffer ( multiple_choices ); case reply :: moved_permanently : return asio :: buffer ( moved_permanently ); case reply :: moved_temporarily : return asio :: buffer ( moved_temporarily ); case reply :: not_modified : return asio :: buffer ( not_modified ); case reply :: bad_request : return asio :: buffer ( bad_request ); case reply :: unauthorized : return asio :: buffer ( unauthorized ); case reply :: forbidden : return asio :: buffer ( forbidden ); case reply :: not_found : return asio :: buffer ( not_found ); case reply :: internal_server_error : return asio :: buffer ( internal_server_error ); case reply :: not_implemented : return asio :: buffer ( not_implemented ); case reply :: bad_gateway : return asio :: buffer ( bad_gateway ); case reply :: service_unavailable : return asio :: buffer ( service_unavailable ); default : return asio :: buffer ( internal_server_error ); } } } // namespace status_strings Write reply to buffers 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 namespace misc_strings { const char name_value_separator [] = { ':' , ' ' }; const char crlf [] = { '\\r' , '\\n' }; } // namespace misc_strings std :: vector < asio :: const_buffer > reply :: to_buffers () { std :: vector < asio :: const_buffer > buffers ; buffers . push_back ( status_strings :: to_buffer ( status )); for ( std :: size_t i = 0 ; i < headers . size (); ++ i ) { header & h = headers [ i ]; buffers . push_back ( asio :: buffer ( h . name )); buffers . push_back ( asio :: buffer ( misc_strings :: name_value_separator )); buffers . push_back ( asio :: buffer ( h . value )); buffers . push_back ( asio :: buffer ( misc_strings :: crlf )); } buffers . push_back ( asio :: buffer ( misc_strings :: crlf )); buffers . push_back ( asio :: buffer ( content )); return buffers ; } Stock replies for messages 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 namespace stock_replies { namespace as_string { constexpr char ok [] = \"\" ; constexpr char created [] = \"<html>\" \"<head><title>Created</title></head>\" \"<body><h1>201 Created</h1></body>\" \"</html>\" ; constexpr char accepted [] = \"<html>\" \"<head><title>Accepted</title></head>\" \"<body><h1>202 Accepted</h1></body>\" \"</html>\" ; constexpr char no_content [] = \"<html>\" \"<head><title>No Content</title></head>\" \"<body><h1>204 Content</h1></body>\" \"</html>\" ; constexpr char multiple_choices [] = \"<html>\" \"<head><title>Multiple Choices</title></head>\" \"<body><h1>300 Multiple Choices</h1></body>\" \"</html>\" ; constexpr char moved_permanently [] = \"<html>\" \"<head><title>Moved Permanently</title></head>\" \"<body><h1>301 Moved Permanently</h1></body>\" \"</html>\" ; constexpr char moved_temporarily [] = \"<html>\" \"<head><title>Moved Temporarily</title></head>\" \"<body><h1>302 Moved Temporarily</h1></body>\" \"</html>\" ; constexpr char not_modified [] = \"<html>\" \"<head><title>Not Modified</title></head>\" \"<body><h1>304 Not Modified</h1></body>\" \"</html>\" ; constexpr char bad_request [] = \"<html>\" \"<head><title>Bad Request</title></head>\" \"<body><h1>400 Bad Request</h1></body>\" \"</html>\" ; constexpr char unauthorized [] = \"<html>\" \"<head><title>Unauthorized</title></head>\" \"<body><h1>401 Unauthorized</h1></body>\" \"</html>\" ; constexpr char forbidden [] = \"<html>\" \"<head><title>Forbidden</title></head>\" \"<body><h1>403 Forbidden</h1></body>\" \"</html>\" ; constexpr char not_found [] = \"<html>\" \"<head><title>Not Found</title></head>\" \"<body><h1>404 Not Found</h1></body>\" \"</html>\" ; constexpr char internal_server_error [] = \"<html>\" \"<head><title>Internal Server Error</title></head>\" \"<body><h1>500 Internal Server Error</h1></body>\" \"</html>\" ; constexpr char not_implemented [] = \"<html>\" \"<head><title>Not Implemented</title></head>\" \"<body><h1>501 Not Implemented</h1></body>\" \"</html>\" ; constexpr char bad_gateway [] = \"<html>\" \"<head><title>Bad Gateway</title></head>\" \"<body><h1>502 Bad Gateway</h1></body>\" \"</html>\" ; constexpr char service_unavailable [] = \"<html>\" \"<head><title>Service Unavailable</title></head>\" \"<body><h1>503 Service Unavailable</h1></body>\" \"</html>\" ; } // namespace as_string std :: string to_string ( reply :: status_type status ) { switch ( status ) { case reply :: ok : // NOLINT(bugprone-branch-clone) return as_string :: ok ; case reply :: created : return as_string :: created ; case reply :: accepted : return as_string :: accepted ; case reply :: no_content : return as_string :: no_content ; case reply :: multiple_choices : return as_string :: multiple_choices ; case reply :: moved_permanently : return as_string :: moved_permanently ; case reply :: moved_temporarily : return as_string :: moved_temporarily ; case reply :: not_modified : return as_string :: not_modified ; case reply :: bad_request : return as_string :: bad_request ; case reply :: unauthorized : return as_string :: unauthorized ; case reply :: forbidden : return as_string :: forbidden ; case reply :: not_found : return as_string :: not_found ; case reply :: internal_server_error : return as_string :: internal_server_error ; case reply :: not_implemented : return as_string :: not_implemented ; case reply :: bad_gateway : return as_string :: bad_gateway ; case reply :: service_unavailable : return as_string :: service_unavailable ; default : return as_string :: internal_server_error ; } } } // namespace stock_replies Create stock reply from status 1 2 3 4 5 6 7 8 9 10 11 reply reply::stock_reply ( reply :: status_type status ) { reply rep ; rep . status = status ; rep . headers . resize ( 2 ); rep . headers [ 0 ]. name = \"Content-Length\" ; rep . content = stock_replies :: to_string ( status ); rep . headers [ 0 ]. value = std :: to_string ( rep . content . size ()); rep . headers [ 1 ]. name = \"Content-Type\" ; rep . headers [ 1 ]. value = \"text/html\" ; return rep ; } Share Snippets Struct for request headers 1 2 3 4 struct header { std :: string name ; std :: string value ; }; Share Snippets A request received from a client. 1 2 3 4 5 6 7 struct request { std :: string method ; std :: string uri ; int http_version_major ; int http_version_minor ; std :: vector < header > headers ; }; Share Snippets Parser for incoming requests. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class request_parser { public : // Construct ready to parse the request method. request_parser (); // Reset to initial parser state. void reset (); // Result of parse. enum result_type { good , bad , indeterminate }; // Parse some data. The enum return value is good when a complete // request has been parsed, bad if the data is invalid, // indeterminate when more data is required. The InputIterator // return value indicates how much of the input has been consumed. template < typename InputIterator > std :: tuple < result_type , InputIterator > parse ( request & req , InputIterator begin , InputIterator end ) { while ( begin != end ) { result_type result = consume ( req , * begin ++ ); if ( result == good || result == bad ) return std :: make_tuple ( result , begin ); } return std :: make_tuple ( indeterminate , begin ); } private : // Handle the next character of input. result_type consume ( request & req , char input ); // Check if a byte is an HTTP character. static bool is_char ( int c ); // Check if a byte is an HTTP control character. static bool is_ctl ( int c ); // Check if a byte is defined as an HTTP tspecial character. static bool is_tspecial ( int c ); // Check if a byte is a digit. static bool is_digit ( int c ); // The current state of the parser. enum state { method_start , method , uri , http_version_h , http_version_t_1 , http_version_t_2 , http_version_p , http_version_slash , http_version_major_start , http_version_major , http_version_minor_start , http_version_minor , expecting_newline_1 , header_line_start , header_lws , header_name , space_before_header_value , header_value , expecting_newline_2 , expecting_newline_3 } state_ ; }; Share Snippets Construct parser 1 request_parser :: request_parser () : state_ ( method_start ) {} Reset parser 1 void request_parser::reset () { state_ = method_start ; } Consume char input 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 request_parser :: result_type request_parser::consume ( request & req , char input ) { switch ( state_ ) { case method_start : if ( ! is_char ( input ) || is_ctl ( input ) || is_tspecial ( input )) { return bad ; } else { state_ = method ; req . method . push_back ( input ); return indeterminate ; } case method : if ( input == ' ' ) { state_ = uri ; return indeterminate ; } else if ( ! is_char ( input ) || is_ctl ( input ) || is_tspecial ( input )) { return bad ; } else { req . method . push_back ( input ); return indeterminate ; } case uri : if ( input == ' ' ) { state_ = http_version_h ; return indeterminate ; } else if ( is_ctl ( input )) { return bad ; } else { req . uri . push_back ( input ); return indeterminate ; } case http_version_h : if ( input == 'H' ) { state_ = http_version_t_1 ; return indeterminate ; } else { return bad ; } case http_version_t_1 : if ( input == 'T' ) { state_ = http_version_t_2 ; return indeterminate ; } else { return bad ; } case http_version_t_2 : if ( input == 'T' ) { state_ = http_version_p ; return indeterminate ; } else { return bad ; } case http_version_p : if ( input == 'P' ) { state_ = http_version_slash ; return indeterminate ; } else { return bad ; } case http_version_slash : if ( input == '/' ) { req . http_version_major = 0 ; req . http_version_minor = 0 ; state_ = http_version_major_start ; return indeterminate ; } else { return bad ; } case http_version_major_start : if ( is_digit ( input )) { req . http_version_major = req . http_version_major * 10 + input - '0' ; state_ = http_version_major ; return indeterminate ; } else { return bad ; } case http_version_major : if ( input == '.' ) { state_ = http_version_minor_start ; return indeterminate ; } else if ( is_digit ( input )) { req . http_version_major = req . http_version_major * 10 + input - '0' ; return indeterminate ; } else { return bad ; } case http_version_minor_start : if ( is_digit ( input )) { req . http_version_minor = req . http_version_minor * 10 + input - '0' ; state_ = http_version_minor ; return indeterminate ; } else { return bad ; } case http_version_minor : if ( input == '\\r' ) { state_ = expecting_newline_1 ; return indeterminate ; } else if ( is_digit ( input )) { req . http_version_minor = req . http_version_minor * 10 + input - '0' ; return indeterminate ; } else { return bad ; } case expecting_newline_1 : if ( input == '\\n' ) { state_ = header_line_start ; return indeterminate ; } else { return bad ; } case header_line_start : if ( input == '\\r' ) { state_ = expecting_newline_3 ; return indeterminate ; } else if ( ! req . headers . empty () && ( input == ' ' || input == '\\t' )) { state_ = header_lws ; return indeterminate ; } else if ( ! is_char ( input ) || is_ctl ( input ) || is_tspecial ( input )) { return bad ; } else { req . headers . push_back ( header ()); req . headers . back (). name . push_back ( input ); state_ = header_name ; return indeterminate ; } case header_lws : if ( input == '\\r' ) { state_ = expecting_newline_2 ; return indeterminate ; } else if ( input == ' ' || input == '\\t' ) { return indeterminate ; } else if ( is_ctl ( input )) { return bad ; } else { state_ = header_value ; req . headers . back (). value . push_back ( input ); return indeterminate ; } case header_name : if ( input == ':' ) { state_ = space_before_header_value ; return indeterminate ; } else if ( ! is_char ( input ) || is_ctl ( input ) || is_tspecial ( input )) { return bad ; } else { req . headers . back (). name . push_back ( input ); return indeterminate ; } case space_before_header_value : if ( input == ' ' ) { state_ = header_value ; return indeterminate ; } else { return bad ; } case header_value : if ( input == '\\r' ) { state_ = expecting_newline_2 ; return indeterminate ; } else if ( is_ctl ( input )) { return bad ; } else { req . headers . back (). value . push_back ( input ); return indeterminate ; } case expecting_newline_2 : if ( input == '\\n' ) { state_ = header_line_start ; return indeterminate ; } else { return bad ; } case expecting_newline_3 : return ( input == '\\n' ) ? good : bad ; default : return bad ; } } Check if c is char 1 bool request_parser::is_char ( int c ) { return c >= 0 && c <= 127 ; } Check if c is ctl 1 2 3 bool request_parser::is_ctl ( int c ) { return ( c >= 0 && c <= 31 ) || ( c == 127 ); } Check if c is special 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 bool request_parser::is_tspecial ( int c ) { switch ( c ) { case '(' : case ')' : case '<' : case '>' : case '@' : case ',' : case ';' : case ':' : case '\\\\' : case '\"' : case '/' : case '[' : case ']' : case '?' : case '=' : case '{' : case '}' : case ' ' : case '\\t' : return true ; default : return false ; } } Check if c is digit 1 bool request_parser::is_digit ( int c ) { return c >= '0' && c <= '9' ; } Share Snippets The common handler for all incoming requests. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class request_handler { public : request_handler ( const request_handler & ) = delete ; request_handler & operator = ( const request_handler & ) = delete ; // Construct with a directory containing files to be served. explicit request_handler ( const std :: string & doc_root ); // Handle a request and produce a reply. void handle_request ( const request & req , reply & rep ); private : // The directory containing the files to be served. std :: string doc_root_ ; // Perform URL-decoding on a string. Returns false if the encoding // was invalid. static bool url_decode ( const std :: string & in , std :: string & out ); }; Share Snippets Request handler constructor 1 2 request_handler :: request_handler ( const std :: string & doc_root ) : doc_root_ ( doc_root ) {} Handle a parsed request and generate reply 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 void request_handler::handle_request ( const request & req , reply & rep ) { // Decode url to path. std :: string request_path ; if ( ! url_decode ( req . uri , request_path )) { rep = reply :: stock_reply ( reply :: bad_request ); return ; } // Request path must be absolute and not contain \"..\". if ( request_path . empty () || request_path [ 0 ] != '/' || request_path . find ( \"..\" ) != std :: string :: npos ) { rep = reply :: stock_reply ( reply :: bad_request ); return ; } // If path ends in slash (i.e. is a directory) then add // \"index.html\". if ( request_path [ request_path . size () - 1 ] == '/' ) { request_path += \"index.html\" ; } // Determine the file extension. std :: size_t last_slash_pos = request_path . find_last_of ( \"/\" ); std :: size_t last_dot_pos = request_path . find_last_of ( \".\" ); std :: string extension ; if ( last_dot_pos != std :: string :: npos && last_dot_pos > last_slash_pos ) { extension = request_path . substr ( last_dot_pos + 1 ); } // Open the file to send back. std :: string full_path = doc_root_ + request_path ; std :: ifstream is ( full_path . c_str (), std :: ios :: in | std :: ios :: binary ); if ( ! is ) { rep = reply :: stock_reply ( reply :: not_found ); return ; } // Fill out the reply to be sent to the client. rep . status = reply :: ok ; char buf [ 512 ]; while ( is . read ( buf , sizeof ( buf )). gcount () > 0 ) rep . content . append ( buf , is . gcount ()); rep . headers . resize ( 2 ); rep . headers [ 0 ]. name = \"Content-Length\" ; rep . headers [ 0 ]. value = std :: to_string ( rep . content . size ()); rep . headers [ 1 ]. name = \"Content-Type\" ; rep . headers [ 1 ]. value = mime_types :: extension_to_type ( extension ); } Decode url string 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 bool request_handler::url_decode ( const std :: string & in , std :: string & out ) { out . clear (); out . reserve ( in . size ()); for ( std :: size_t i = 0 ; i < in . size (); ++ i ) { if ( in [ i ] == '%' ) { if ( i + 3 <= in . size ()) { int value = 0 ; std :: istringstream is ( in . substr ( i + 1 , 2 )); if ( is >> std :: hex >> value ) { out += static_cast < char > ( value ); i += 2 ; } else { return false ; } } else { return false ; } } else if ( in [ i ] == '+' ) { out += ' ' ; } else { out += in [ i ]; } } return true ; } Share Snippets Convert a file extension into a MIME type. 1 std :: string extension_to_type ( const std :: string & extension ); Share Snippets Map MIME types 1 2 3 4 5 6 7 8 constexpr struct mapping { const char * extension ; const char * mime_type ; } mappings [] = {{ \"gif\" , \"image/gif\" }, { \"htm\" , \"text/html\" }, { \"html\" , \"text/html\" }, { \"jpg\" , \"image/jpeg\" }, { \"png\" , \"image/png\" }}; Convert file extension to type 1 2 3 4 5 6 7 8 9 std :: string extension_to_type ( const std :: string & extension ) { for ( mapping m : mappings ) { if ( m . extension == extension ) { return m . mime_type ; } } return \"text/plain\" ; } Share Snippets","title":"Http server"},{"location":"utilities/networking/http-server/#http-server","text":"Find ASIO 1 2 3 4 5 6 7 8 9 10 11 12 find_package ( Asio 1.21.0 QUIET ) if ( NOT Asio_FOUND ) FetchContent_Declare ( asio GIT_REPOSITORY https://github.com/chriskohlhoff/asio.git GIT_TAG asio-1-21-0 ) FetchContent_GetProperties ( asio ) if ( NOT asio_POPULATED ) FetchContent_Populate ( asio ) add_library ( asio INTERFACE ) target_include_directories ( asio INTERFACE ${ asio_SOURCE_DIR } /asio/include ) target_compile_definitions ( asio INTERFACE ASIO_STANDALONE ASIO_NO_DEPRECATED ) target_link_libraries ( asio INTERFACE Threads::Threads ) endif () endif () http_server 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 add_executable ( http_server connection.cpp connection.hpp connection_manager.cpp connection_manager.hpp header.hpp main.cpp mime_types.cpp mime_types.hpp reply.cpp reply.hpp request.hpp request_handler.cpp request_handler.hpp request_parser.cpp request_parser.hpp server.cpp server.hpp ) target_link_libraries ( http_server asio ) Check command line arguments. 1 2 3 4 5 6 7 8 9 int main ( int argc , char * argv []) { try { if ( argc != 4 ) { std :: cout << \"Usage: http_server <address> <port> <doc_root> \\n \" ; std :: cout << \" For IPv4, try: \" ; std :: cout << \" receiver 0.0.0.0 80 . \\n \" ; std :: cout << \" For IPv6, try: \" ; std :: cout << \" receiver 0::0 80 . \\n \" ; } Initialise the server 1 2 3 4 5 6 std :: string address = argc > 1 ? argv [ 1 ] : \"0.0.0.0\" ; std :: string port = argc > 2 ? argv [ 2 ] : \"80\" ; std :: string doc_root = argc > 3 ? argv [ 3 ] : \".\" ; std :: cout << \"Server address: http://\" << address << \":\" << port << '\\n' ; http :: server :: server s ( address , port , doc_root ); Run the server until stopped. 1 s . run (); Catch server exceptions 1 2 3 } catch ( std :: exception & e ) { std :: cerr << \"exception: \" << e . what () << \" \\n \" ; } Share Snippets Define top-level class for the HTTP server. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class server { public : server ( const server & ) = delete ; server & operator = ( const server & ) = delete ; // Construct the server to listen on the specified TCP address and // port, and serve up files from the given directory. explicit server ( const std :: string & address , const std :: string & port , const std :: string & doc_root ); // Run the server's io_context loop. void run (); private : // Perform an asynchronous accept operation. void schedule_accept (); // Wait for a request to stop the server. void schedule_await_stop (); // The io_context used to perform asynchronous operations. asio :: io_context io_context_ ; // Executor for the io context asio :: thread_pool pool_ ; // The signal_set is used to register for process termination // notifications. asio :: signal_set signals_ ; // Acceptor used to listen for incoming connections. asio :: ip :: tcp :: acceptor acceptor_ ; // The connection manager which owns all live connections. connection_manager connection_manager_ ; // The handler for all incoming requests. request_handler request_handler_ ; // Helper class to setup signals void setup_signals (); // Helper class to setup acceptor void setup_acceptor ( const std :: string & address , const std :: string & port ); }; Share Snippets Server constructor 1 2 3 4 5 6 7 server :: server ( const std :: string & address , const std :: string & port , const std :: string & doc_root ) : io_context_ ( 1 ), signals_ ( io_context_ ), acceptor_ ( io_context_ ), connection_manager_ (), request_handler_ ( doc_root ) { setup_signals (); setup_acceptor ( address , port ); } Setup server acceptor 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void server::setup_acceptor ( const std :: string & address , const std :: string & port ) { // Open the acceptor with the option to // reuse the address (i.e. SO_REUSEADDR). asio :: ip :: tcp :: resolver resolver ( io_context_ ); asio :: ip :: tcp :: endpoint endpoint = * resolver . resolve ( address , port ). begin (); acceptor_ . open ( endpoint . protocol ()); acceptor_ . set_option ( asio :: socket_base :: reuse_address ( true )); acceptor_ . bind ( endpoint ); acceptor_ . listen (); schedule_accept (); } Server setup_signals 1 2 3 4 5 6 7 8 9 10 11 12 void server::setup_signals () { // Register to handle the signals that indicate when the server // should exit. It is safe to register for the same signal multiple // times in a program, provided all registration for the specified // signal is made through Asio. signals_ . add ( SIGINT ); signals_ . add ( SIGTERM ); #if defined(SIGQUIT) signals_ . add ( SIGQUIT ); #endif // defined(SIGQUIT) schedule_await_stop (); } Server run 1 2 3 4 5 6 7 8 9 10 void server::run () { // The io_context::run() call will block until all asynchronous // operations have finished. While the server is running, there is // always at least one asynchronous operation outstanding: the // asynchronous accept call waiting for new incoming connections. for ( size_t i = 0 ; i < std :: thread :: hardware_concurrency (); ++ i ) { asio :: post ( pool_ , [ this ] { io_context_ . run (); }); } pool_ . join (); } Server schedule_accept 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void server::schedule_accept () { acceptor_ . async_accept ([ this ]( std :: error_code ec , asio :: ip :: tcp :: socket socket ) { // Check whether the server was stopped by a signal before // this completion handler had a chance to run. if ( ! acceptor_ . is_open ()) { return ; } if ( ! ec ) { connection_manager_ . start ( std :: make_shared < connection > ( std :: move ( socket ), connection_manager_ , request_handler_ )); } schedule_accept (); }); } Server schedule_await_stop 1 2 3 4 5 6 7 8 9 void server::schedule_await_stop () { signals_ . async_wait ([ this ]( std :: error_code /*ec*/ , int /*signo*/ ) { // The server is stopped by cancelling all outstanding // asynchronous operations. Once all operations have finished // the io_context::run() call will exit. acceptor_ . close (); connection_manager_ . stop_all (); }); } Share Snippets Declare connection manager 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // Manages open connections so that they may be cleanly stopped when // the server needs to shut down. class connection_manager { public : connection_manager ( const connection_manager & ) = delete ; connection_manager & operator = ( const connection_manager & ) = delete ; // Construct a connection manager. connection_manager (); // Add the specified connection to the manager and start it. void start ( connection_ptr c ); // Stop the specified connection. void stop ( connection_ptr c ); // Stop all connections. void stop_all (); private : // The managed connections. std :: set < connection_ptr > connections_ ; }; Share Snippets Default construct 1 connection_manager :: connection_manager () = default ; Start a connection 1 2 3 4 void connection_manager::start ( connection_ptr c ) { connections_ . insert ( c ); c -> start (); } Stop a connection 1 2 3 4 void connection_manager::stop ( connection_ptr c ) { connections_ . erase ( c ); c -> stop (); } Stop all connections 1 2 3 4 5 6 void connection_manager::stop_all () { for ( auto c : connections_ ) { c -> stop (); } connections_ . clear (); } Share Snippets Define class for a single connection from a client. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class connection : public std :: enable_shared_from_this < connection > { public : connection ( const connection & ) = delete ; connection & operator = ( const connection & ) = delete ; // Construct a connection with the given socket. explicit connection ( asio :: ip :: tcp :: socket socket , connection_manager & manager , request_handler & handler ); // Start the first asynchronous operation for the connection. void start (); // Stop all asynchronous operations associated with the connection. void stop (); private : // Perform an asynchronous read operation. void schedule_read (); // Perform an asynchronous write operation. void schedule_write (); // Socket for the connection. asio :: ip :: tcp :: socket socket_ ; // The manager for this connection. connection_manager & connection_manager_ ; // The handler used to process the incoming request. request_handler & request_handler_ ; // Buffer for incoming data. std :: array < char , 8192 > buffer_ ; // The incoming request. request request_ ; // The parser for the incoming request. request_parser request_parser_ ; // The reply to be sent back to the client. reply reply_ ; }; Share Snippets Construct a connection 1 2 3 4 5 connection :: connection ( asio :: ip :: tcp :: socket socket , connection_manager & manager , request_handler & handler ) : socket_ ( std :: move ( socket )), connection_manager_ ( manager ), request_handler_ ( handler ) {} Start connection by reading 1 void connection::start () { schedule_read (); } Stop connection by closing socket 1 void connection::stop () { socket_ . close (); } Schedule read operation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 void connection::schedule_read () { auto self ( shared_from_this ()); socket_ . async_read_some ( asio :: buffer ( buffer_ ), [ this , self ]( std :: error_code ec , std :: size_t bytes_transferred ) { if ( ! ec ) { // Parse as an HTTP request request_parser :: result_type result ; std :: tie ( result , std :: ignore ) = request_parser_ . parse ( request_ , buffer_ . data (), buffer_ . data () + bytes_transferred ); // Generate reply with the request handler and write it if ( result == request_parser :: good ) { request_handler_ . handle_request ( request_ , reply_ ); schedule_write (); } else if ( result == request_parser :: bad ) { reply_ = reply :: stock_reply ( reply :: bad_request ); schedule_write (); } else { schedule_read (); } } else if ( ec != asio :: error :: operation_aborted ) { connection_manager_ . stop ( shared_from_this ()); } }); } schedule_write operation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void connection::schedule_write () { auto self ( shared_from_this ()); asio :: async_write ( socket_ , reply_ . to_buffers (), [ this , self ]( std :: error_code ec , std :: size_t ) { if ( ! ec ) { // Initiate graceful connection closure. asio :: error_code ignored_ec ; socket_ . shutdown ( asio :: ip :: tcp :: socket :: shutdown_both , ignored_ec ); } if ( ec != asio :: error :: operation_aborted ) { connection_manager_ . stop ( shared_from_this ()); } }); } Share Snippets A reply to be sent to a client. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 struct reply { // The status of the reply. enum status_type { ok = 200 , created = 201 , accepted = 202 , no_content = 204 , multiple_choices = 300 , moved_permanently = 301 , moved_temporarily = 302 , not_modified = 304 , bad_request = 400 , unauthorized = 401 , forbidden = 403 , not_found = 404 , internal_server_error = 500 , not_implemented = 501 , bad_gateway = 502 , service_unavailable = 503 } status ; // The headers to be included in the reply. std :: vector < header > headers ; // The content to be sent in the reply. std :: string content ; // Convert the reply into a vector of buffers. The buffers do not // own the underlying memory blocks, therefore the reply object // must remain valid and not be changed until the write operation // has completed. std :: vector < asio :: const_buffer > to_buffers (); // Get a stock reply. static reply stock_reply ( status_type status ); }; Share Snippets Status Strings 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 namespace status_strings { const std :: string ok = \"HTTP/1.0 200 OK \\r\\n \" ; const std :: string created = \"HTTP/1.0 201 Created \\r\\n \" ; const std :: string accepted = \"HTTP/1.0 202 Accepted \\r\\n \" ; const std :: string no_content = \"HTTP/1.0 204 No Content \\r\\n \" ; const std :: string multiple_choices = \"HTTP/1.0 300 Multiple Choices \\r\\n \" ; const std :: string moved_permanently = \"HTTP/1.0 301 Moved Permanently \\r\\n \" ; const std :: string moved_temporarily = \"HTTP/1.0 302 Moved Temporarily \\r\\n \" ; const std :: string not_modified = \"HTTP/1.0 304 Not Modified \\r\\n \" ; const std :: string bad_request = \"HTTP/1.0 400 Bad Request \\r\\n \" ; const std :: string unauthorized = \"HTTP/1.0 401 Unauthorized \\r\\n \" ; const std :: string forbidden = \"HTTP/1.0 403 Forbidden \\r\\n \" ; const std :: string not_found = \"HTTP/1.0 404 Not Found \\r\\n \" ; const std :: string internal_server_error = \"HTTP/1.0 500 Internal Server Error \\r\\n \" ; const std :: string not_implemented = \"HTTP/1.0 501 Not Implemented \\r\\n \" ; const std :: string bad_gateway = \"HTTP/1.0 502 Bad Gateway \\r\\n \" ; const std :: string service_unavailable = \"HTTP/1.0 503 Service Unavailable \\r\\n \" ; Store status string in buffer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 asio :: const_buffer to_buffer ( reply :: status_type status ) { switch ( status ) { case reply :: ok : return asio :: buffer ( ok ); case reply :: created : return asio :: buffer ( created ); case reply :: accepted : return asio :: buffer ( accepted ); case reply :: no_content : return asio :: buffer ( no_content ); case reply :: multiple_choices : return asio :: buffer ( multiple_choices ); case reply :: moved_permanently : return asio :: buffer ( moved_permanently ); case reply :: moved_temporarily : return asio :: buffer ( moved_temporarily ); case reply :: not_modified : return asio :: buffer ( not_modified ); case reply :: bad_request : return asio :: buffer ( bad_request ); case reply :: unauthorized : return asio :: buffer ( unauthorized ); case reply :: forbidden : return asio :: buffer ( forbidden ); case reply :: not_found : return asio :: buffer ( not_found ); case reply :: internal_server_error : return asio :: buffer ( internal_server_error ); case reply :: not_implemented : return asio :: buffer ( not_implemented ); case reply :: bad_gateway : return asio :: buffer ( bad_gateway ); case reply :: service_unavailable : return asio :: buffer ( service_unavailable ); default : return asio :: buffer ( internal_server_error ); } } } // namespace status_strings Write reply to buffers 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 namespace misc_strings { const char name_value_separator [] = { ':' , ' ' }; const char crlf [] = { '\\r' , '\\n' }; } // namespace misc_strings std :: vector < asio :: const_buffer > reply :: to_buffers () { std :: vector < asio :: const_buffer > buffers ; buffers . push_back ( status_strings :: to_buffer ( status )); for ( std :: size_t i = 0 ; i < headers . size (); ++ i ) { header & h = headers [ i ]; buffers . push_back ( asio :: buffer ( h . name )); buffers . push_back ( asio :: buffer ( misc_strings :: name_value_separator )); buffers . push_back ( asio :: buffer ( h . value )); buffers . push_back ( asio :: buffer ( misc_strings :: crlf )); } buffers . push_back ( asio :: buffer ( misc_strings :: crlf )); buffers . push_back ( asio :: buffer ( content )); return buffers ; } Stock replies for messages 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 namespace stock_replies { namespace as_string { constexpr char ok [] = \"\" ; constexpr char created [] = \"<html>\" \"<head><title>Created</title></head>\" \"<body><h1>201 Created</h1></body>\" \"</html>\" ; constexpr char accepted [] = \"<html>\" \"<head><title>Accepted</title></head>\" \"<body><h1>202 Accepted</h1></body>\" \"</html>\" ; constexpr char no_content [] = \"<html>\" \"<head><title>No Content</title></head>\" \"<body><h1>204 Content</h1></body>\" \"</html>\" ; constexpr char multiple_choices [] = \"<html>\" \"<head><title>Multiple Choices</title></head>\" \"<body><h1>300 Multiple Choices</h1></body>\" \"</html>\" ; constexpr char moved_permanently [] = \"<html>\" \"<head><title>Moved Permanently</title></head>\" \"<body><h1>301 Moved Permanently</h1></body>\" \"</html>\" ; constexpr char moved_temporarily [] = \"<html>\" \"<head><title>Moved Temporarily</title></head>\" \"<body><h1>302 Moved Temporarily</h1></body>\" \"</html>\" ; constexpr char not_modified [] = \"<html>\" \"<head><title>Not Modified</title></head>\" \"<body><h1>304 Not Modified</h1></body>\" \"</html>\" ; constexpr char bad_request [] = \"<html>\" \"<head><title>Bad Request</title></head>\" \"<body><h1>400 Bad Request</h1></body>\" \"</html>\" ; constexpr char unauthorized [] = \"<html>\" \"<head><title>Unauthorized</title></head>\" \"<body><h1>401 Unauthorized</h1></body>\" \"</html>\" ; constexpr char forbidden [] = \"<html>\" \"<head><title>Forbidden</title></head>\" \"<body><h1>403 Forbidden</h1></body>\" \"</html>\" ; constexpr char not_found [] = \"<html>\" \"<head><title>Not Found</title></head>\" \"<body><h1>404 Not Found</h1></body>\" \"</html>\" ; constexpr char internal_server_error [] = \"<html>\" \"<head><title>Internal Server Error</title></head>\" \"<body><h1>500 Internal Server Error</h1></body>\" \"</html>\" ; constexpr char not_implemented [] = \"<html>\" \"<head><title>Not Implemented</title></head>\" \"<body><h1>501 Not Implemented</h1></body>\" \"</html>\" ; constexpr char bad_gateway [] = \"<html>\" \"<head><title>Bad Gateway</title></head>\" \"<body><h1>502 Bad Gateway</h1></body>\" \"</html>\" ; constexpr char service_unavailable [] = \"<html>\" \"<head><title>Service Unavailable</title></head>\" \"<body><h1>503 Service Unavailable</h1></body>\" \"</html>\" ; } // namespace as_string std :: string to_string ( reply :: status_type status ) { switch ( status ) { case reply :: ok : // NOLINT(bugprone-branch-clone) return as_string :: ok ; case reply :: created : return as_string :: created ; case reply :: accepted : return as_string :: accepted ; case reply :: no_content : return as_string :: no_content ; case reply :: multiple_choices : return as_string :: multiple_choices ; case reply :: moved_permanently : return as_string :: moved_permanently ; case reply :: moved_temporarily : return as_string :: moved_temporarily ; case reply :: not_modified : return as_string :: not_modified ; case reply :: bad_request : return as_string :: bad_request ; case reply :: unauthorized : return as_string :: unauthorized ; case reply :: forbidden : return as_string :: forbidden ; case reply :: not_found : return as_string :: not_found ; case reply :: internal_server_error : return as_string :: internal_server_error ; case reply :: not_implemented : return as_string :: not_implemented ; case reply :: bad_gateway : return as_string :: bad_gateway ; case reply :: service_unavailable : return as_string :: service_unavailable ; default : return as_string :: internal_server_error ; } } } // namespace stock_replies Create stock reply from status 1 2 3 4 5 6 7 8 9 10 11 reply reply::stock_reply ( reply :: status_type status ) { reply rep ; rep . status = status ; rep . headers . resize ( 2 ); rep . headers [ 0 ]. name = \"Content-Length\" ; rep . content = stock_replies :: to_string ( status ); rep . headers [ 0 ]. value = std :: to_string ( rep . content . size ()); rep . headers [ 1 ]. name = \"Content-Type\" ; rep . headers [ 1 ]. value = \"text/html\" ; return rep ; } Share Snippets Struct for request headers 1 2 3 4 struct header { std :: string name ; std :: string value ; }; Share Snippets A request received from a client. 1 2 3 4 5 6 7 struct request { std :: string method ; std :: string uri ; int http_version_major ; int http_version_minor ; std :: vector < header > headers ; }; Share Snippets Parser for incoming requests. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class request_parser { public : // Construct ready to parse the request method. request_parser (); // Reset to initial parser state. void reset (); // Result of parse. enum result_type { good , bad , indeterminate }; // Parse some data. The enum return value is good when a complete // request has been parsed, bad if the data is invalid, // indeterminate when more data is required. The InputIterator // return value indicates how much of the input has been consumed. template < typename InputIterator > std :: tuple < result_type , InputIterator > parse ( request & req , InputIterator begin , InputIterator end ) { while ( begin != end ) { result_type result = consume ( req , * begin ++ ); if ( result == good || result == bad ) return std :: make_tuple ( result , begin ); } return std :: make_tuple ( indeterminate , begin ); } private : // Handle the next character of input. result_type consume ( request & req , char input ); // Check if a byte is an HTTP character. static bool is_char ( int c ); // Check if a byte is an HTTP control character. static bool is_ctl ( int c ); // Check if a byte is defined as an HTTP tspecial character. static bool is_tspecial ( int c ); // Check if a byte is a digit. static bool is_digit ( int c ); // The current state of the parser. enum state { method_start , method , uri , http_version_h , http_version_t_1 , http_version_t_2 , http_version_p , http_version_slash , http_version_major_start , http_version_major , http_version_minor_start , http_version_minor , expecting_newline_1 , header_line_start , header_lws , header_name , space_before_header_value , header_value , expecting_newline_2 , expecting_newline_3 } state_ ; }; Share Snippets Construct parser 1 request_parser :: request_parser () : state_ ( method_start ) {} Reset parser 1 void request_parser::reset () { state_ = method_start ; } Consume char input 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 request_parser :: result_type request_parser::consume ( request & req , char input ) { switch ( state_ ) { case method_start : if ( ! is_char ( input ) || is_ctl ( input ) || is_tspecial ( input )) { return bad ; } else { state_ = method ; req . method . push_back ( input ); return indeterminate ; } case method : if ( input == ' ' ) { state_ = uri ; return indeterminate ; } else if ( ! is_char ( input ) || is_ctl ( input ) || is_tspecial ( input )) { return bad ; } else { req . method . push_back ( input ); return indeterminate ; } case uri : if ( input == ' ' ) { state_ = http_version_h ; return indeterminate ; } else if ( is_ctl ( input )) { return bad ; } else { req . uri . push_back ( input ); return indeterminate ; } case http_version_h : if ( input == 'H' ) { state_ = http_version_t_1 ; return indeterminate ; } else { return bad ; } case http_version_t_1 : if ( input == 'T' ) { state_ = http_version_t_2 ; return indeterminate ; } else { return bad ; } case http_version_t_2 : if ( input == 'T' ) { state_ = http_version_p ; return indeterminate ; } else { return bad ; } case http_version_p : if ( input == 'P' ) { state_ = http_version_slash ; return indeterminate ; } else { return bad ; } case http_version_slash : if ( input == '/' ) { req . http_version_major = 0 ; req . http_version_minor = 0 ; state_ = http_version_major_start ; return indeterminate ; } else { return bad ; } case http_version_major_start : if ( is_digit ( input )) { req . http_version_major = req . http_version_major * 10 + input - '0' ; state_ = http_version_major ; return indeterminate ; } else { return bad ; } case http_version_major : if ( input == '.' ) { state_ = http_version_minor_start ; return indeterminate ; } else if ( is_digit ( input )) { req . http_version_major = req . http_version_major * 10 + input - '0' ; return indeterminate ; } else { return bad ; } case http_version_minor_start : if ( is_digit ( input )) { req . http_version_minor = req . http_version_minor * 10 + input - '0' ; state_ = http_version_minor ; return indeterminate ; } else { return bad ; } case http_version_minor : if ( input == '\\r' ) { state_ = expecting_newline_1 ; return indeterminate ; } else if ( is_digit ( input )) { req . http_version_minor = req . http_version_minor * 10 + input - '0' ; return indeterminate ; } else { return bad ; } case expecting_newline_1 : if ( input == '\\n' ) { state_ = header_line_start ; return indeterminate ; } else { return bad ; } case header_line_start : if ( input == '\\r' ) { state_ = expecting_newline_3 ; return indeterminate ; } else if ( ! req . headers . empty () && ( input == ' ' || input == '\\t' )) { state_ = header_lws ; return indeterminate ; } else if ( ! is_char ( input ) || is_ctl ( input ) || is_tspecial ( input )) { return bad ; } else { req . headers . push_back ( header ()); req . headers . back (). name . push_back ( input ); state_ = header_name ; return indeterminate ; } case header_lws : if ( input == '\\r' ) { state_ = expecting_newline_2 ; return indeterminate ; } else if ( input == ' ' || input == '\\t' ) { return indeterminate ; } else if ( is_ctl ( input )) { return bad ; } else { state_ = header_value ; req . headers . back (). value . push_back ( input ); return indeterminate ; } case header_name : if ( input == ':' ) { state_ = space_before_header_value ; return indeterminate ; } else if ( ! is_char ( input ) || is_ctl ( input ) || is_tspecial ( input )) { return bad ; } else { req . headers . back (). name . push_back ( input ); return indeterminate ; } case space_before_header_value : if ( input == ' ' ) { state_ = header_value ; return indeterminate ; } else { return bad ; } case header_value : if ( input == '\\r' ) { state_ = expecting_newline_2 ; return indeterminate ; } else if ( is_ctl ( input )) { return bad ; } else { req . headers . back (). value . push_back ( input ); return indeterminate ; } case expecting_newline_2 : if ( input == '\\n' ) { state_ = header_line_start ; return indeterminate ; } else { return bad ; } case expecting_newline_3 : return ( input == '\\n' ) ? good : bad ; default : return bad ; } } Check if c is char 1 bool request_parser::is_char ( int c ) { return c >= 0 && c <= 127 ; } Check if c is ctl 1 2 3 bool request_parser::is_ctl ( int c ) { return ( c >= 0 && c <= 31 ) || ( c == 127 ); } Check if c is special 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 bool request_parser::is_tspecial ( int c ) { switch ( c ) { case '(' : case ')' : case '<' : case '>' : case '@' : case ',' : case ';' : case ':' : case '\\\\' : case '\"' : case '/' : case '[' : case ']' : case '?' : case '=' : case '{' : case '}' : case ' ' : case '\\t' : return true ; default : return false ; } } Check if c is digit 1 bool request_parser::is_digit ( int c ) { return c >= '0' && c <= '9' ; } Share Snippets The common handler for all incoming requests. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class request_handler { public : request_handler ( const request_handler & ) = delete ; request_handler & operator = ( const request_handler & ) = delete ; // Construct with a directory containing files to be served. explicit request_handler ( const std :: string & doc_root ); // Handle a request and produce a reply. void handle_request ( const request & req , reply & rep ); private : // The directory containing the files to be served. std :: string doc_root_ ; // Perform URL-decoding on a string. Returns false if the encoding // was invalid. static bool url_decode ( const std :: string & in , std :: string & out ); }; Share Snippets Request handler constructor 1 2 request_handler :: request_handler ( const std :: string & doc_root ) : doc_root_ ( doc_root ) {} Handle a parsed request and generate reply 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 void request_handler::handle_request ( const request & req , reply & rep ) { // Decode url to path. std :: string request_path ; if ( ! url_decode ( req . uri , request_path )) { rep = reply :: stock_reply ( reply :: bad_request ); return ; } // Request path must be absolute and not contain \"..\". if ( request_path . empty () || request_path [ 0 ] != '/' || request_path . find ( \"..\" ) != std :: string :: npos ) { rep = reply :: stock_reply ( reply :: bad_request ); return ; } // If path ends in slash (i.e. is a directory) then add // \"index.html\". if ( request_path [ request_path . size () - 1 ] == '/' ) { request_path += \"index.html\" ; } // Determine the file extension. std :: size_t last_slash_pos = request_path . find_last_of ( \"/\" ); std :: size_t last_dot_pos = request_path . find_last_of ( \".\" ); std :: string extension ; if ( last_dot_pos != std :: string :: npos && last_dot_pos > last_slash_pos ) { extension = request_path . substr ( last_dot_pos + 1 ); } // Open the file to send back. std :: string full_path = doc_root_ + request_path ; std :: ifstream is ( full_path . c_str (), std :: ios :: in | std :: ios :: binary ); if ( ! is ) { rep = reply :: stock_reply ( reply :: not_found ); return ; } // Fill out the reply to be sent to the client. rep . status = reply :: ok ; char buf [ 512 ]; while ( is . read ( buf , sizeof ( buf )). gcount () > 0 ) rep . content . append ( buf , is . gcount ()); rep . headers . resize ( 2 ); rep . headers [ 0 ]. name = \"Content-Length\" ; rep . headers [ 0 ]. value = std :: to_string ( rep . content . size ()); rep . headers [ 1 ]. name = \"Content-Type\" ; rep . headers [ 1 ]. value = mime_types :: extension_to_type ( extension ); } Decode url string 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 bool request_handler::url_decode ( const std :: string & in , std :: string & out ) { out . clear (); out . reserve ( in . size ()); for ( std :: size_t i = 0 ; i < in . size (); ++ i ) { if ( in [ i ] == '%' ) { if ( i + 3 <= in . size ()) { int value = 0 ; std :: istringstream is ( in . substr ( i + 1 , 2 )); if ( is >> std :: hex >> value ) { out += static_cast < char > ( value ); i += 2 ; } else { return false ; } } else { return false ; } } else if ( in [ i ] == '+' ) { out += ' ' ; } else { out += in [ i ]; } } return true ; } Share Snippets Convert a file extension into a MIME type. 1 std :: string extension_to_type ( const std :: string & extension ); Share Snippets Map MIME types 1 2 3 4 5 6 7 8 constexpr struct mapping { const char * extension ; const char * mime_type ; } mappings [] = {{ \"gif\" , \"image/gif\" }, { \"htm\" , \"text/html\" }, { \"html\" , \"text/html\" }, { \"jpg\" , \"image/jpeg\" }, { \"png\" , \"image/png\" }}; Convert file extension to type 1 2 3 4 5 6 7 8 9 std :: string extension_to_type ( const std :: string & extension ) { for ( mapping m : mappings ) { if ( m . extension == extension ) { return m . mime_type ; } } return \"text/plain\" ; } Share Snippets","title":"Http server"},{"location":"utilities/networking/network/","text":"Network Find ASIO 1 2 3 4 5 6 7 8 9 10 11 12 find_package ( Asio 1.21.0 QUIET ) if ( NOT Asio_FOUND ) FetchContent_Declare ( asio GIT_REPOSITORY https://github.com/chriskohlhoff/asio.git GIT_TAG asio-1-21-0 ) FetchContent_GetProperties ( asio ) if ( NOT asio_POPULATED ) FetchContent_Populate ( asio ) add_library ( asio INTERFACE ) target_include_directories ( asio INTERFACE ${ asio_SOURCE_DIR } /asio/include ) target_compile_definitions ( asio INTERFACE ASIO_STANDALONE ASIO_NO_DEPRECATED ) target_link_libraries ( asio INTERFACE Threads::Threads ) endif () endif () CMakeLists.txt 1 2 add_executable ( network network.cpp ) target_link_libraries ( network asio ) Create io_context executor 1 2 3 4 5 // Object for network input and output // - All networking programs at least one io_context // - I/O execution context represents your program's link to the // operating system's I/O services asio :: io_context io_context ; Create acceptor 1 2 3 4 // The acceptor listens for connections // - Create the simplest server possible asio :: ip :: tcp :: endpoint ep ( asio :: ip :: tcp :: v4 (), 8080 ); asio :: ip :: tcp :: acceptor acceptor ( io_context , ep ); Create connection socket 1 2 3 4 5 6 7 // For loop listening to connections from client // - It will handle one connection at a time // - See the async example for more than one connection at a time while ( true ) { // Connection socket // - Represents the connection to the client asio :: ip :: tcp :: socket socket ( io_context ); or Create acceptor 1 2 3 4 // The acceptor listens for connections // - Create the simplest server possible asio :: ip :: tcp :: endpoint ep ( asio :: ip :: tcp :: v4 (), 8080 ); asio :: ip :: tcp :: acceptor acceptor ( io_context , ep ); Write response to client 1 2 3 // - Transfer this information to the client with the socket std :: error_code error ; asio :: write ( socket , asio :: buffer ( message ), error ); Check for errors 1 2 3 4 5 if ( error ) { std :: cout << \"Error \" << error . value () << \": \" << error . message () << std :: endl ; } } // while (true) Share Snippets","title":"Network"},{"location":"utilities/networking/network/#network","text":"Find ASIO 1 2 3 4 5 6 7 8 9 10 11 12 find_package ( Asio 1.21.0 QUIET ) if ( NOT Asio_FOUND ) FetchContent_Declare ( asio GIT_REPOSITORY https://github.com/chriskohlhoff/asio.git GIT_TAG asio-1-21-0 ) FetchContent_GetProperties ( asio ) if ( NOT asio_POPULATED ) FetchContent_Populate ( asio ) add_library ( asio INTERFACE ) target_include_directories ( asio INTERFACE ${ asio_SOURCE_DIR } /asio/include ) target_compile_definitions ( asio INTERFACE ASIO_STANDALONE ASIO_NO_DEPRECATED ) target_link_libraries ( asio INTERFACE Threads::Threads ) endif () endif () CMakeLists.txt 1 2 add_executable ( network network.cpp ) target_link_libraries ( network asio ) Create io_context executor 1 2 3 4 5 // Object for network input and output // - All networking programs at least one io_context // - I/O execution context represents your program's link to the // operating system's I/O services asio :: io_context io_context ; Create acceptor 1 2 3 4 // The acceptor listens for connections // - Create the simplest server possible asio :: ip :: tcp :: endpoint ep ( asio :: ip :: tcp :: v4 (), 8080 ); asio :: ip :: tcp :: acceptor acceptor ( io_context , ep ); Create connection socket 1 2 3 4 5 6 7 // For loop listening to connections from client // - It will handle one connection at a time // - See the async example for more than one connection at a time while ( true ) { // Connection socket // - Represents the connection to the client asio :: ip :: tcp :: socket socket ( io_context ); or Create acceptor 1 2 3 4 // The acceptor listens for connections // - Create the simplest server possible asio :: ip :: tcp :: endpoint ep ( asio :: ip :: tcp :: v4 (), 8080 ); asio :: ip :: tcp :: acceptor acceptor ( io_context , ep ); Write response to client 1 2 3 // - Transfer this information to the client with the socket std :: error_code error ; asio :: write ( socket , asio :: buffer ( message ), error ); Check for errors 1 2 3 4 5 if ( error ) { std :: cout << \"Error \" << error . value () << \": \" << error . message () << std :: endl ; } } // while (true) Share Snippets","title":"Network"},{"location":"utilities/regular-expressions/regex/","text":"Regex Regex The regular expressions library provides a class that represents regular expressions, which are a kind of mini-language used to perform pattern matching within strings. Headers 1 #include <regex> Match single expression 1 2 3 if ( std :: regex_match ( \"subject\" , std :: regex ( \"(sub)(.*)\" ))) { std :: cout << \"subject matches expression (sub)(.*)\" << '\\n' ; } Match string 1 2 3 4 5 6 const char cstr [] = \"subject\" ; std :: string s ( \"subject\" ); std :: regex e ( \"(sub) (. * ) \") ; if ( regex_match ( s , e )) { std :: cout << \"subject matches expression (sub)(.*)\" << '\\n' ; } Match char range 1 2 3 if ( std :: regex_match ( s . begin (), s . end (), e )) { std :: cout << \"subject matches expression (sub)(.*)\" << '\\n' ; } Store match results 1 2 std :: cmatch cm ; // same as `match_results<const char*>` std :: regex_match ( cstr , cm , e ); Access match results 1 2 3 4 5 6 std :: cout << \"literal string with \" << cm . size () << \" matches\" << '\\n' ; std :: cout << \"The literal string matches were: \" ; for ( const auto & i : cm ) { std :: cout << \"[\" << i << \"] \" ; } std :: cout << '\\n' ; Store string match results 1 2 std :: smatch sm ; // match_results<string::const_iterator> std :: regex_match ( s , sm , e ); Access string match results 1 2 3 4 5 6 std :: cout << \"string object with \" << sm . size () << \" matches\" << '\\n' ; std :: cout << \"The string matches were: \" ; for ( const auto & i : sm ) { std :: cout << \"[\" << i << \"] \" ; } std :: cout << '\\n' ; Store string match results 1 2 std :: smatch sm ; // match_results<string::const_iterator> std :: regex_match ( s , sm , e ); Using flags to determine behavior 1 std :: regex_match ( cstr , cm , e , std :: regex_constants :: match_default ); Iterate substrings with matches 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 std :: string ss = \"foo bar 123\" ; std :: regex r ( \"([a-zA-Z]+) | ( d + ) \") ; std :: sregex_iterator match_it ( ss . begin (), ss . end (), r ); for (; match_it != std :: sregex_iterator (); ++ match_it ) { std :: smatch m = * match_it ; // Match std :: cout << \"Match value: \" << m . str () << \" at position \" << m . position () << '\\n' ; // Groups for ( size_t index = 1 ; index < m . size (); ++ index ) { if ( ! m [ index ]. str (). empty ()) { std :: cout << \"Capture group ID: \" << index - 1 << '\\n' ; break ; } } } Regex expression conjunction 1 2 3 4 5 6 7 std :: string var = \"first second third forth\" ; if ( regex_match ( var , sm , std :: regex ( \"(.*) (.*) (.*) (.*)\" ))) { for ( size_t i = 1 ; i < sm . size (); i ++ ) { std :: cout << \"Match \" << i << \": \" << sm [ i ] << \" at position \" << sm . position ( i ) << '\\n' ; } } Helper function to implode strings 1 2 3 4 5 6 7 auto implode = []( const std :: vector < std :: string > & strs , const std :: string & delim ) { std :: stringstream s ; copy ( strs . begin (), strs . end (), std :: ostream_iterator < std :: string > ( s , delim . c_str ())); return s . str (); }; Regex expression string disjunction 1 2 3 4 5 var = \"user/32\" ; std :: smatch sm2 ; std :: vector < std :: string > routes = { \"welcome\" , \"user/ \\\\ d+\" , \"post/[a-zA-Z]+\" , \"about\" }; std :: regex disjunction ( \"(\" + implode ( routes , \") | ( \") + \" ) \") ; Match disjunction 1 2 3 4 5 6 7 8 9 10 11 if ( std :: regex_match ( var , sm2 , disjunction , std :: regex_constants :: match_not_null )) { for ( size_t index = 1 ; index < sm2 . size (); ++ index ) { if ( sm2 [ index ]. length () > 0 ) { std :: cout << \"Capture group index: \" << index - 1 << '\\n' ; std :: cout << var << \" matched route \" << routes [ index - 1 ] << '\\n' ; break ; } } } Share Snippets","title":"Regex"},{"location":"utilities/regular-expressions/regex/#regex","text":"Regex The regular expressions library provides a class that represents regular expressions, which are a kind of mini-language used to perform pattern matching within strings. Headers 1 #include <regex> Match single expression 1 2 3 if ( std :: regex_match ( \"subject\" , std :: regex ( \"(sub)(.*)\" ))) { std :: cout << \"subject matches expression (sub)(.*)\" << '\\n' ; } Match string 1 2 3 4 5 6 const char cstr [] = \"subject\" ; std :: string s ( \"subject\" ); std :: regex e ( \"(sub) (. * ) \") ; if ( regex_match ( s , e )) { std :: cout << \"subject matches expression (sub)(.*)\" << '\\n' ; } Match char range 1 2 3 if ( std :: regex_match ( s . begin (), s . end (), e )) { std :: cout << \"subject matches expression (sub)(.*)\" << '\\n' ; } Store match results 1 2 std :: cmatch cm ; // same as `match_results<const char*>` std :: regex_match ( cstr , cm , e ); Access match results 1 2 3 4 5 6 std :: cout << \"literal string with \" << cm . size () << \" matches\" << '\\n' ; std :: cout << \"The literal string matches were: \" ; for ( const auto & i : cm ) { std :: cout << \"[\" << i << \"] \" ; } std :: cout << '\\n' ; Store string match results 1 2 std :: smatch sm ; // match_results<string::const_iterator> std :: regex_match ( s , sm , e ); Access string match results 1 2 3 4 5 6 std :: cout << \"string object with \" << sm . size () << \" matches\" << '\\n' ; std :: cout << \"The string matches were: \" ; for ( const auto & i : sm ) { std :: cout << \"[\" << i << \"] \" ; } std :: cout << '\\n' ; Store string match results 1 2 std :: smatch sm ; // match_results<string::const_iterator> std :: regex_match ( s , sm , e ); Using flags to determine behavior 1 std :: regex_match ( cstr , cm , e , std :: regex_constants :: match_default ); Iterate substrings with matches 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 std :: string ss = \"foo bar 123\" ; std :: regex r ( \"([a-zA-Z]+) | ( d + ) \") ; std :: sregex_iterator match_it ( ss . begin (), ss . end (), r ); for (; match_it != std :: sregex_iterator (); ++ match_it ) { std :: smatch m = * match_it ; // Match std :: cout << \"Match value: \" << m . str () << \" at position \" << m . position () << '\\n' ; // Groups for ( size_t index = 1 ; index < m . size (); ++ index ) { if ( ! m [ index ]. str (). empty ()) { std :: cout << \"Capture group ID: \" << index - 1 << '\\n' ; break ; } } } Regex expression conjunction 1 2 3 4 5 6 7 std :: string var = \"first second third forth\" ; if ( regex_match ( var , sm , std :: regex ( \"(.*) (.*) (.*) (.*)\" ))) { for ( size_t i = 1 ; i < sm . size (); i ++ ) { std :: cout << \"Match \" << i << \": \" << sm [ i ] << \" at position \" << sm . position ( i ) << '\\n' ; } } Helper function to implode strings 1 2 3 4 5 6 7 auto implode = []( const std :: vector < std :: string > & strs , const std :: string & delim ) { std :: stringstream s ; copy ( strs . begin (), strs . end (), std :: ostream_iterator < std :: string > ( s , delim . c_str ())); return s . str (); }; Regex expression string disjunction 1 2 3 4 5 var = \"user/32\" ; std :: smatch sm2 ; std :: vector < std :: string > routes = { \"welcome\" , \"user/ \\\\ d+\" , \"post/[a-zA-Z]+\" , \"about\" }; std :: regex disjunction ( \"(\" + implode ( routes , \") | ( \") + \" ) \") ; Match disjunction 1 2 3 4 5 6 7 8 9 10 11 if ( std :: regex_match ( var , sm2 , disjunction , std :: regex_constants :: match_not_null )) { for ( size_t index = 1 ; index < sm2 . size (); ++ index ) { if ( sm2 [ index ]. length () > 0 ) { std :: cout << \"Capture group index: \" << index - 1 << '\\n' ; std :: cout << var << \" matched route \" << routes [ index - 1 ] << '\\n' ; break ; } } } Share Snippets","title":"Regex"}]}